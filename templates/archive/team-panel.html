<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Panel - Adzsend</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='responsive.css') }}">
    {% include 'partials/config_styles.html' %}
    <script src="{{ url_for('static', filename='tab_enforcement.js') }}"></script>
    <script src="{{ url_for('static', filename='status_polling.js') }}"></script>
    <script>
        window.DB_VERSION = {{ db_version }};
        window.DB_WIPE_MESSAGE = "{{ db_wipe_message }}";
    </script>
    <script src="{{ url_for('static', filename='db_wipe_notice.js') }}"></script>
    <script src="{{ url_for('static', filename='custom_modals.js') }}"></script>
</head>
<body>
    <div class="panel">
        <nav class="navbar">
            <div class="navbar-content">
                <div class="navbar-left">
                    <div class="menu-icon" id="menu-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="3" y1="12" x2="21" y2="12"></line>
                            <line x1="3" y1="6" x2="21" y2="6"></line>
                            <line x1="3" y1="18" x2="21" y2="18"></line>
                        </svg>
                    </div>
                    <div class="navbar-text">
                        <h1 class="navbar-title">Ad <span class="gradient-z">Z</span> send</h1>
                        <p class="navbar-subtitle">Send team advertisements using the shared message set by your team owner</p>
                    </div>
                </div>
                {% if user %}
                <div class="nav-right">
                    <div style="display: flex; flex-direction: row; align-items: center; gap: 12px; background: #1A1A1E; padding: 8px 12px; border-radius: 8px; box-shadow: none;">
                        <div style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden; flex-shrink: 0;">
                            <img src="{{ url_for('static', filename='profile_photos/' ~ (user_data.profile_photo if user_data and user_data.profile_photo else 'Light_Blue.jpg')) }}" alt="Profile" style="width: 100%; height: 100%; object-fit: cover;">
                        </div>
                        <span style="color: #dcddde; font-size: 0.9rem;">Welcome!</span>
                        <img src="{{ url_for('static', filename='gear.png') }}" alt="Settings" title="Settings" style="width: 20px; height: 20px; cursor: pointer; filter: brightness(0) saturate(100%) invert(55%) sepia(5%) saturate(368%) hue-rotate(202deg) brightness(92%) contrast(87%);" onclick="window.location.href='{{ url_for('settings') }}'">
                    </div>
                </div>
                {% else %}
                <div class="nav-right"></div>
                {% endif %}
            </div>

            <!-- Dropdown Menu -->
            <div class="dropdown-menu" id="dropdown-menu">
                <a href="{{ url_for('home') }}" class="dropdown-item">Home</a>
                <a href="{{ url_for('purchase') }}" class="dropdown-item">Purchase</a>
                {% if not (plan_status and plan_status.plan_id and plan_status.plan_id.startswith('team_plan_')) %}
                <a href="{{ url_for('panel') }}" class="dropdown-item">Personal Panel</a>
                {% endif %}
                {% if has_business %}
                {% if is_owner %}
                <a href="{{ url_for('team_management') }}" class="dropdown-item">Team management</a>
                {% endif %}
                <a href="{{ url_for('team_panel') }}" class="dropdown-item">Team panel</a>
                {% endif %}
                <a href="{{ url_for('settings') }}" class="dropdown-item">Settings</a>
                {% if is_admin_user %}
                <a href="{{ url_for('admin_panel') }}" class="dropdown-item">Admin</a>
                {% endif %}
                <div class="dropdown-divider"></div>
                <a href="https://discord.gg/KWt6rvCukp" target="_blank" class="dropdown-item discord-item">Discord Server</a>
                <a href="{{ url_for('logout') }}" class="dropdown-item logout-item">Logout</a>
            </div>
        </nav>

        <div class="panel-container">
            {% if is_banned %}
            <!-- Banned User Overlay -->
            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 1000; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 1rem;">
                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#991a35" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>
                </svg>
                <h2 style="color: #991a35; margin: 0;">Account Banned</h2>
                <p style="color: #81828A; margin: 0; text-align: center; max-width: 400px;">Your account has been banned from using the panel. If you believe this is a mistake, please contact support.</p>
            </div>
            {% endif %}

            {% if guilds %}
                <div class="main-layout">
                    <!-- Left: Server and Channel Selection -->
                    <div class="selection-panel">
                        <!-- View Mode Toggle -->
                        <div class="view-mode-toggle" style="display: flex; gap: 0; padding: 0.5rem 1rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <button class="view-mode-btn active" data-mode="servers" style="flex: 1; padding: 0.5rem 1rem; background: linear-gradient(to bottom, #15d8bc, #006e59); border: 1px solid transparent; border-radius: 6px 0 0 6px; color: #121215; font-weight: 500; cursor: pointer; transition: all 0.2s ease; box-sizing: border-box;">Show servers and channels</button>
                            <button class="view-mode-btn" data-mode="channels" style="flex: 1; padding: 0.5rem 1rem; background: linear-gradient(to bottom, rgba(21, 216, 188, 0.15), rgba(0, 110, 89, 0.15)); border: 1px solid transparent; border-radius: 0 6px 6px 0; color: #15d8bc; font-weight: 500; cursor: pointer; transition: all 0.2s ease; box-sizing: border-box;">Show channels only</button>
                        </div>

                        <!-- Unified Header for Left Panel (Servers Mode) -->
                        <div class="unified-header servers-mode-header">
                            <div class="header-section">
                                <div class="panel-header" style="margin-top: 0.75rem;">Your servers</div>
                                <div class="server-search-container">
                                    <input type="text" id="server-search" class="search-input" placeholder="Search">
                                </div>
                            </div>
                        </div>

                        <!-- Channels Only Mode Header -->
                        <div class="unified-header channels-only-header" style="display: none;">
                            <div class="header-section">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.75rem; margin-bottom: 0.5rem;">
                                    <div class="panel-header" style="margin: 0;">All channels</div>
                                    <span style="color: #81828A; font-size: 0.7rem; font-style: italic;">All channels shown regardless of permissions</span>
                                </div>
                                <div class="server-search-container">
                                    <input type="text" id="channels-only-search" class="search-input" placeholder="Search">
                                    <div class="search-tags" id="channels-only-search-tags"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Server List (Servers Mode) -->
                        <div class="servers-section servers-mode-section">
                            <div id="servers-list" class="servers-list">
                                <!-- Servers will be populated by JavaScript -->
                            </div>
                        </div>

                        <!-- Channels List (Servers Mode) -->
                        <div class="channels-section servers-mode-section">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <div class="panel-header" style="margin: 0;">Channels</div>
                                <span style="color: #81828A; font-size: 0.7rem; font-style: italic;">All channels shown regardless of permissions</span>
                            </div>

                            <!-- Search Bar -->
                            <div class="channels-search" style="margin-bottom: 0;">
                                <input type="text" id="channel-search" class="search-input" placeholder="Search">
                                <div class="search-tags" id="search-tags"></div>
                            </div>

                            <div id="channels-list" class="channels-list">
                                <div class="no-selection">Select a server to view channels</div>
                            </div>
                        </div>

                        <!-- Channels Only List (Channels Only Mode) -->
                        <div class="channels-only-section" style="display: none; flex: 1; flex-direction: column; min-height: 0;">
                            <div id="channels-only-list" class="channels-list" style="flex: 1; overflow-y: auto;">
                                <div class="no-selection">Loading channels...</div>
                            </div>
                        </div>
                    </div>

                    <!-- Right: Selected Channels and Team Message -->
                    <div class="action-panel">
                        <!-- Unified Header for Right Panel -->
                        <div class="unified-header">
                            <div class="header-section">
                                <div class="panel-header">Selected channels</div>
                                <div class="selected-search-container">
                                    <input type="text" id="selected-search" class="search-input" placeholder="Search">
                                </div>
                            </div>
                        </div>

                        <!-- Selected Channels -->
                        <div class="selected-section">
                            <button class="clear-all-btn" id="clear-all-btn" style="display: none;">Clear all selected channels</button>
                            <div id="selected-channels-tags" class="selected-channels-tags">
                                <div class="no-selection">No channels selected</div>
                            </div>
                        </div>

                        <!-- Team Message Display (Read-only) -->
                        <div class="message-section">
                            <div class="team-message-notice" style="margin-bottom: 0.75rem;">
                                <p style="color: #faa61a; font-size: 0.85rem; margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="flex-shrink: 0;">
                                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                                    </svg>
                                    Team message contents are managed by the team owner in Team management.
                                </p>
                            </div>
                            <textarea id="message-input" class="message-input" placeholder="Team message will appear here..." maxlength="2000" readonly style="cursor: not-allowed; opacity: 0.8;">{{ team.team_message or '' }}</textarea>
                            <div class="message-footer">
                                <span class="char-count"><span id="char-count">{{ (team.team_message or '')|length }}</span>/2000</span>
                                <button id="send-btn" class="send-button" {% if not team.team_message %}disabled{% endif %}>
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="22" y1="2" x2="11" y2="13"></line>
                                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                                    </svg>
                                    Send
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            {% else %}
                {% if not discord_linked %}
                    <!-- No Discord account linked -->
                    <div class="empty-state" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: calc(100vh - 120px);">
                        <h2 style="color: #dcddde; font-size: 1.5rem; margin-bottom: 1rem;">No Discord account linked</h2>
                        <button class="discord-btn" onclick="window.location.href='{{ url_for('settings') }}'" style="padding: 0.75rem 1.5rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                            </svg>
                            Link Discord Account
                        </button>
                    </div>
                {% else %}
                    <!-- Discord linked but no servers -->
                    <div class="empty-state" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: calc(100vh - 120px);">
                        <h2 style="color: #dcddde; font-size: 1.5rem;">Not in any Discord servers with linked account</h2>
                    </div>
                {% endif %}
            {% endif %}
        </div>
    </div>

    <!-- Tag Limit Popup Modal -->
    <div id="tag-limit-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: #191A1F; border-radius: 12px; padding: 1.5rem; max-width: 400px; width: 90%; text-align: center; display: flex; flex-direction: column; gap: 1rem;">
            <h2 style="color: #dcddde; margin: 0; font-size: 1.25rem;">Tag limit reached</h2>
            <p style="color: #81828A; margin: 0; font-size: 0.9rem;">Maximum 6 tags allowed. Please remove a tag before adding a new one.</p>
            <button class="grey-btn" onclick="closeTagLimitModal()" style="padding: 0.6rem 2rem;">OK</button>
        </div>
    </div>

    <!-- Channel Limit Per Server Modal -->
    <div id="channel-limit-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: #191A1F; border-radius: 12px; padding: 1.5rem; max-width: 400px; width: 90%; text-align: center; display: flex; flex-direction: column; gap: 1rem;">
            <h2 style="color: #dcddde; margin: 0; font-size: 1.25rem;">Channel limit reached</h2>
            <p id="channel-limit-message" style="color: #81828A; margin: 0; font-size: 0.9rem;">You can only select up to X channels per server on your current plan.</p>
            <button class="grey-btn" onclick="closeChannelLimitModal()" style="padding: 0.6rem 2rem;">OK</button>
        </div>
    </div>

    <script>
        // Tag Limit Modal functions
        function showTagLimitModal() {
            document.getElementById('tag-limit-modal').style.display = 'flex';
        }

        function closeTagLimitModal() {
            document.getElementById('tag-limit-modal').style.display = 'none';
        }

        // Channel Limit Modal functions
        function showChannelLimitModal(limit) {
            document.getElementById('channel-limit-message').textContent =
                `You can only select up to ${limit} channel${limit !== 1 ? 's' : ''} per server on your current plan.`;
            document.getElementById('channel-limit-modal').style.display = 'flex';
        }

        function closeChannelLimitModal() {
            document.getElementById('channel-limit-modal').style.display = 'none';
        }

        // Close modals when clicking outside
        document.getElementById('tag-limit-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeTagLimitModal();
            }
        });
        document.getElementById('channel-limit-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeChannelLimitModal();
            }
        });

        // Prevent page from being stored in cache
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                window.location.reload();
            }
        });

        // Team message that will be used for all sends
        const TEAM_MESSAGE = {{ (team.team_message or '')|tojson }};

        // Wait for all elements to load before initializing
        document.addEventListener('DOMContentLoaded', function() {
            const serversList = document.getElementById('servers-list');
            const channelsList = document.getElementById('channels-list');
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const charCount = document.getElementById('char-count');
            const selectedChannelsTags = document.getElementById('selected-channels-tags');
            const channelSearch = document.getElementById('channel-search');
            const searchTagsContainer = document.getElementById('search-tags');
            const serverSearch = document.getElementById('server-search');
            const selectedSearch = document.getElementById('selected-search');

            let guilds = [];
            let serverChannels = {}; // Cache for channels by guild ID
            let selectedChannels = []; // Array for multiple channel selection
            let selectedGuild = null; // Currently selected guild
            let searchTags = []; // Search filter tags
            let serverSearchText = ''; // Server search filter
            let selectedSearchText = ''; // Selected channels search filter
            let currentServerColor = 'rgba(51, 95, 255, 0.6)'; // Current server's dominant color
            let isSending = false; // Track if messages are being sent
            let failedChannels = new Map(); // Track channels that failed to send with failure type
            let viewMode = 'servers'; // 'servers' or 'channels'
            let channelsOnlySearchText = ''; // Search filter for channels-only mode
            let channelsOnlySearchTags = []; // Search filter tags for channels-only mode
            const maxChannelsPerServer = {{ plan_status.max_channels_per_server if plan_status and plan_status.max_channels_per_server is defined else -1 }}; // -1 = unlimited

            // View mode toggle elements
            const viewModeButtons = document.querySelectorAll('.view-mode-btn');
            const serversModeHeader = document.querySelector('.servers-mode-header');
            const channelsOnlyHeader = document.querySelector('.channels-only-header');
            const serversModeSections = document.querySelectorAll('.servers-mode-section');
            const channelsOnlySection = document.querySelector('.channels-only-section');
            const channelsOnlyList = document.getElementById('channels-only-list');
            const channelsOnlySearch = document.getElementById('channels-only-search');
            const channelsOnlySearchTagsContainer = document.getElementById('channels-only-search-tags');

            // View mode toggle handler
            viewModeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    if (mode === viewMode) return;

                    viewMode = mode;

                    // Update button styles
                    viewModeButtons.forEach(b => {
                        if (b.dataset.mode === mode) {
                            b.classList.add('active');
                            b.style.background = 'linear-gradient(to bottom, #15d8bc, #006e59)';
                            b.style.color = '#121215';
                        } else {
                            b.classList.remove('active');
                            b.style.background = 'linear-gradient(to bottom, rgba(21, 216, 188, 0.15), rgba(0, 110, 89, 0.15))';
                            b.style.color = '#15d8bc';
                        }
                    });

                    // Toggle visibility
                    if (mode === 'servers') {
                        serversModeHeader.style.display = '';
                        channelsOnlyHeader.style.display = 'none';
                        serversModeSections.forEach(s => s.style.display = '');
                        channelsOnlySection.style.display = 'none';
                    } else {
                        serversModeHeader.style.display = 'none';
                        channelsOnlyHeader.style.display = '';
                        serversModeSections.forEach(s => s.style.display = 'none');
                        channelsOnlySection.style.display = 'flex';
                        renderChannelsOnlyMode();
                    }
                });
            });

            // Channels-only search handler
            if (channelsOnlySearch) {
                channelsOnlySearch.addEventListener('input', (e) => {
                    channelsOnlySearchText = e.target.value.toLowerCase();
                    renderChannelsOnlyMode();
                });
                channelsOnlySearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && channelsOnlySearch.value.trim()) {
                        addChannelsOnlySearchTag(channelsOnlySearch.value);
                    }
                });
            }

            // Add search tag for channels-only mode
            function addChannelsOnlySearchTag(text) {
                if (channelsOnlySearchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                if (!channelsOnlySearchTags.includes(text.toLowerCase()) && text.trim()) {
                    channelsOnlySearchTags.push(text.toLowerCase());
                    updateChannelsOnlySearchTagsDisplay();
                    channelsOnlySearch.value = '';
                    channelsOnlySearchText = '';
                    renderChannelsOnlyMode();
                }
            }

            // Remove search tag for channels-only mode
            function removeChannelsOnlySearchTag(tag) {
                channelsOnlySearchTags = channelsOnlySearchTags.filter(t => t !== tag);
                updateChannelsOnlySearchTagsDisplay();
                renderChannelsOnlyMode();
            }

            // Update search tags display for channels-only mode
            function updateChannelsOnlySearchTagsDisplay() {
                if (!channelsOnlySearchTagsContainer) return;
                channelsOnlySearchTagsContainer.innerHTML = '';
                channelsOnlySearchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}">✕</span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        removeChannelsOnlySearchTag(tag);
                    });
                    channelsOnlySearchTagsContainer.appendChild(tagEl);
                });
            }

            // Render channels in channels-only mode (with server icons)
            function renderChannelsOnlyMode() {
                if (!channelsOnlyList) return;

                // Check if any channels have been loaded
                const hasLoadedChannels = Object.keys(serverChannels).length > 0;

                // Collect all channels from all servers
                let allChannels = [];
                for (const guild of guilds) {
                    const channels = serverChannels[guild.id] || [];
                    for (const channel of channels) {
                        allChannels.push({
                            ...channel,
                            guildId: guild.id,
                            guildName: guild.name,
                            guildIcon: guild.icon
                        });
                    }
                }

                // Filter by search tags (OR logic - any tag matches)
                if (channelsOnlySearchTags.length > 0) {
                    allChannels = allChannels.filter(ch =>
                        channelsOnlySearchTags.some(tag =>
                            ch.name.toLowerCase().includes(tag) ||
                            ch.guildName.toLowerCase().includes(tag)
                        )
                    );
                }

                // Filter by search text
                if (channelsOnlySearchText) {
                    allChannels = allChannels.filter(ch =>
                        ch.name.toLowerCase().includes(channelsOnlySearchText) ||
                        ch.guildName.toLowerCase().includes(channelsOnlySearchText)
                    );
                }

                if (allChannels.length === 0) {
                    if (!hasLoadedChannels) {
                        // Channels haven't been loaded yet - show loading message
                        channelsOnlyList.innerHTML = '<div class="no-selection">Loading channels...</div>';
                    } else if (channelsOnlySearchText || channelsOnlySearchTags.length > 0) {
                        // Channels loaded but filtered to empty
                        channelsOnlyList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    } else {
                        // Channels loaded but none available
                        channelsOnlyList.innerHTML = '<div class="no-selection">No channels found</div>';
                    }
                    return;
                }

                channelsOnlyList.innerHTML = allChannels.map(channel => {
                    const isSelected = selectedChannels.some(ch => ch.id === channel.id);
                    const iconUrl = channel.guildIcon
                        ? `https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png`
                        : null;

                    return `
                        <div class="channel-item ${isSelected ? 'selected' : ''}"
                             data-channel-id="${channel.id}"
                             data-channel-name="${channel.name}"
                             data-guild-id="${channel.guildId}"
                             data-guild-name="${channel.guildName}"
                             data-guild-icon="${channel.guildIcon || ''}">
                            <img class="channel-tick" src="{{ url_for('static', filename='tick.png') }}" alt="✓" width="16" height="16" style="display: ${isSelected ? 'inline-block' : 'none'}; flex-shrink: 0;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1; min-width: 0;">
                                ${iconUrl
                                    ? `<img src="${iconUrl}" style="width: 20px; height: 20px; border-radius: 50%; flex-shrink: 0;">`
                                    : `<div style="width: 20px; height: 20px; border-radius: 50%; background: #5865f2; display: flex; align-items: center; justify-content: center; font-size: 10px; color: #fff; flex-shrink: 0;">${channel.guildName[0].toUpperCase()}</div>`
                                }
                                <span class="channel-name" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"># ${channel.name}</span>
                            </div>
                            <span class="channel-guild" style="color: #81828A; font-size: 0.75rem; flex-shrink: 0;">${channel.guildName}</span>
                        </div>
                    `;
                }).join('');

                // Add click handlers
                channelsOnlyList.querySelectorAll('.channel-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const channelId = item.dataset.channelId;
                        const channelName = item.dataset.channelName;
                        const guildId = item.dataset.guildId;
                        const guildName = item.dataset.guildName;
                        const guildIcon = item.dataset.guildIcon;

                        toggleChannelSelection({
                            id: channelId,
                            name: channelName,
                            guildId: guildId,
                            guildName: guildName,
                            guildIcon: guildIcon
                        });

                        // Update selection state with glow color
                        const isNowSelected = selectedChannels.some(ch => ch.id === channelId);
                        const tickIcon = item.querySelector('.channel-tick');
                        if (isNowSelected) {
                            item.classList.add('selected');
                            if (tickIcon) tickIcon.style.display = 'inline-block';
                            // Apply glow based on guild's dominant color
                            if (guildIcon) {
                                const iconUrl = `https://cdn.discordapp.com/icons/${guildId}/${guildIcon}.png`;
                                getDominantColor(iconUrl, (color) => {
                                    item.style.borderColor = color;
                                    item.style.boxShadow = `0 0 15px ${color.replace('rgb', 'rgba').replace(')', ', 0.4)')}`;
                                });
                            } else {
                                // Default purple glow for servers without icons
                                item.style.borderColor = 'rgba(21, 216, 188, 0.6)';
                                item.style.boxShadow = '0 0 15px rgba(21, 216, 188, 0.4)';
                            }
                        } else {
                            item.classList.remove('selected');
                            if (tickIcon) tickIcon.style.display = 'none';
                            item.style.borderColor = '';
                            item.style.boxShadow = '';
                        }
                    });
                });

                // Apply glow to already-selected channels
                channelsOnlyList.querySelectorAll('.channel-item.selected').forEach(item => {
                    const guildId = item.dataset.guildId;
                    const guildIcon = item.dataset.guildIcon;
                    if (guildIcon) {
                        const iconUrl = `https://cdn.discordapp.com/icons/${guildId}/${guildIcon}.png`;
                        getDominantColor(iconUrl, (color) => {
                            item.style.borderColor = color;
                            item.style.boxShadow = `0 0 15px ${color.replace('rgb', 'rgba').replace(')', ', 0.4)')}`;
                        });
                    } else {
                        // Default purple glow for servers without icons
                        item.style.borderColor = 'rgba(21, 216, 188, 0.6)';
                        item.style.boxShadow = '0 0 15px rgba(21, 216, 188, 0.4)';
                    }
                });
            }

            // Check if team message exists
            if (!TEAM_MESSAGE) {
                if (messageInput) {
                    messageInput.placeholder = "No team message set. Please contact your team owner.";
                }
            }

            // Check session on API error
            async function handleSessionError(response) {
                if (response.status === 401) {
                    // Session expired or token invalid - redirect to settings
                    window.location.href = '/settings';
                }
                return false;
            }

            // Warn user before leaving if messages are being sent
            window.addEventListener('beforeunload', (e) => {
                if (isSending) {
                    e.preventDefault();
                    e.returnValue = '';
                    return '';
                }
            });

            // Dropdown menu toggle
            const menuIcon = document.getElementById('menu-icon');
            const dropdownMenu = document.getElementById('dropdown-menu');

            if (menuIcon) {
                menuIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    dropdownMenu.classList.toggle('show');
                });
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (dropdownMenu && !dropdownMenu.contains(e.target) && menuIcon && !menuIcon.contains(e.target)) {
                    dropdownMenu.classList.remove('show');
                }
            });

            // Load saved data from localStorage (persists across sessions)
            function loadSelectedChannels() {
                const saved = localStorage.getItem('businessSelectedChannels');
                if (saved) {
                    try {
                        selectedChannels = JSON.parse(saved);
                    } catch (e) {
                        console.error('Error loading saved channels:', e);
                        selectedChannels = [];
                    }
                }
            }

            // Load user data from database (business panel specific)
            async function loadUserDataFromDB() {
                try {
                    const response = await fetch('/api/get-user-data');
                    if (response.ok) {
                        const data = await response.json();

                        // Load business selected channels if available
                        if (data.business_selected_channels && Array.isArray(data.business_selected_channels)) {
                            selectedChannels = data.business_selected_channels;
                            localStorage.setItem('businessSelectedChannels', JSON.stringify(selectedChannels));
                        }

                        return true;
                    } else {
                        console.warn('Failed to load user data from database, using localStorage fallback');
                        return false;
                    }
                } catch (error) {
                    console.error('Error loading user data from database:', error);
                    return false;
                }
            }

            // Save user data to database (business panel specific)
            async function saveUserDataToDB() {
                try {
                    const response = await fetch('/api/save-user-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-Token': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({
                            business_selected_channels: selectedChannels
                        })
                    });

                    if (!response.ok) {
                        console.warn('Failed to save user data to database');
                        return false;
                    }

                    return true;
                } catch (error) {
                    console.error('Error saving user data to database:', error);
                    return false;
                }
            }

            // Save data to localStorage (persists across sessions)
            function saveSelectedChannels() {
                localStorage.setItem('businessSelectedChannels', JSON.stringify(selectedChannels));
                // Also save to database
                saveUserDataToDB();
            }

            // Add search tag
            function addSearchTag(text) {
                if (searchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                if (!searchTags.includes(text.toLowerCase()) && text.trim()) {
                    searchTags.push(text.toLowerCase());
                    updateSearchTagsDisplay();
                    channelSearch.value = '';
                    if (selectedGuild) {
                        renderChannels();
                    }
                }
            }

            // Remove search tag
            function removeSearchTag(tag) {
                searchTags = searchTags.filter(t => t !== tag);
                updateSearchTagsDisplay();
                if (selectedGuild) {
                    renderChannels();
                }
            }

            // Update search tags display
            function updateSearchTagsDisplay() {
                searchTagsContainer.innerHTML = '';
                searchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}">✕</span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        removeSearchTag(tag);
                    });
                    searchTagsContainer.appendChild(tagEl);
                });
            }

            // Handle channel search input
            if (channelSearch) {
                channelSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && channelSearch.value.trim()) {
                        addSearchTag(channelSearch.value);
                    }
                });
            }

            // Handle server search input
            if (serverSearch) {
                serverSearch.addEventListener('input', (e) => {
                    serverSearchText = e.target.value.toLowerCase();
                    renderServers();
                });
            }

            // Handle selected channels search input
            if (selectedSearch) {
                selectedSearch.addEventListener('input', (e) => {
                    selectedSearchText = e.target.value.toLowerCase();
                    updateSelectedDisplay();
                });
            }

            // Render servers list with search filter
            function renderServers() {
                if (!serversList) return;

                serversList.innerHTML = '';

                if (!guilds || guilds.length === 0) {
                    serversList.innerHTML = '<div style="color: #81828A; padding: 1rem;">No servers found</div>';
                    return;
                }

                // Filter guilds by search text
                const filteredGuilds = guilds.filter(guild =>
                    guild.name.toLowerCase().includes(serverSearchText)
                );

                if (filteredGuilds.length === 0) {
                    serversList.innerHTML = '<div style="color: #81828A; padding: 1rem;">No servers match search</div>';
                    return;
                }

                filteredGuilds.forEach(guild => {
                    const serverItem = document.createElement('div');
                    serverItem.className = 'server-item';
                    serverItem.dataset.guildId = guild.id;

                    const iconHtml = guild.icon
                        ? `<img src="https://cdn.discordapp.com/icons/${guild.id}/${guild.icon}.png" alt="${guild.name}" class="server-icon">`
                        : `<div class="server-icon-placeholder">${guild.name.charAt(0).toUpperCase()}</div>`;

                    serverItem.innerHTML = `
                        ${iconHtml}
                        <div class="server-info">
                            <div class="server-name">${guild.name}</div>
                            <div class="server-count" style="display: none;">0 selected</div>
                        </div>
                    `;

                    serverItem.addEventListener('click', () => selectServer(guild));
                    serversList.appendChild(serverItem);

                    // Update server count based on saved selections
                    updateServerCount(guild.id);

                    // Restore active state if this is the selected guild
                    if (selectedGuild && selectedGuild.id === guild.id) {
                        serverItem.classList.add('active');
                    }
                });
            }

            // Preload all channels for all guilds (for channels-only mode)
            async function preloadAllChannels() {
                const promises = guilds.map(async (guild) => {
                    if (!serverChannels[guild.id]) {
                        try {
                            const response = await fetch(`/api/guild/${guild.id}/channels`);
                            const data = await response.json();

                            if (data.token_invalid) {
                                return; // Skip, will handle redirect elsewhere
                            }

                            if (data.channels) {
                                serverChannels[guild.id] = data.channels.filter(ch => ch.type === 0);
                            } else {
                                serverChannels[guild.id] = [];
                            }

                            // Update channels-only view progressively as each guild loads
                            if (viewMode === 'channels') {
                                renderChannelsOnlyMode();
                            }
                        } catch (error) {
                            console.error(`Error preloading channels for ${guild.name}:`, error);
                            serverChannels[guild.id] = [];
                        }
                    }
                });

                await Promise.all(promises);
            }

            // Fetch all guilds and build UI
            async function initializeUI() {
                // Load from localStorage first (instant)
                loadSelectedChannels();

                // Then load from database (syncs across devices)
                await loadUserDataFromDB();

                guilds = {{ guilds|tojson }};

                // Render servers
                renderServers();

                // Update selected display
                updateSelectedDisplay();
                updateSendButton();

                // Preload all channels in background for faster channel-only mode
                preloadAllChannels();
            }

            // Extract dominant color from image
            function getDominantColor(imageUrl, callback) {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    let r = 0, g = 0, b = 0, count = 0;

                    // Sample every 10th pixel for performance
                    for (let i = 0; i < data.length; i += 40) {
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        count++;
                    }

                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    callback(`rgb(${r}, ${g}, ${b})`);
                };
                img.onerror = function() {
                    callback('rgba(51, 95, 255, 0.6)'); // Fallback to default blue
                };
                img.src = imageUrl;
            }

            // Select a server and load its channels
            async function selectServer(guild) {
                // Set selected guild immediately
                selectedGuild = guild;
                const guildId = guild.id;

                // Update active state
                document.querySelectorAll('.server-item').forEach(item => {
                    item.classList.remove('active');
                    item.style.borderColor = '';
                    item.style.boxShadow = '';
                });

                const activeItem = document.querySelector(`[data-guild-id="${guildId}"]`);
                if (activeItem) {
                    activeItem.classList.add('active');
                }

                // Apply dominant color from server icon
                if (guild.icon) {
                    const iconUrl = `https://cdn.discordapp.com/icons/${guildId}/${guild.icon}.png`;
                    getDominantColor(iconUrl, (color) => {
                        // Only update if this guild is still selected
                        if (selectedGuild && selectedGuild.id === guildId) {
                            currentServerColor = color;
                            if (activeItem) {
                                activeItem.style.borderColor = color;
                                activeItem.style.boxShadow = `0 0 15px ${color.replace('rgb', 'rgba').replace(')', ', 0.4)')}`;
                            }
                        }
                    });
                } else {
                    // Use default blue for servers without icons
                    currentServerColor = 'rgba(51, 95, 255, 0.6)';
                    if (activeItem) {
                        activeItem.style.borderColor = 'rgba(51, 95, 255, 0.6)';
                        activeItem.style.boxShadow = '0 0 15px rgba(51, 95, 255, 0.4)';
                    }
                }

                // Load channels if not cached
                if (!serverChannels[guildId]) {
                    channelsList.innerHTML = '<div class="loading-container"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spinner"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2 A10 10 0 0 1 22 12" stroke-linecap="round"></path></svg> Loading channels...</div>';

                    try {
                        const response = await fetch(`/api/guild/${guildId}/channels`);

                        // Check if this guild is still selected
                        if (!selectedGuild || selectedGuild.id !== guildId) {
                            return;
                        }

                        const data = await response.json();

                        // Check for token_invalid error - redirect to settings
                        if (data.token_invalid) {
                            window.location.href = '/settings';
                            return;
                        }

                        if (!response.ok) {
                            await handleSessionError(response);
                            return;
                        }

                        if (data.channels) {
                            serverChannels[guildId] = data.channels.filter(ch => ch.type === 0);
                        } else {
                            serverChannels[guildId] = [];
                        }
                    } catch (error) {
                        console.error(`Error fetching channels:`, error);
                        serverChannels[guildId] = [];
                    }
                }

                // Only render if this guild is still selected
                if (selectedGuild && selectedGuild.id === guildId) {
                    renderChannels();
                }

                // Also update channels-only mode if active
                if (viewMode === 'channels') {
                    renderChannelsOnlyMode();
                }
            }

            // Render channels for selected server
            function renderChannels() {
                if (!selectedGuild) {
                    channelsList.innerHTML = '<div class="no-selection">Select a server to view channels</div>';
                    return;
                }

                channelsList.innerHTML = '';
                const channels = serverChannels[selectedGuild.id] || [];

                if (channels.length === 0) {
                    channelsList.innerHTML = '<div class="no-selection">No channels found</div>';
                    return;
                }

                // Filter channels by search tags (OR logic - any tag matches)
                let filteredChannels = channels;
                if (searchTags.length > 0) {
                    filteredChannels = channels.filter(channel =>
                        searchTags.some(tag => channel.name.toLowerCase().includes(tag))
                    );
                }

                if (filteredChannels.length === 0) {
                    channelsList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                filteredChannels.forEach(channel => {
                    const isSelected = selectedChannels.some(ch =>
                        ch.id === channel.id && ch.guildId === selectedGuild.id
                    );

                    const channelItem = document.createElement('div');
                    channelItem.className = `channel-item ${isSelected ? 'selected' : ''}`;
                    channelItem.dataset.channelId = channel.id;

                    // Create tick icon (only visible when selected)
                    const tickIcon = document.createElement('img');
                    tickIcon.className = 'channel-tick';
                    tickIcon.src = '{{ url_for("static", filename="tick.png") }}';
                    tickIcon.alt = '✓';
                    tickIcon.width = 16;
                    tickIcon.height = 16;
                    tickIcon.style.display = isSelected ? 'inline-block' : 'none';

                    const label = document.createElement('label');
                    label.className = 'channel-label';
                    label.innerHTML = `#${channel.name}`;

                    channelItem.appendChild(tickIcon);
                    channelItem.appendChild(label);

                    // Apply server color to selected channel
                    if (isSelected) {
                        channelItem.style.borderColor = currentServerColor;
                        channelItem.style.boxShadow = `0 0 15px ${currentServerColor.replace('rgb', 'rgba').replace(')', ', 0.4)')}`;
                    }

                    // Click anywhere on channel item to toggle selection
                    channelItem.addEventListener('click', () => {
                        // Check current selection state at click time, not render time
                        const currentlySelected = selectedChannels.some(ch =>
                            ch.id === channel.id && ch.guildId === selectedGuild.id
                        );
                        toggleChannel(channel, !currentlySelected);
                    });

                    channelsList.appendChild(channelItem);
                });
            }

            // Toggle channel selection for channels-only mode
            function toggleChannelSelection(channel) {
                const isCurrentlySelected = selectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === channel.guildId
                );

                if (!isCurrentlySelected) {
                    // Check channel limit per server (-1 means unlimited)
                    if (maxChannelsPerServer !== -1) {
                        const currentServerChannelCount = selectedChannels.filter(ch =>
                            ch.guildId === channel.guildId
                        ).length;

                        if (currentServerChannelCount >= maxChannelsPerServer) {
                            showChannelLimitModal(maxChannelsPerServer);
                            return;
                        }
                    }

                    selectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: channel.guildId,
                        guildName: channel.guildName,
                        guildIcon: channel.guildIcon || null
                    });
                    // Clear any failed status when re-selecting
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    failedChannels.delete(channelKey);
                } else {
                    selectedChannels = selectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === channel.guildId)
                    );
                }

                // Save to localStorage
                saveSelectedChannels();

                // Update UI
                updateServerCount(channel.guildId);
                updateSelectedDisplay();
                updateSendButton();
            }

            // Toggle channel selection
            function toggleChannel(channel, isChecked) {
                if (!selectedGuild) return;

                const isCurrentlySelected = selectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === selectedGuild.id
                );

                if (isChecked && !isCurrentlySelected) {
                    // Check channel limit per server (-1 means unlimited)
                    if (maxChannelsPerServer !== -1) {
                        const currentServerChannelCount = selectedChannels.filter(ch =>
                            ch.guildId === selectedGuild.id
                        ).length;

                        if (currentServerChannelCount >= maxChannelsPerServer) {
                            showChannelLimitModal(maxChannelsPerServer);
                            return;
                        }
                    }

                    selectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: selectedGuild.id,
                        guildName: selectedGuild.name,
                        guildIcon: selectedGuild.icon || null
                    });
                    // Clear any failed status when re-selecting
                    const channelKey = `${selectedGuild.id}-${channel.id}`;
                    failedChannels.delete(channelKey);
                } else if (!isChecked && isCurrentlySelected) {
                    selectedChannels = selectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === selectedGuild.id)
                    );
                }

                // Save to localStorage
                saveSelectedChannels();

                // Update UI
                renderChannels();
                updateServerCount(selectedGuild.id);
                updateSelectedDisplay();
                updateSendButton();
            }

            // Update count badge on server
            function updateServerCount(guildId) {
                const count = selectedChannels.filter(ch => ch.guildId === guildId).length;
                const serverItem = document.querySelector(`[data-guild-id="${guildId}"]`);
                if (serverItem) {
                    const countEl = serverItem.querySelector('.server-count');
                    if (countEl) {
                        if (count > 0) {
                            countEl.textContent = `${count} selected`;
                            countEl.style.display = 'block';
                            serverItem.classList.add('has-selection');
                        } else {
                            countEl.style.display = 'none';
                            serverItem.classList.remove('has-selection');
                        }
                    }
                }
            }

            // Update only a specific channel's failed status without rebuilding the list
            function updateFailedChannelStatus(channel) {
                const channelKey = `${channel.guildId}-${channel.id}`;
                const failureInfo = failedChannels.get(channelKey);
                const tagElement = selectedChannelsTags.querySelector(`[data-channel-key="${channelKey}"]`);

                if (!tagElement) return;

                // Remove existing failure classes and labels
                tagElement.classList.remove('failed-channel', 'rate-limited');
                const existingLabel = tagElement.querySelector('.failure-label');
                if (existingLabel) existingLabel.remove();

                // Add new failure status if needed
                if (failureInfo) {
                    if (failureInfo.type === 'ratelimit') {
                        tagElement.classList.add('rate-limited');
                        const label = document.createElement('span');
                        label.className = 'failure-label ratelimit';
                        label.textContent = 'Rate limited';
                        tagElement.insertBefore(label, tagElement.querySelector('.tag-remove'));
                    } else {
                        tagElement.classList.add('failed-channel');
                        const label = document.createElement('span');
                        label.className = 'failure-label permission';
                        label.textContent = 'Missing permission';
                        tagElement.insertBefore(label, tagElement.querySelector('.tag-remove'));
                    }
                }
            }

            // Update selected channels display
            function updateSelectedDisplay() {
                if (selectedChannels.length > 0) {
                    // Filter channels by search text
                    let filteredChannels = selectedChannels;
                    if (selectedSearchText) {
                        filteredChannels = selectedChannels.filter(channel =>
                            channel.name.toLowerCase().includes(selectedSearchText) ||
                            channel.guildName.toLowerCase().includes(selectedSearchText)
                        );
                    }

                    if (filteredChannels.length === 0) {
                        selectedChannelsTags.innerHTML = '<div class="no-selection">No channels match search</div>';
                    } else {
                        let tagsHtml = '';
                        filteredChannels.forEach(channel => {
                            const iconHtml = channel.guildIcon
                                ? `<img src="https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png" alt="${channel.guildName}">`
                                : `<span>${channel.guildName.charAt(0).toUpperCase()}</span>`;

                            const channelKey = `${channel.guildId}-${channel.id}`;
                            const failureInfo = failedChannels.get(channelKey);

                            let failedClass = '';
                            let labelHtml = '';

                            if (failureInfo) {
                                if (failureInfo.type === 'ratelimit') {
                                    failedClass = ' rate-limited';
                                    labelHtml = '<span class="failure-label ratelimit">Rate limited</span>';
                                } else {
                                    failedClass = ' failed-channel';
                                    labelHtml = '<span class="failure-label permission">Missing permission</span>';
                                }
                            }

                            tagsHtml += `
                                <div class="selected-tag${failedClass}" data-channel-key="${channelKey}">
                                    <div class="tag-icon">${iconHtml}</div>
                                    <div class="tag-text">#${channel.name}</div>
                                    ${labelHtml}
                                    <button class="tag-remove" data-channel-id="${channel.id}" data-guild-id="${channel.guildId}">✕</button>
                                </div>
                            `;
                        });
                        selectedChannelsTags.innerHTML = tagsHtml;

                        // Add event listeners for remove buttons
                        selectedChannelsTags.querySelectorAll('.tag-remove').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const channelId = btn.dataset.channelId;
                                const guildId = btn.dataset.guildId;
                                selectedChannels = selectedChannels.filter(ch =>
                                    !(ch.id === channelId && ch.guildId === guildId)
                                );
                                saveSelectedChannels();
                                updateSelectedDisplay();
                                if (selectedGuild && selectedGuild.id === guildId) {
                                    renderChannels();
                                }
                                updateServerCount(guildId);
                                updateSendButton();
                            });
                        });
                    }

                    // Show external clear all button
                    const clearAllBtn = document.getElementById('clear-all-btn');
                    clearAllBtn.style.display = 'block';
                    clearAllBtn.onclick = () => {
                        selectedChannels = [];
                        saveSelectedChannels();
                        updateSelectedDisplay();
                        if (selectedGuild) {
                            renderChannels();
                        }
                        guilds.forEach(g => updateServerCount(g.id));
                        updateSendButton();
                    };
                } else {
                    selectedChannelsTags.innerHTML = '<div class="no-selection">No channels selected</div>';
                    const clearAllBtn = document.getElementById('clear-all-btn');
                    clearAllBtn.style.display = 'none';
                }
            }

            // Update send button state
            function updateSendButton() {
                if (sendBtn && messageInput) {
                    sendBtn.disabled = selectedChannels.length === 0 || !TEAM_MESSAGE.trim();
                }
            }

            // Show collapsible send results
            async function showSendResults(succeeded, rateLimited, failed) {
                const totalAttempted = succeeded.length + rateLimited.length + failed.length;

                // Determine title and icon
                let title, icon;
                if (succeeded.length === 0 && (rateLimited.length > 0 || failed.length > 0)) {
                    title = 'Failed to send';
                    icon = 'error';
                } else {
                    title = 'Send succeeded';
                    icon = 'success';
                }

                // Build collapsible sections HTML
                let sectionsHTML = '';

                // Success section
                if (succeeded.length > 0) {
                    sectionsHTML += `
                        <div class="result-section collapsed">
                            <div class="result-header" onclick="this.parentElement.classList.toggle('collapsed')">
                                <span>Send succeeded (${succeeded.length} Channel${succeeded.length !== 1 ? 's' : ''})</span>
                                <img src="/static/openorclose.png" class="collapse-icon" style="width: 16px; height: 16px; transition: transform 0.2s;">
                            </div>
                            <div class="result-content">
                                ${succeeded.map(ch => `<div class="channel-item"># ${ch}</div>`).join('')}
                            </div>
                        </div>
                    `;
                }

                // Rate limited section
                if (rateLimited.length > 0) {
                    sectionsHTML += `
                        <div class="result-section collapsed">
                            <div class="result-header" onclick="this.parentElement.classList.toggle('collapsed')">
                                <span>Send rate limited (${rateLimited.length} Channel${rateLimited.length !== 1 ? 's' : ''})</span>
                                <img src="/static/openorclose.png" class="collapse-icon" style="width: 16px; height: 16px; transition: transform 0.2s;">
                            </div>
                            <div class="result-content">
                                ${rateLimited.map(ch => `<div class="channel-item"># ${ch}</div>`).join('')}
                            </div>
                        </div>
                    `;
                }

                // Failed section
                if (failed.length > 0) {
                    sectionsHTML += `
                        <div class="result-section collapsed">
                            <div class="result-header" onclick="this.parentElement.classList.toggle('collapsed')">
                                <span>Send failed (${failed.length} Channel${failed.length !== 1 ? 's' : ''})</span>
                                <img src="/static/openorclose.png" class="collapse-icon" style="width: 16px; height: 16px; transition: transform 0.2s;">
                            </div>
                            <div class="result-content">
                                ${failed.map(ch => `<div class="channel-item"># ${ch}</div>`).join('')}
                            </div>
                        </div>
                    `;
                }

                // Create custom modal
                const modalHTML = `
                    <style>
                        .result-section {
                            margin: 0 !important;
                            padding: 0 !important;
                            display: block !important;
                        }
                        .result-section.collapsed .result-content {
                            display: none;
                        }
                        .result-section.collapsed .collapse-icon {
                            transform: rotate(180deg);
                        }
                        .result-header {
                            padding: 0 !important;
                            margin: 0 !important;
                            cursor: pointer;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            font-weight: 500;
                            color: #dcddde;
                            user-select: none;
                            font-size: 0.85rem;
                            line-height: 1;
                        }
                        .result-header:hover {
                            opacity: 0.8;
                        }
                        .result-header span {
                            margin: 0 !important;
                            padding: 0 !important;
                            line-height: 1;
                        }
                        .result-content {
                            max-height: 150px;
                            overflow-y: auto;
                            overflow-x: hidden;
                            padding: 0 !important;
                            margin: 0 !important;
                            scroll-behavior: auto;
                        }
                        .result-content::-webkit-scrollbar {
                            width: 5px;
                        }
                        .result-content::-webkit-scrollbar-track {
                            background: transparent;
                        }
                        .result-content::-webkit-scrollbar-thumb {
                            background: rgba(255, 255, 255, 0.2);
                            border-radius: 3px;
                        }
                        .channel-item {
                            padding: 0 !important;
                            margin: 0 !important;
                            color: #81828A;
                            font-size: 0.75rem;
                            background: transparent;
                            line-height: 1;
                            display: block !important;
                        }
                    </style>
                    <div style="max-height: 300px; overflow-y: auto; overflow-x: hidden; scroll-behavior: auto; padding: 0 !important; margin: 0 !important; display: flex; flex-direction: column; gap: 0;">
                        ${sectionsHTML}
                    </div>
                `;

                await showAlert(modalHTML, title, { icon: icon, allowHtml: true });
            }

            // Send button handler
            if (sendBtn) {
                sendBtn.addEventListener('click', async function() {
                    if (selectedChannels.length > 0 && TEAM_MESSAGE.trim()) {
                        // Check for filtered content before proceeding
                        const message = TEAM_MESSAGE.trim();
                        const filteredWords = {{ BLACKLISTED_WORDS|tojson }};

                        // Check message against blacklist (case-insensitive) - find ALL matches
                        const messageLower = message.toLowerCase();
                        let foundWords = [];

                        for (const word of filteredWords) {
                            if (messageLower.includes(word.toLowerCase())) {
                                foundWords.push(word);
                            }
                        }

                        if (foundWords.length > 0) {
                            // Flag the user for using banned words
                            try {
                                await fetch('/api/flag-self', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({ words: foundWords })
                                });
                            } catch (e) {
                                console.error('Failed to report flagged content:', e);
                            }

                            await showAlert(`Banned words used\n\nTeam message contains prohibited content:\n• ${foundWords.join('\n• ')}\n\nPlease update the team message in Team management to remove this content.`, 'Warning');
                            return; // Stop execution
                        }

                        // Show confirmation popup
                        const channelCount = selectedChannels.length;
                        const confirmed = await showConfirm(`Send message to ${channelCount} channel${channelCount !== 1 ? 's' : ''}?`, 'Send Message', { confirmText: 'Send' });
                        if (!confirmed) return;

                        // Clear previous failed channels
                        failedChannels.clear();

                        isSending = true;
                        sendBtn.disabled = true;
                        sendBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spinner"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2 A10 10 0 0 1 22 12" stroke-linecap="round"></path></svg> Sending...';

                        // Send messages one by one for real-time usage tracking
                        let succeededChannels = [];
                        let rateLimitedChannels = [];
                        let failedChannelsList = [];

                        // Helper function to wait/delay
                        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

                        // Get custom delay setting from database (default to 1000ms)
                        const customDelay = parseInt('{{ user_data.message_delay }}') || 1000;

                        try {
                            for (let i = 0; i < selectedChannels.length; i++) {
                                const channel = selectedChannels[i];

                                // Update progress in button
                                sendBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spinner"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2 A10 10 0 0 1 22 12" stroke-linecap="round"></path></svg> Sending ${i + 1}/${selectedChannels.length}...`;

                                // Send message using team message (no retry for rate limits)
                                const response = await fetch('/api/send-message-single', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({
                                        channel: channel,
                                        message: TEAM_MESSAGE,
                                        is_business: true
                                    })
                                });

                                const result = await response.json();

                                // Check if send was successful (200/201 response)
                                if (response.ok && result.success) {
                                    succeededChannels.push(channel.name);
                                    // Clear any previous failure status for this channel
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.delete(channelKey);
                                    updateFailedChannelStatus(channel);
                                } else if (result.token_invalid) {
                                    // Token is invalid - redirect to settings
                                    window.location.href = '/settings';
                                    return; // Stop execution
                                } else if (response.status === 429) {
                                    // Rate limited by Discord - mark and skip (don't retry)
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.set(channelKey, { type: 'ratelimit' });
                                    rateLimitedChannels.push(channel.name);
                                    updateFailedChannelStatus(channel);
                                } else {
                                    // Other error (permissions, etc.)
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.set(channelKey, { type: 'permission' });
                                    failedChannelsList.push(channel.name);
                                    updateFailedChannelStatus(channel);
                                }

                                // Add delay between messages based on user setting
                                // Only delay if there are more messages to send
                                if (i < selectedChannels.length - 1 && customDelay > 0) {
                                    await delay(customDelay);
                                }
                            }

                            // Show collapsible results
                            await showSendResults(succeededChannels, rateLimitedChannels, failedChannelsList);
                        } catch (error) {
                            console.error('Send error:', error);
                            await showAlert(`Error sending message: ${error.message}`, 'Error');
                        } finally {
                            isSending = false;
                            sendBtn.disabled = selectedChannels.length === 0 || !TEAM_MESSAGE.trim();
                            sendBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"></path></svg> Send';
                        }
                    }
                });
            }

            // Initialize on load
            initializeUI();
        });
    </script>

    {% include 'partials/settings_popup.html' %}
</body>
</html>
