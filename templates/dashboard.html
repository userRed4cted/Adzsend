<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Ad Z send</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='responsive.css') }}">
    {% include 'partials/config_styles.html' %}
    <script src="{{ url_for('static', filename='tab_enforcement.js') }}"></script>
    <script src="{{ url_for('static', filename='status_polling.js') }}"></script>
    <script>
        window.DB_VERSION = {{ db_version }};
        window.DB_WIPE_MESSAGE = "{{ db_wipe_message }}";
    </script>
    <script src="{{ url_for('static', filename='db_wipe_notice.js') }}"></script>
    <script src="{{ url_for('static', filename='custom_popup.js') }}"></script>
    {% include 'partials/base_scripts.html' %}
    <style>
        /* Prevent page scrolling */
        body {
            overflow: hidden;
            height: 100vh;
        }

        .panel {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* New panel design - wrapper for side menu + content */
        .dashboard-panel-container {
            padding: 1rem;
            flex: 1;
            overflow: hidden;
        }

        .dashboard-main-frame {
            background: transparent;
            border: 1px solid #222225;
            border-radius: 12px;
            display: flex;
            height: 100%;
            overflow: hidden;
        }

        /* Side menu */
        .side-menu {
            width: 240px;
            background: #1A1A1E;
            border-right: 1px solid #222225;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            gap: 1rem;
            flex-shrink: 0;
        }

        /* Discord profile section */
        .profile-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .profile-card {
            background: transparent;
            border-radius: 8px;
            padding: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
        }

        .profile-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: visible;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2a2a30;
            position: relative;
        }

        .profile-avatar img.avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }

        .profile-avatar .avatar-decoration {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120%;
            height: 120%;
            pointer-events: none;
            z-index: 1;
        }

        .profile-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .profile-name {
            color: #dcddde;
            font-weight: 500;
            font-size: 0.9rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            line-height: 1.2;
            margin: 0;
        }

        .change-account-text {
            color: #81828A;
            font-size: 0.75rem;
            line-height: 1.2;
            margin: 0;
        }

        /* Menu sections */
        .menu-section {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .menu-category {
            color: #81828A;
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            padding: 0.25rem 0.75rem;
            margin-top: 0.25rem;
        }

        .menu-category:first-child {
            margin-top: 0;
        }

        .menu-item {
            display: flex;
            align-items: center;
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            color: #dcddde;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            background: transparent;
            border: none;
            width: 100%;
            text-align: left;
        }

        .menu-item.active {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
            color: #121215;
        }

        .menu-divider {
            height: 1px;
            background: rgba(255,255,255,0.05);
            margin: 0.25rem 0;
        }

        /* Main content wrapper - takes up remaining space */
        .main-content-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: visible;
            min-width: 0;
        }

        /* Custom radio button styling matching settings.html */
        input[type="radio"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid #15d8bc;
            border-radius: 50%;
            background: transparent;
            cursor: pointer;
            position: relative;
        }
        input[type="radio"]:checked {
            background: #15d8bc;
            border-color: #15d8bc;
        }
        input[type="radio"]:checked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: #fff;
            border-radius: 50%;
        }
        input[type="radio"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Override main-layout for test panel - add divider */
        .main-content-wrapper .main-layout {
            display: flex;
            gap: 0;
            height: 100%;
        }

        .main-content-wrapper .main-layout .selection-panel {
            flex: 1;
            margin: 0;
            padding: 0;
            background: transparent;
            border-radius: 0;
        }

        .main-content-wrapper .main-layout .action-panel {
            flex: 1;
            margin: 0.75rem;
        }

        /* Vertical divider between panels */
        .panel-divider {
            width: 1px;
            background: #222225;
            margin: 0;
            flex-shrink: 0;
        }

        /* View mode toggle - centered */
        .view-mode-toggle {
            display: flex;
            gap: 1.5rem;
            padding: 0.5rem 0.5rem;
            justify-content: center;
            margin-top: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .view-mode-toggle label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .view-mode-toggle span {
            color: #dcddde;
            font-weight: 500;
            font-size: 0.85rem;
        }

        /* Selected channels mode - channels list with x.png for remove */
        .selected-channels-mode .channels-list .channel-item .channel-tick {
            content: url("{{ url_for('static', filename='x.png') }}");
        }

        /* Reduced height searchbar for selection panel */
        .selection-panel .search-input {
            padding: 0.35rem 0.75rem;
            padding-left: 2.5rem;
            font-size: 0.85rem;
            width: 100%;
            box-sizing: border-box;
            color: #81828A;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            background-color: #1A1A1E;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%2381828A' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: 0.75rem center;
            background-size: 16px 16px;
            border: 1px solid #222225;
            border-radius: 8px;
        }

        /* Full-width channels list with horizontal padding to match searchbar */
        .selection-panel .channels-list {
            padding: 0 0.5rem;
            margin: 0;
            border-radius: 0;
        }

        .selection-panel .channels-list .channel-item {
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            border-radius: 4px;
        }

        .selection-panel .channels-section,
        .selection-panel .channels-only-section {
            padding: 0;
            margin: 0;
            border-radius: 0;
        }

        .selection-panel .unified-header {
            padding: 0 0.5rem;
            margin-bottom: 0.25rem;
        }

        /* Fixed height for both headers to prevent rescaling */
        .selection-panel .servers-mode-header,
        .selection-panel .channels-only-header {
            min-height: 2.5rem;
        }

        .selection-panel .servers-mode-header .header-section,
        .selection-panel .channels-only-header .header-section {
            width: 100%;
        }

        .selection-panel .channels-search {
            width: 100%;
        }

        /* Discord-style server sidebar on far left */
        .server-sidebar {
            width: 76px;
            background: transparent;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 0.5rem 0;
            gap: 0.5rem;
            overflow-y: auto;
            flex-shrink: 0;
            position: relative;
            box-sizing: border-box;
        }

        .server-icon-wrapper {
            position: relative;
            width: 48px;
            height: 48px;
            margin-left: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .server-icon-pill {
            position: absolute;
            left: -14px;
            width: 4px;
            background: #FFFFFF;
            border-radius: 0 4px 4px 0;
            transition: height 0.15s ease-out, opacity 0.15s ease-out;
            height: 0;
            opacity: 0;
        }

        .server-icon-wrapper:hover .server-icon-pill {
            height: 20px;
            opacity: 1;
        }

        .server-icon-wrapper.active .server-icon-pill {
            height: 40px;
            opacity: 1;
        }

        .server-icon-holder {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #1A1A1E;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: border-radius 0.15s ease-out;
        }

        .server-icon-wrapper:hover .server-icon-holder {
            border-radius: 16px;
        }

        .server-icon-wrapper.active .server-icon-holder {
            border-radius: 16px;
        }

        .server-icon-holder img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .server-icon-placeholder {
            color: #dcddde;
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* Loading placeholder for server sidebar */
        .server-loading-placeholder {
            display: flex;
            justify-content: center;
            padding-top: 8px;
            margin-left: 14px;
            width: 48px;
        }

        .server-loading-placeholder .server-icon-holder.placeholder {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #1A1A1E;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .server-loading-placeholder .loading-dots {
            gap: 3px;
        }

        .server-loading-placeholder .loading-dots .dot {
            width: 6px;
            height: 6px;
        }

        /* Divider between content and server sidebar */
        .server-sidebar-divider {
            width: 1px;
            background: #222225;
            margin: 0;
            flex-shrink: 0;
        }

        /* Discord-style channel list overrides */
        .channels-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 0 0.5rem;
            overflow-x: hidden;
        }

        /* Selection panel needs position relative for absolute centering of messages */
        .selection-panel {
            position: relative;
        }

        /* Center no-selection and loading messages exactly in the middle of the selection-panel */
        .selection-panel .no-selection,
        .selection-panel .loading-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #81828A;
            font-size: 0.95rem;
            padding: 0;
            margin: 0;
            width: max-content;
            z-index: 1;
        }

        .channels-list .channel-item {
            display: flex !important;
            flex-direction: row !important;
            align-items: center !important;
            flex-wrap: nowrap !important;
            gap: 0.5rem;
            padding: 0.4rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            border: none;
            transition: none;
            width: 100%;
            box-sizing: border-box;
        }

        .channels-list .channel-item:hover {
            transform: none;
            background: #1A1A1E;
        }

        .channels-list .channel-item:hover .channel-hash,
        .channels-list .channel-item:hover .channel-name {
            color: #fff;
        }

        .channels-list .channel-item.selected {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
            border: none;
            box-shadow: none;
        }

        .channels-list .channel-item.selected:hover {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
        }

        .channels-list .channel-item .channel-hash {
            color: #81828A;
            font-size: 1rem;
            font-weight: 500;
            flex-shrink: 0;
        }

        .channels-list .channel-item.selected .channel-hash {
            color: #121215;
        }

        .channels-list .channel-item .channel-name {
            color: #81828A;
            font-size: 0.9rem;
            font-weight: 500;
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .channels-list .channel-item.selected .channel-name {
            color: #121215;
        }

        /* Right side container for status tag and tick icon */
        .channels-list .channel-item .channel-right {
            display: none !important;
            flex-direction: row !important;
            align-items: center !important;
            flex-wrap: nowrap !important;
            gap: 0.5rem;
            margin-left: auto;
            flex-shrink: 0;
            position: absolute;
            right: 0.5rem;
        }

        .channels-list .channel-item.selected .channel-right {
            display: flex !important;
        }

        /* Make channel-item position relative for absolute positioning of channel-right */
        .channels-list .channel-item {
            position: relative;
        }

        .channels-list .channel-item .channel-tick {
            width: 22px;
            height: 22px;
            flex-shrink: 0;
            filter: brightness(0) saturate(100%);
        }

        /* X icon same size as tick */
        .channels-list .channel-item .channel-tick[alt="x"] {
            width: 22px;
            height: 22px;
        }

        /* Failed channel status tag */
        .channels-list .channel-item .channel-status-tag {
            display: none;
            background: #121215;
            color: #81828A;
            font-size: 0.6rem;
            font-weight: 500;
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
            white-space: nowrap;
            width: 85px;
            text-align: center;
            flex-shrink: 0;
            line-height: 1;
            box-sizing: border-box;
        }

        .channels-list .channel-item.failed .channel-status-tag {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Team Management member items - always show right side */
        .channels-list .channel-item.mgmt-member-item .channel-right,
        .channels-list .channel-item.analytics-member-item .channel-right {
            display: flex !important;
        }

        .channels-list .channel-item.mgmt-member-item .channel-status-tag,
        .channels-list .channel-item.analytics-member-item .channel-status-tag {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Analytics View button hover */
        .analytics-view-btn:hover {
            opacity: 0.8;
        }

        /* Failed channel styling - red gradient background */
        .channels-list .channel-item.failed {
            background: linear-gradient(to bottom, #991a35, #6b1226);
        }

        .channels-list .channel-item.failed:hover {
            background: linear-gradient(to bottom, #991a35, #6b1226);
        }

        .channels-list .channel-item.failed .channel-hash,
        .channels-list .channel-item.failed .channel-name {
            color: #121215;
        }

        /* Server icon for channels-only mode */
        .channels-list .channel-item .server-icon-small {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            flex-shrink: 0;
            object-fit: cover;
        }

        .channels-list .channel-item .server-icon-placeholder-small {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #5865f2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            font-weight: 600;
            flex-shrink: 0;
        }

        /* Keep server icon unchanged when selected */
        .channels-list .channel-item.selected .server-icon-small,
        .channels-list .channel-item.selected .server-icon-placeholder-small {
            /* No changes - keep original appearance */
        }

        /* Mobile page header - hidden on desktop */
        .dashboard-mobile-page-header {
            display: none;
        }

        /* ==================== DASHBOARD MOBILE RESPONSIVE ==================== */
        @media (max-width: 900px) {
            /* Remove container padding on mobile */
            .dashboard-panel-container {
                padding: 0;
            }

            /* Full screen frame, no border/radius */
            .dashboard-main-frame {
                border: none;
                border-radius: 0;
                flex-direction: column;
            }

            /* Side menu takes full screen */
            .side-menu {
                width: 100%;
                height: 100%;
                border-right: none;
                padding: 1rem 1.25rem;
            }

            /* Hide main content wrapper by default - slides from right, covers entire screen */
            .main-content-wrapper {
                display: flex;
                flex-direction: column;
                position: fixed;
                top: 0;
                right: -100%;
                width: 100%;
                height: 100%;
                background: #121215;
                z-index: 100;
                transition: right 0.3s ease;
            }

            /* Show content when page is active */
            .main-content-wrapper.mobile-page-active {
                right: 0;
            }

            /* Mobile page header - shown on mobile */
            .dashboard-mobile-page-header {
                display: flex;
                align-items: center;
                height: 56px;
                min-height: 56px;
                padding: 0 1.25rem;
                border-bottom: 0.5px solid #222225;
                position: relative;
                background: #121215;
            }

            /* Mobile back button */
            .dashboard-mobile-back-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                background: #121215;
                border: 1px solid #222225;
                border-radius: 4px;
                cursor: pointer;
                padding: 0.25rem;
                width: 32px;
                height: 32px;
            }

            .dashboard-mobile-back-btn > img {
                width: 20px;
                height: 20px;
                transform: rotate(90deg);
                filter: brightness(0) saturate(100%) invert(100%);
            }

            /* Mobile page title - left aligned next to back button */
            .dashboard-mobile-page-title {
                flex: 1;
                text-align: left;
                margin-left: 12px;
                color: #dcddde;
                font-family: 'gg sans Semibold', sans-serif;
                font-size: 1rem;
            }

            /* Remove active state background on mobile menu items */
            .menu-item.active {
                background: transparent;
                color: #dcddde;
            }

            /* Page content needs to account for header */
            .page-content {
                height: calc(100% - 56px) !important;
                overflow-y: auto !important;
                overflow-x: hidden !important;
            }

            /* Make dashboard-main-frame position relative for absolute children */
            .dashboard-main-frame {
                position: relative;
            }

            /* ===== PAGE LAYOUTS - Stack vertically on mobile ===== */

            /* Personal Panel & Team Panel - column layout to stack server row + action panel */
            .main-layout {
                flex-direction: column !important;
                height: auto !important;
                min-height: 100% !important;
            }

            /* Hide vertical dividers, show horizontal ones for non-panel sections */
            .panel-divider {
                width: 100% !important;
                height: 1px !important;
                margin: 0 !important;
            }

            /* Server sidebar divider stays vertical within the row */
            .server-sidebar-divider {
                width: 1px !important;
                height: auto !important;
                margin: 0 !important;
                flex-shrink: 0 !important;
            }

            /* Server sidebar - vertical on mobile, scaled down */
            .server-sidebar {
                width: 56px !important;
                min-width: 56px !important;
                height: 100% !important;
                min-height: 150px !important;
                flex-direction: column !important;
                padding: 0.4rem 0 !important;
                overflow-x: hidden !important;
                overflow-y: auto !important;
                flex-shrink: 0 !important;
                align-items: flex-start !important;
                gap: 0.4rem !important;
            }

            .server-icon-wrapper {
                width: 36px !important;
                height: 36px !important;
                margin-left: 10px !important;
                margin-top: 0 !important;
                padding-top: 0 !important;
                position: relative !important;
                flex-shrink: 0 !important;
            }

            .server-icon-holder {
                width: 36px !important;
                height: 36px !important;
                border-radius: 50% !important;
                transition: border-radius 0.15s ease-out !important;
            }

            .server-icon-wrapper:hover .server-icon-holder {
                border-radius: 12px !important;
            }

            .server-icon-wrapper.active .server-icon-holder {
                border-radius: 12px !important;
            }

            /* Pill on left for vertical layout */
            .server-icon-pill {
                display: block !important;
                left: -10px !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
                width: 3px !important;
                height: 0 !important;
                border-radius: 0 3px 3px 0 !important;
            }

            .server-icon-wrapper:hover .server-icon-pill {
                width: 3px !important;
                height: 16px !important;
            }

            .server-icon-wrapper.active .server-icon-pill {
                width: 3px !important;
                height: 30px !important;
            }

            .server-icon-placeholder {
                font-size: 0.85rem !important;
            }

            .server-loading-placeholder {
                margin-left: 10px !important;
                width: 36px !important;
                padding-top: 4px !important;
            }

            .server-loading-placeholder .server-icon-holder.placeholder {
                width: 36px !important;
                height: 36px !important;
            }

            /* Create a grid container for server sidebar + divider + selection panel + action panel */
            #page-personal-panel > .main-layout,
            #page-team-panel > .main-layout {
                display: grid !important;
                grid-template-columns: 56px 1px 1fr !important;
                grid-template-rows: minmax(150px, 1fr) auto !important;
                gap: 0 !important;
            }

            #page-personal-panel > .main-layout > .server-sidebar,
            #page-team-panel > .main-layout > .server-sidebar {
                grid-column: 1 !important;
                grid-row: 1 !important;
            }

            #page-personal-panel > .main-layout > .server-sidebar-divider,
            #page-team-panel > .main-layout > .server-sidebar-divider {
                grid-column: 2 !important;
                grid-row: 1 !important;
            }

            #page-personal-panel > .main-layout > .selection-panel,
            #page-team-panel > .main-layout > .selection-panel {
                grid-column: 3 !important;
                grid-row: 1 !important;
                min-height: 0 !important;
                overflow: hidden !important;
            }

            /* Horizontal divider between selection area and action panel */
            #page-personal-panel > .main-layout > .panel-divider:not(.server-sidebar-divider),
            #page-team-panel > .main-layout > .panel-divider:not(.server-sidebar-divider) {
                display: none !important;
            }

            /* Action panel spans full width below with top border as divider */
            #page-personal-panel > .main-layout > .action-panel,
            #page-team-panel > .main-layout > .action-panel,
            #page-personal-panel > .main-layout > div:last-child,
            #page-team-panel > .main-layout > div:last-child {
                grid-column: 1 / -1 !important;
                grid-row: 2 !important;
                min-height: 200px !important;
                padding: 0 0.75rem 0.75rem 0.75rem !important;
                border-top: 1px solid #222225 !important;
            }

            /* Selection panel styling */
            .selection-panel {
                flex: 1 !important;
                min-height: 0 !important;
                min-width: 0 !important;
                display: flex !important;
                flex-direction: column !important;
                overflow: hidden !important;
            }

            /* Team Management - stack vertically */
            #page-team-management {
                flex-direction: column !important;
            }

            #page-team-management > div:first-child {
                flex: 1 !important;
                min-height: 200px;
            }

            #page-team-management > div:last-child {
                flex: 1 !important;
                min-height: 250px;
                padding: 0 1rem 1rem 1rem !important;
            }

            /* Analytics - stack vertically, personal on top, team on bottom */
            #page-analytics {
                flex-direction: column !important;
                height: auto !important;
                overflow-y: auto !important;
            }

            #page-analytics > div:first-child {
                flex: none !important;
                height: auto !important;
                min-height: 350px;
            }

            #page-analytics > .panel-divider {
                width: 100% !important;
                height: 1px !important;
                flex-shrink: 0 !important;
            }

            #page-analytics > div:last-child {
                flex: none !important;
                height: auto !important;
            }

            /* Team analytics inner sections - fixed heights matching desktop proportions */
            #page-analytics > div:last-child > div:first-child {
                flex: none !important;
                height: 350px !important;
                min-height: 350px !important;
                max-height: 350px !important;
            }

            #page-analytics > div:last-child > div:nth-child(3) {
                flex: none !important;
                height: 350px !important;
                min-height: 350px !important;
                max-height: 350px !important;
            }

            /* View mode toggle - wrap on smaller screens */
            .view-mode-toggle {
                flex-wrap: wrap;
                gap: 0.75rem !important;
                padding: 0.5rem 1rem !important;
            }

            .view-mode-toggle label {
                font-size: 0.8rem;
            }

            .view-mode-toggle span {
                font-size: 0.8rem !important;
            }
        }
    </style>
</head>
<body>
    <div class="panel">
        {% include 'navbar.html' %}

        <div class="dashboard-panel-container">
            <div class="dashboard-main-frame">
                <!-- Side Menu -->
                <div class="side-menu">
                    <!-- Discord Profile -->
                    <div class="profile-section">
                        {% if discord_linked and discord_info %}
                        <div class="profile-card">
                            <div class="profile-avatar" style="background: #121215;">
                                {% if discord_info.avatar %}
                                <img class="avatar-img" src="https://cdn.discordapp.com/avatars/{{ discord_info.id }}/{{ discord_info.avatar }}.png?size=128" alt="Avatar">
                                {% else %}
                                <img class="avatar-img" src="https://cdn.discordapp.com/embed/avatars/{{ discord_info.discriminator|int % 5 }}.png" alt="Default Avatar">
                                {% endif %}
                                {% if discord_info.avatar_decoration_data and discord_info.avatar_decoration_data.asset %}
                                <img class="avatar-decoration" src="https://cdn.discordapp.com/avatar-decoration-presets/{{ discord_info.avatar_decoration_data.asset }}.png?size=160&passthrough=true" alt="">
                                {% endif %}
                            </div>
                            <div class="profile-info">
                                <div class="profile-name">{{ discord_info.username }}</div>
                                <div class="change-account-text">Change account</div>
                            </div>
                        </div>
                        {% else %}
                        <div class="profile-card">
                            <div class="profile-avatar" style="background: #121215; display: flex; align-items: center; justify-content: center;">
                                <img src="{{ url_for('static', filename='DiscordLogo.png') }}" alt="Discord Logo" style="width: 24px !important; height: 24px !important; object-fit: contain !important; border-radius: 0 !important;">
                            </div>
                            <div class="profile-info">
                                <div class="profile-name">No Discord Account</div>
                                <div class="change-account-text">Change account</div>
                            </div>
                        </div>
                        {% endif %}
                    </div>

                    <!-- Menu Items -->
                    <div class="menu-section">
                        <div class="menu-category">Main</div>

                        <button class="menu-item{% if not discord_linked or is_team_owner %} disabled{% endif %}" data-page="personal-panel" id="personal-panel-btn" data-discord-linked="{{ discord_linked|tojson }}"{% if not discord_linked or is_team_owner %} disabled style="opacity: 0.5; cursor: not-allowed; color: #81828A;"{% endif %}>
                            Personal panel
                        </button>

                        <button class="menu-item{% if not discord_linked or not has_team %} disabled{% endif %}" data-page="team-panel" id="team-panel-btn" data-discord-linked="{{ discord_linked|tojson }}"{% if not discord_linked or not has_team %} disabled style="opacity: 0.5; cursor: not-allowed; color: #81828A;"{% endif %}>
                            Team panel
                        </button>

                        <div class="menu-divider"></div>

                        <div class="menu-category">Management</div>

                        <button class="menu-item{% if not is_team_owner %} disabled{% endif %}" data-page="team-management"{% if not is_team_owner %} disabled style="opacity: 0.5; cursor: not-allowed; color: #81828A;"{% endif %}>
                            Team management
                        </button>

                        <button class="menu-item active" data-page="analytics">
                            Analytics
                        </button>

                    </div>
                </div>

                <!-- Main Content Area (uses styles.css classes) -->
                <div class="main-content-wrapper">
                    <!-- Mobile Page Header -->
                    <div class="dashboard-mobile-page-header">
                        <button class="dashboard-mobile-back-btn" onclick="dashboardMobileBack()">
                            <img src="{{ url_for('static', filename='openorclose.png') }}" alt="Back">
                        </button>
                        <span class="dashboard-mobile-page-title" id="dashboard-mobile-page-title">Analytics</span>
                    </div>
                    <!-- Page: Personal Panel -->
                    <div id="page-personal-panel" class="page-content" style="height: 100%; display: none; flex-direction: column;">
                    {% if discord_linked %}
                    <div class="main-layout" style="height: 100%;">
                        <!-- Left: Discord-style Server Sidebar -->
                        <div class="server-sidebar" id="server-sidebar">
                            <!-- Loading placeholder shown until guilds load -->
                            <div class="server-loading-placeholder">
                                <div class="server-icon-holder placeholder">
                                    <div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>
                                </div>
                            </div>
                        </div>

                        <!-- Divider after server sidebar -->
                        <div class="server-sidebar-divider"></div>

                        <!-- Channel Selection -->
                        <div class="selection-panel">
                            <!-- View Mode Toggle with Radio Buttons - Centered -->
                            <div class="view-mode-toggle">
                                <label>
                                    <input type="radio" name="view-mode" value="servers" checked>
                                    <span>Selected server</span>
                                </label>
                                <label>
                                    <input type="radio" name="view-mode" value="channels">
                                    <span>All channels</span>
                                </label>
                                <label>
                                    <input type="radio" name="view-mode" value="selected">
                                    <span>Selected channels</span>
                                </label>
                            </div>

                            <!-- Channels Header (Servers Mode) -->
                            <div class="unified-header servers-mode-header">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="channel-search" class="search-input" placeholder="Search (press enter to add tag)">
                                        <div class="search-tags" id="search-tags"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Channels Only Mode Header -->
                            <div class="unified-header channels-only-header" style="display: none;">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="channels-only-search" class="search-input" placeholder="Search (press enter to add tag)">
                                        <div class="search-tags" id="channels-only-search-tags"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Channels List (Servers Mode) -->
                            <div class="channels-section servers-mode-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                                <div id="channels-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="no-selection">Select a server to view channels</div>
                                </div>
                            </div>

                            <!-- Channels Only List (Channels Only Mode) -->
                            <div class="channels-only-section" style="display: none; flex: 1; flex-direction: column; min-height: 0;">
                                <div id="channels-only-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>
                                </div>
                            </div>

                            <!-- Selected Channels Mode Header -->
                            <div class="unified-header selected-channels-mode-header" style="display: none;">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="selected-channels-mode-search" class="search-input" placeholder="Search">
                                    </div>
                                </div>
                            </div>

                            <!-- Selected Channels Mode List -->
                            <div class="selected-channels-mode-section" style="display: none; flex: 1; flex-direction: column; min-height: 0; overflow: hidden;">
                                <div id="selected-channels-mode-list" class="channels-list selected-channels-mode" style="flex: 1; overflow-y: auto; overflow-x: hidden; min-height: 0;">
                                    <div class="no-selection">No channels selected</div>
                                </div>
                            </div>
                        </div>

                        <!-- Vertical Divider -->
                        <div class="panel-divider"></div>

                        <!-- Middle: Message Composer Only -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; background: transparent; padding: 0 0.75rem; border: none; box-sizing: border-box; position: relative;">
                            <!-- Loading overlay -->
                            <div id="personal-message-loading" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 10;">
                                <div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>
                            </div>

                            <!-- Content - hidden until loaded -->
                            <div id="personal-message-content" style="opacity: 0; pointer-events: none; flex: 1; display: flex; flex-direction: column; height: 100%;">
                                <!-- Personal panel label - matching view-mode-toggle position -->
                                <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                    <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Personal panel</span>
                                </div>
                                <!-- Message Composer -->
                                <div class="message-section" style="display: flex; flex-direction: column; width: 100%; flex: 1; min-height: 0;">
                                    <div class="message-input-container" style="flex: 1; display: flex; flex-direction: column; background: #1A1A1E; border: 1px solid #222225; border-radius: 8px; position: relative; min-height: 0;">
                                    <!-- Emoji button - top right corner (disabled) -->
                                    <button id="emoji-btn" type="button" disabled style="position: absolute; top: 8px; right: 8px; background: transparent; border: none; cursor: not-allowed; padding: 0; z-index: 2; opacity: 0.5;">
                                        <img src="{{ url_for('static', filename='emojimain.png') }}" alt="Emoji" style="width: 20px; height: 20px; opacity: 0.7;">
                                    </button>
                                    <!-- Character count - bottom right corner -->
                                    <span id="char-count" style="position: absolute; bottom: 8px; right: 8px; color: #81828A; font-size: 0.85rem; font-weight: 500; z-index: 1; pointer-events: none;">2000</span>
                                    <!-- Textarea with padding barriers for emoji (top-right) and counter (bottom-right) -->
                                    <textarea id="message-input" class="message-input" placeholder="Message" style="flex: 1; width: 100%; padding: 8px; padding-top: 8px; padding-right: 40px; padding-bottom: 32px; background: transparent; border: none; color: #dcddde; font-size: 0.9rem; resize: none; box-sizing: border-box; line-height: 1.4; vertical-align: top;"></textarea>
                                </div>
                                <div class="message-footer" style="flex-shrink: 0; padding: 0.75rem 0;">
                                    <button id="send-btn" class="send-button" disabled style="width: 100%; justify-content: center;">
                                        Send
                                    </button>
                                </div>
                            </div>
                            </div><!-- End personal-message-content -->
                        </div>

                    </div>
                    {% endif %}
                    </div>
                    <!-- End Page: Personal Panel -->

                    <!-- Page: Team Panel -->
                    <div id="page-team-panel" class="page-content" style="height: 100%; display: none; flex-direction: column;">
                    {% if has_team and discord_linked %}
                    <div class="main-layout" style="height: 100%;">
                        <!-- Left: Discord-style Server Sidebar -->
                        <div class="server-sidebar" id="team-server-sidebar">
                            <!-- Loading placeholder shown until guilds load -->
                            <div class="server-loading-placeholder">
                                <div class="server-icon-holder placeholder">
                                    <div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>
                                </div>
                            </div>
                        </div>

                        <!-- Divider after server sidebar -->
                        <div class="server-sidebar-divider"></div>

                        <!-- Channel Selection -->
                        <div class="selection-panel" id="team-selection-panel">
                            <!-- View Mode Toggle with Radio Buttons - Centered -->
                            <div class="view-mode-toggle">
                                <label>
                                    <input type="radio" name="team-view-mode" value="servers" checked>
                                    <span>Selected server</span>
                                </label>
                                <label>
                                    <input type="radio" name="team-view-mode" value="channels">
                                    <span>All channels</span>
                                </label>
                                <label>
                                    <input type="radio" name="team-view-mode" value="selected">
                                    <span>Selected channels</span>
                                </label>
                            </div>

                            <!-- Channels Header (Servers Mode) -->
                            <div class="unified-header team-servers-mode-header">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="team-channel-search" class="search-input" placeholder="Search (press enter to add tag)">
                                        <div class="search-tags" id="team-search-tags"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Channels Only Mode Header -->
                            <div class="unified-header team-channels-only-header" style="display: none;">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="team-channels-only-search" class="search-input" placeholder="Search (press enter to add tag)">
                                        <div class="search-tags" id="team-channels-only-search-tags"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Channels List (Servers Mode) -->
                            <div class="channels-section team-servers-mode-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                                <div id="team-channels-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="no-selection">Select a server to view channels</div>
                                </div>
                            </div>

                            <!-- Channels Only List (Channels Only Mode) -->
                            <div class="team-channels-only-section" style="display: none; flex: 1; flex-direction: column; min-height: 0;">
                                <div id="team-channels-only-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>
                                </div>
                            </div>

                            <!-- Selected Channels Mode Header -->
                            <div class="unified-header team-selected-channels-mode-header" style="display: none;">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="team-selected-channels-mode-search" class="search-input" placeholder="Search">
                                    </div>
                                </div>
                            </div>

                            <!-- Selected Channels Mode List -->
                            <div class="team-selected-channels-mode-section" style="display: none; flex: 1; flex-direction: column; min-height: 0; overflow: hidden;">
                                <div id="team-selected-channels-mode-list" class="channels-list selected-channels-mode" style="flex: 1; overflow-y: auto; overflow-x: hidden; min-height: 0;">
                                    <div class="no-selection">No channels selected</div>
                                </div>
                            </div>
                        </div>

                        <!-- Vertical Divider -->
                        <div class="panel-divider"></div>

                        <!-- Middle: Message Composer Only -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; background: transparent; padding: 0 0.75rem; border: none; box-sizing: border-box; position: relative;">
                            <!-- Loading overlay -->
                            <div id="team-message-loading" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 10;">
                                <div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>
                            </div>

                            <!-- Content - hidden until loaded -->
                            <div id="team-message-content" style="opacity: 0; pointer-events: none; flex: 1; display: flex; flex-direction: column; height: 100%;">
                                <!-- Team panel label - matching view-mode-toggle position -->
                                <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                    <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Team panel (message set by team owner)</span>
                                </div>
                                <!-- Message Composer -->
                                <div class="message-section" style="display: flex; flex-direction: column; width: 100%; flex: 1; min-height: 0;">
                                    <div class="message-input-container" style="flex: 1; display: flex; flex-direction: column; background: #1A1A1E; border: 1px solid #222225; border-radius: 8px; position: relative; min-height: 0;">
                                    <!-- Emoji button - top right corner (disabled) -->
                                    <button id="team-emoji-btn" type="button" disabled style="position: absolute; top: 8px; right: 8px; background: transparent; border: none; cursor: not-allowed; padding: 0; z-index: 2; opacity: 0.5;">
                                        <img src="{{ url_for('static', filename='emojimain.png') }}" alt="Emoji" style="width: 20px; height: 20px; opacity: 0.7;">
                                    </button>
                                    <!-- Character count - bottom right corner -->
                                    <span id="team-char-count" style="position: absolute; bottom: 8px; right: 8px; color: #81828A; font-size: 0.85rem; font-weight: 500; z-index: 1; pointer-events: none;">{{ 2000 - (team.team_message or '')|length }}</span>
                                    <!-- Textarea with padding barriers for emoji (top-right) and counter (bottom-right) -->
                                    <textarea id="team-message-input" class="message-input" placeholder="No team message set" readonly style="flex: 1; width: 100%; padding: 8px; padding-top: 8px; padding-right: 40px; padding-bottom: 32px; background: transparent; border: none; color: #81828A; font-size: 0.9rem; resize: none; box-sizing: border-box; line-height: 1.4; vertical-align: top;">{{ team.team_message or '' }}</textarea>
                                </div>
                                <div class="message-footer" style="flex-shrink: 0; padding: 0.75rem 0;">
                                    <button id="team-send-btn" class="send-button"{% if not team or not team.team_message %} disabled{% endif %} style="width: 100%; justify-content: center;">
                                        Send
                                    </button>
                                </div>
                            </div>
                            </div><!-- End team-message-content -->
                        </div>

                    </div>
                    {% endif %}
                    </div>

                    <!-- Page: Team Management -->
                    <div id="page-team-management" class="page-content" style="height: 100%; display: none; flex-direction: row;">
                        {% if is_team_owner %}
                        <!-- Left Half: Team Members Management -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; position: relative;">
                            <!-- Radio Toggle -->
                            <div class="view-mode-toggle">
                                <label>
                                    <input type="radio" name="mgmt-view-mode" value="add" checked>
                                    <span>Add</span>
                                </label>
                                <label>
                                    <input type="radio" name="mgmt-view-mode" value="members">
                                    <span>Team members</span>
                                </label>
                            </div>

                            <!-- Add Mode Header (search bar + member count) -->
                            <div class="unified-header mgmt-add-mode-header">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="mgmt-add-search" class="search-input" placeholder="Search Adzsend ID (press enter to add)">
                                    </div>
                                </div>
                                <div id="mgmt-member-count-add" style="display: flex; justify-content: center; padding: 0.25rem 0 0 0;">
                                    <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">{{ active_member_count|default(0) }}/15 team members</span>
                                </div>
                            </div>

                            <!-- Team Members Mode Header (member count only, no search bar) -->
                            <div class="unified-header mgmt-members-mode-header" style="display: none;">
                                <div id="mgmt-member-count-members" style="display: flex; justify-content: center; padding: 0.5rem 0;">
                                    <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">{{ active_member_count|default(0) }}/15 team members</span>
                                </div>
                            </div>

                            <!-- Empty state messages (centered in entire left half) -->
                            {% set pending_members = members|default([])|selectattr('invitation_status', 'equalto', 'pending')|list %}
                            {% set accepted_members = members|default([])|selectattr('invitation_status', 'equalto', 'accepted')|list %}
                            <div id="mgmt-add-empty" class="no-selection" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); {% if pending_members|length > 0 %}display: none;{% endif %}">No pending invitations</div>
                            <div id="mgmt-members-empty" class="no-selection" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none;">No team members yet</div>

                            <!-- Add Mode List (Only pending invitations) -->
                            <div class="channels-section mgmt-add-mode-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0; padding-top: 0;">
                                <div id="mgmt-add-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    {% if pending_members|length > 0 %}
                                        {% for member in pending_members %}
                                            <div class="channel-item mgmt-member-item" data-adzsend-id="{{ member.member_adzsend_id }}" data-status="pending" style="cursor: default;">
                                                <div class="mgmt-member-avatar" style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden; flex-shrink: 0;">
                                                    <img src="{{ url_for('static', filename='profile_photos/' ~ (member.profile_photo if member.profile_photo else 'Light_Blue.jpg')) }}" alt="Profile" style="width: 100%; height: 100%; object-fit: cover;">
                                                </div>
                                                <span class="channel-name">{{ member.member_adzsend_id or 'No ID' }}</span>
                                                <div class="channel-right">
                                                    <span class="channel-status-tag">Pending</span>
                                                    <img class="mgmt-member-remove" src="{{ url_for('static', filename='x.png') }}" alt="x" style="width: 16px; height: 16px; cursor: pointer; opacity: 0.7;" data-action="cancel-invite">
                                                </div>
                                            </div>
                                        {% endfor %}
                                    {% endif %}
                                </div>
                            </div>

                            <!-- Team Members Mode List (Only accepted members) -->
                            <div class="channels-section mgmt-members-mode-section" style="display: none; flex: 1; flex-direction: column; min-height: 0; padding-top: 0;">
                                <div id="mgmt-members-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    {% if accepted_members|length > 0 %}
                                        {% for member in accepted_members %}
                                            <div class="channel-item mgmt-member-item" data-adzsend-id="{{ member.member_adzsend_id }}" data-status="accepted" style="cursor: default;">
                                                <div class="mgmt-member-avatar" style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden; flex-shrink: 0;">
                                                    <img src="{{ url_for('static', filename='profile_photos/' ~ (member.profile_photo if member.profile_photo else 'Light_Blue.jpg')) }}" alt="Profile" style="width: 100%; height: 100%; object-fit: cover;">
                                                </div>
                                                <span class="channel-name">{{ member.member_adzsend_id or 'No ID' }}</span>
                                                <div class="channel-right">
                                                    <span class="channel-status-tag">Team member</span>
                                                    <img class="mgmt-member-remove" src="{{ url_for('static', filename='x.png') }}" alt="x" style="width: 16px; height: 16px; cursor: pointer; opacity: 0.7;" data-action="remove-member">
                                                </div>
                                            </div>
                                        {% endfor %}
                                    {% endif %}
                                </div>
                            </div>
                        </div>

                        <!-- Vertical Divider -->
                        <div class="panel-divider"></div>

                        <!-- Right Half: Team Message (same UI as Personal panel) -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; background: transparent; border: none; box-sizing: border-box;">
                            <!-- Team message label - matching view-mode-toggle position -->
                            <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Team message</span>
                            </div>
                            <!-- Message Composer -->
                            <div class="message-section" style="display: flex; flex-direction: column; flex: 1; min-height: 0; margin: 0 0.75rem;">
                                <div class="message-input-container" style="flex: 1; display: flex; flex-direction: column; background: #1A1A1E; border: 1px solid #222225; border-radius: 8px; position: relative; min-height: 0;">
                                    <!-- Emoji button - top right corner (disabled) -->
                                    <button id="mgmt-emoji-btn" type="button" disabled style="position: absolute; top: 8px; right: 8px; background: transparent; border: none; cursor: not-allowed; padding: 0; z-index: 2; opacity: 0.5;">
                                        <img src="{{ url_for('static', filename='emojimain.png') }}" alt="Emoji" style="width: 20px; height: 20px; opacity: 0.7;">
                                    </button>
                                    <!-- Character count - bottom right corner -->
                                    <span id="mgmt-char-count" style="position: absolute; bottom: 8px; right: 8px; color: #81828A; font-size: 0.85rem; font-weight: 500; z-index: 1; pointer-events: none;">{{ 2000 - (team.team_message or '')|length }}</span>
                                    <!-- Textarea with padding barriers for emoji (top-right) and counter (bottom-right) -->
                                    <textarea id="mgmt-team-message-input" class="message-input" placeholder="Message" style="flex: 1; width: 100%; padding: 8px; padding-top: 8px; padding-right: 40px; padding-bottom: 32px; background: transparent; border: none; color: #dcddde; font-size: 0.9rem; resize: none; box-sizing: border-box; line-height: 1.4; vertical-align: top;">{{ team.team_message or '' }}</textarea>
                                </div>
                                <div class="message-footer" style="flex-shrink: 0; padding: 0.75rem 0;">
                                    <button id="mgmt-save-btn" class="send-button" style="width: 100%; justify-content: center;">
                                        Save
                                    </button>
                                </div>
                            </div>
                        </div>
                        {% else %}
                        <!-- No access message -->
                        <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
                            <div class="no-selection">You need to be a team owner to access this page</div>
                        </div>
                        {% endif %}
                    </div>

                    <!-- Page: Analytics -->
                    <div id="page-analytics" class="page-content" style="height: 100%; display: flex; flex-direction: row;">
                        <!-- Left Half: Personal Analytics -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; position: relative;">
                            <!-- Loading overlay - shows in center until everything loads -->
                            <div id="personal-analytics-loading" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 10;">
                                <div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>
                            </div>

                            <!-- Content - hidden until loaded -->
                            <div id="personal-analytics-content" style="opacity: 0; pointer-events: none; flex: 1; display: flex; flex-direction: column; height: 100%;">
                                <!-- Label (replaces radio toggle) -->
                                <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                    <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Personal analytics</span>
                                </div>

                                <!-- Personal Analytics Stats -->
                                <div id="personal-analytics-stats" style="display: flex; flex-direction: column; padding: 0 1rem; margin-bottom: 0.5rem;">
                                    <div class="personal-stat-row" style="display: flex; justify-content: space-between; padding: 0.4rem 0;">
                                        <span style="color: #81828A; font-size: 0.8rem;">All time messages sent across personal panel</span>
                                        <span id="stat-personal-all-time" style="color: #dcddde; font-size: 0.8rem; font-weight: 500;"></span>
                                    </div>
                                    <div style="height: 1px; background: #222225;"></div>
                                    <div class="personal-stat-row" style="display: flex; justify-content: space-between; padding: 0.4rem 0;">
                                        <span style="color: #81828A; font-size: 0.8rem;">All time messages sent across team panels</span>
                                        <span id="stat-team-all-time" style="color: #dcddde; font-size: 0.8rem; font-weight: 500;"></span>
                                    </div>
                                    <div style="height: 1px; background: #222225;"></div>
                                    <div class="personal-stat-row" style="display: flex; justify-content: space-between; padding: 0.4rem 0;">
                                        <span style="color: #81828A; font-size: 0.8rem;">All time messages sent across all panels</span>
                                        <span id="stat-total-all-time" style="color: #dcddde; font-size: 0.8rem; font-weight: 500;"></span>
                                    </div>
                                    <div style="height: 1px; background: #222225;"></div>
                                    <div class="personal-stat-row" style="display: flex; justify-content: space-between; padding: 0.4rem 0;">
                                        <span class="date-format-label" data-label-template="Peak send date on personal panel (%FORMAT%)" style="color: #81828A; font-size: 0.8rem;">Peak send date on personal panel ({{ user_data.date_format if user_data.date_format else 'mm/dd/yy' }})</span>
                                        <span id="stat-peak-date-personal" style="color: #dcddde; font-size: 0.8rem; font-weight: 500;"></span>
                                    </div>
                                    <div style="height: 1px; background: #222225;"></div>
                                    <div class="personal-stat-row" style="display: flex; justify-content: space-between; padding: 0.4rem 0;">
                                        <span class="date-format-label" data-label-template="Peak send date across all panels (%FORMAT%)" style="color: #81828A; font-size: 0.8rem;">Peak send date across all panels ({{ user_data.date_format if user_data.date_format else 'mm/dd/yy' }})</span>
                                        <span id="stat-peak-date-all" style="color: #dcddde; font-size: 0.8rem; font-weight: 500;"></span>
                                    </div>
                                </div>

                                <!-- Personal Chart Section -->
                            <div style="flex: 1; display: flex; flex-direction: column; padding: 1rem; min-height: 0;">
                                <div class="date-range-container" style="margin-bottom: 1rem;">
                                    <div class="date-input-group">
                                        <label>From</label>
                                        <div class="custom-date-wrapper">
                                            <input type="text" id="personal-start-date-text" class="custom-date-text" data-picker="personal-start-date">
                                            <input type="date" id="personal-start-date" class="hidden-date-picker">
                                            <img src="/static/calendar.png" class="calendar-trigger" data-picker="personal-start-date" alt="calendar">
                                        </div>
                                    </div>
                                    <div class="date-input-group">
                                        <label>To</label>
                                        <div class="custom-date-wrapper">
                                            <input type="text" id="personal-end-date-text" class="custom-date-text" data-picker="personal-end-date">
                                            <input type="date" id="personal-end-date" class="hidden-date-picker">
                                            <img src="/static/calendar.png" class="calendar-trigger" data-picker="personal-end-date" alt="calendar">
                                        </div>
                                    </div>
                                    <button class="apply-dates-btn" onclick="applyPersonalDateRange()">Apply</button>
                                </div>
                                <script>
                                    // Set default dates immediately to avoid showing dd/mm/yyyy
                                    (function() {
                                        const today = new Date().toISOString().split('T')[0];
                                        const thirtyDaysAgo = new Date();
                                        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                                        const startDate = thirtyDaysAgo.toISOString().split('T')[0];

                                        const startInput = document.getElementById('personal-start-date');
                                        const endInput = document.getElementById('personal-end-date');
                                        if (startInput) startInput.value = startDate;
                                        if (endInput) endInput.value = today;

                                        // Update custom date displays after setting values
                                        if (typeof updateCustomDateDisplays === 'function') {
                                            updateCustomDateDisplays();
                                        }
                                    })();
                                </script>
                                <div class="chart-container" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                                    <div class="chart-canvas-wrapper" style="flex: 1; min-height: 0;">
                                        <canvas id="personal-analytics-chart" class="chart-canvas"></canvas>
                                        <div class="chart-tooltip" id="personal-chart-tooltip"></div>
                                    </div>
                                    <div class="chart-summary" id="personal-chart-summary">
                                        <div class="chart-summary-item">
                                            <div class="chart-summary-value" id="personal-summary-total">0</div>
                                            <div class="chart-summary-label">Total ads</div>
                                        </div>
                                        <div class="chart-summary-item">
                                            <div class="chart-summary-value" id="personal-summary-avg">0</div>
                                            <div class="chart-summary-label">Daily avg</div>
                                        </div>
                                        <div class="chart-summary-item">
                                            <div class="chart-summary-value" id="personal-summary-peak">0</div>
                                            <div class="chart-summary-label">Peak day</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            </div><!-- End personal-analytics-content -->
                        </div>

                        <!-- Vertical Divider -->
                        <div class="panel-divider"></div>

                        <!-- Right Half: Team Analytics -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; position: relative;">
                            <!-- Top Half: Individual team member analytics -->
                            <div style="flex: 1 1 50%; display: flex; flex-direction: column; min-height: 0; max-height: calc(50% - 0.5px); position: relative;">
                                {% if is_team_owner %}
                                <!-- Loading overlay - shows in center until everything loads -->
                                <div id="team-analytics-loading" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 10;">
                                    <div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>
                                </div>

                                <!-- Content - hidden until loaded -->
                                <div id="team-analytics-content" style="opacity: 0; pointer-events: none; flex: 1; display: flex; flex-direction: column; height: 100%;">
                                    <!-- Label -->
                                    <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                        <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Individual team member analytics</span>
                                    </div>

                                    <!-- Header (search bar) -->
                                    <div class="unified-header">
                                    <div class="header-section">
                                        <div class="channels-search">
                                            <input type="text" id="analytics-team-search" class="search-input" placeholder="Search Adzsend ID" oninput="filterAnalyticsMembersList()">
                                        </div>
                                    </div>
                                </div>

                                <!-- List Section -->
                                <div class="channels-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0; padding-top: 0;">
                                    <div id="analytics-team-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                        <!-- Team Owner at top -->
                                        {% if is_team_owner and user %}
                                            <div class="channel-item analytics-member-item" data-adzsend-id="{{ user.adzsend_id }}" data-is-owner="true" style="cursor: pointer;">
                                                <div class="mgmt-member-avatar" style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden; flex-shrink: 0;">
                                                    <img src="{{ url_for('static', filename='profile_photos/' ~ (user_data.profile_photo if user_data and user_data.profile_photo else 'Light_Blue.jpg')) }}" alt="Profile" style="width: 100%; height: 100%; object-fit: cover;" class="user-profile-photo">
                                                </div>
                                                <span class="channel-name" style="display: flex; align-items: center; gap: 6px;">{{ user.adzsend_id }}<img src="{{ url_for('static', filename='OwnerDiscordCrown.png') }}" alt="Owner" title="Team owner" style="width: 16px; height: 16px;"></span>
                                            </div>
                                        {% endif %}
                                        <!-- Team Members -->
                                        {% set accepted_members = members|default([])|selectattr('invitation_status', 'equalto', 'accepted')|list %}
                                        {% for member in accepted_members %}
                                            <div class="channel-item analytics-member-item" data-adzsend-id="{{ member.member_adzsend_id }}" style="cursor: pointer;">
                                                <div class="mgmt-member-avatar" style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden; flex-shrink: 0;">
                                                    <img src="{{ url_for('static', filename='profile_photos/' ~ (member.profile_photo if member.profile_photo else 'Light_Blue.jpg')) }}" alt="Profile" style="width: 100%; height: 100%; object-fit: cover;">
                                                </div>
                                                <span class="channel-name">{{ member.member_adzsend_id or 'No ID' }}</span>
                                            </div>
                                        {% endfor %}
                                    </div>
                                </div>
                                </div><!-- End team-analytics-content -->
                                {% else %}
                                <!-- Non-owner message -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; justify-content: center; align-items: center;">
                                    <span class="no-selection">Only available for team owners</span>
                                </div>
                                {% endif %}
                            </div>

                            <!-- Horizontal Divider -->
                            <div style="height: 1px; background: #222225; margin: 0; flex-shrink: 0;"></div>

                            <!-- Bottom Half: Overall team analytics -->
                            <div style="flex: 1 1 50%; display: flex; flex-direction: column; min-height: 0; max-height: calc(50% - 0.5px); position: relative;">
                                {% if is_team_owner %}
                                <!-- Label -->
                                <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                    <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Overall team analytics</span>
                                </div>

                                <!-- Empty space for now -->
                                <div style="flex: 1;"></div>
                                {% else %}
                                <!-- Non-owner message -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; justify-content: center; align-items: center;">
                                    <span class="no-selection">Only available for team owners</span>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <!-- Analytics Dialog -->
    <div class="analytics-dialog-overlay" id="analytics-dialog-overlay">
        <div class="analytics-dialog">
            <button class="analytics-dialog-close" onclick="closeAnalyticsDialog()">&times;</button>
            <h3 class="analytics-dialog-title" id="analytics-dialog-title">Member Analytics</h3>
            <!-- Radio Toggle for Information/Dates -->
            <div class="analytics-toggle">
                <label>
                    <input type="radio" name="analytics-view-mode" value="information" checked onchange="switchAnalyticsTab('information')">
                    <span>Information</span>
                </label>
                <label>
                    <input type="radio" name="analytics-view-mode" value="dates" onchange="switchAnalyticsTab('dates')">
                    <span>Dates</span>
                </label>
            </div>
            <div class="analytics-content">
                <!-- Information Panel -->
                <div class="analytics-panel active" id="panel-information">
                    <div id="analytics-info-content">
                        <div class="no-data-message">Loading...</div>
                    </div>
                </div>
                <!-- Dates Panel -->
                <div class="analytics-panel" id="panel-dates">
                    <div class="date-range-container">
                        <div class="date-input-group">
                            <label>From</label>
                            <div class="custom-date-wrapper">
                                <input type="text" id="analytics-start-date-text" class="custom-date-text" data-picker="analytics-start-date">
                                <input type="date" id="analytics-start-date" class="hidden-date-picker">
                                <img src="/static/calendar.png" class="calendar-trigger" data-picker="analytics-start-date" alt="calendar">
                            </div>
                        </div>
                        <div class="date-input-group">
                            <label>To</label>
                            <div class="custom-date-wrapper">
                                <input type="text" id="analytics-end-date-text" class="custom-date-text" data-picker="analytics-end-date">
                                <input type="date" id="analytics-end-date" class="hidden-date-picker">
                                <img src="/static/calendar.png" class="calendar-trigger" data-picker="analytics-end-date" alt="calendar">
                            </div>
                        </div>
                        <button class="apply-dates-btn" onclick="applyDateRange()">Apply</button>
                    </div>
                    <script>
                        // Set default dates immediately for analytics dialog
                        (function() {
                            const today = new Date().toISOString().split('T')[0];
                            const thirtyDaysAgo = new Date();
                            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                            const startDate = thirtyDaysAgo.toISOString().split('T')[0];

                            const startInput = document.getElementById('analytics-start-date');
                            const endInput = document.getElementById('analytics-end-date');
                            if (startInput) startInput.value = startDate;
                            if (endInput) endInput.value = today;

                            // Update custom date displays after setting values
                            if (typeof updateCustomDateDisplays === 'function') {
                                updateCustomDateDisplays();
                            }
                        })();
                    </script>
                    <div class="chart-container">
                        <div class="chart-canvas-wrapper">
                            <canvas id="analytics-chart" class="chart-canvas"></canvas>
                            <div class="chart-tooltip" id="chart-tooltip"></div>
                        </div>
                        <div class="chart-summary" id="chart-summary">
                            <div class="chart-summary-item">
                                <div class="chart-summary-value" id="summary-total">0</div>
                                <div class="chart-summary-label">Total ads</div>
                            </div>
                            <div class="chart-summary-item">
                                <div class="chart-summary-value" id="summary-avg">0</div>
                                <div class="chart-summary-label">Daily avg</div>
                            </div>
                            <div class="chart-summary-item">
                                <div class="chart-summary-value" id="summary-peak">0</div>
                                <div class="chart-summary-label">Peak day</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    {% include 'partials/settings_popup.html' %}

    <style>
        /* Analytics Dialog Styles - matching custom-popup */
        .analytics-dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .analytics-dialog-overlay.show {
            display: flex;
        }

        .analytics-dialog {
            background: #1A1A1E;
            border: 1px solid #222225;
            border-radius: 8px;
            padding: 1.25rem 1.5rem 1.5rem 1.5rem;
            width: 440px;
            max-width: 95vw;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .analytics-dialog-title {
            color: #ffffff;
            font-size: 1.125rem;
            font-weight: 600;
            margin: 0 0 0.75rem 0;
            padding-right: 2rem;
        }

        .analytics-dialog-close {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            color: #81828A;
            cursor: pointer;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            line-height: 1;
            transition: all 0.15s ease;
        }

        .analytics-dialog-close:hover {
            background: #1A1A1E;
            border-color: #222225;
            color: white;
        }

        /* Radio toggle - same as view-mode-toggle */
        .analytics-toggle {
            display: flex;
            gap: 1.5rem;
            padding: 0.5rem 0;
            justify-content: center;
            margin-bottom: 0.75rem;
        }

        .analytics-toggle label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .analytics-toggle span {
            color: #dcddde;
            font-weight: 500;
            font-size: 0.85rem;
        }

        .analytics-content {
            padding: 0;
            overflow-y: auto;
            flex: 1;
        }

        .analytics-panel {
            display: none;
        }

        .analytics-panel.active {
            display: block;
        }

        .analytics-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #282930;
        }

        .analytics-stat-row:last-child {
            border-bottom: none;
        }

        .analytics-stat-label {
            color: #81828A;
            font-size: 0.9rem;
        }

        .analytics-stat-value {
            color: #dcddde;
            font-weight: 600;
        }

        .analytics-progress-bar {
            width: 100%;
            height: 8px;
            background: #282930;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .analytics-progress-fill {
            height: 100%;
            background: linear-gradient(to right, #15d8bc, #006e59);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Date picker styles */
        .date-range-container {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .date-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .date-input-group label {
            color: #81828A;
            font-size: 0.75rem;
        }

        .date-input-group input {
            background: #212227;
            border: 1px solid #282930;
            border-radius: 6px;
            padding: 0.5rem;
            color: #dcddde;
            font-size: 0.85rem;
        }

        .date-input-group input:focus {
            outline: none;
        }

        .date-input-group input[type="date"]::-webkit-calendar-picker-indicator {
            background: url('/static/calendar.png') no-repeat center;
            background-size: contain;
            filter: brightness(0) invert(1);
            cursor: pointer;
        }

        /* Custom date wrapper for format display */
        .custom-date-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            width: 100%;
        }

        .custom-date-text {
            background: #212227;
            border: 1px solid #282930;
            border-radius: 6px;
            padding: 0.5rem;
            padding-right: 2rem;
            color: #dcddde;
            font-size: 0.85rem;
            width: 100%;
        }

        .custom-date-text:focus {
            outline: none;
            border-color: #282930;
        }

        .hidden-date-picker {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            cursor: pointer;
            z-index: -1;
        }

        .calendar-trigger {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            cursor: pointer;
            filter: brightness(0) invert(1);
            opacity: 0.7;
        }

        .apply-dates-btn {
            background: transparent;
            border: none;
            color: #15d8bc;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            margin-top: auto;
        }

        .apply-dates-btn:hover {
            color: #10b89e;
        }

        /* Chart styles */
        .chart-container {
            background: #121215;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .chart-canvas-wrapper {
            position: relative;
            width: 100%;
            height: 140px;
            overflow: hidden;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
        }

        .chart-tooltip {
            position: absolute;
            background: #1A1A1E;
            border: 1px solid #222225;
            color: #dcddde;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 10;
            display: none;
            white-space: nowrap;
            text-align: center;
        }

        .chart-summary {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #282930;
        }

        .chart-summary-item {
            text-align: center;
        }

        .chart-summary-value {
            color: #15d8bc;
            font-size: 1.2rem;
            font-weight: 700;
        }

        .chart-summary-label {
            color: #81828A;
            font-size: 0.7rem;
            margin-top: 0.25rem;
        }

        .no-data-message {
            text-align: center;
            color: #81828A;
            padding: 2rem;
        }

        /* Analytics Dialog Responsive */
        @media (max-width: 480px) {
            .analytics-dialog {
                width: 92vw;
                max-width: none;
                padding: 0.875rem 1rem 1rem 1rem;
                max-height: 85vh;
            }

            .analytics-dialog-title {
                font-size: 0.95rem;
                padding-right: 1.75rem;
            }

            .analytics-dialog-close {
                top: 0.6rem;
                right: 0.6rem;
                width: 24px;
                height: 24px;
                font-size: 1.25rem;
            }

            .analytics-toggle {
                gap: 1rem;
            }

            .analytics-toggle span {
                font-size: 0.8rem;
            }

            .date-range-container {
                flex-direction: column;
                gap: 0.75rem;
            }

            .date-input-group {
                width: 100%;
            }

            .apply-dates-btn {
                width: 100%;
                margin-top: 0.5rem;
            }
        }

        /* Member Stats Styles */
        .member-stats-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .member-stat-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: #212227;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .member-stat-item:hover {
            background: #2a2b32;
        }

        .member-stat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
        }

        .member-stat-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .member-stat-info {
            flex: 1;
            min-width: 0;
        }

        .member-stat-username {
            color: #dcddde;
            font-weight: 500;
            font-size: 0.95rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .member-stat-id {
            color: #81828A;
            font-size: 0.8rem;
            font-family: 'gg sans', sans-serif;
        }

        .member-stat-usage {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem 1rem;
            background: #121215;
            border-radius: 6px;
            min-width: 80px;
        }

        .stat-number {
            color: #15d8bc;
            font-weight: 700;
            font-size: 1.2rem;
            line-height: 1;
        }

        .stat-label {
            color: #81828A;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 0.25rem;
        }

        .view-analytics-btn {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
            border: none;
            color: #121215;
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s ease;
            margin-left: auto;
        }

        .view-analytics-btn:hover {
            background: linear-gradient(to bottom, #10b89e, #004e40);
        }
    </style>


    <script>
        // Global message delay variable - can be updated by settings popup
        window.userMessageDelay = parseInt('{{ user_data.message_delay }}') || 1000;

        // Global date format variable - can be updated by settings popup
        window.userDateFormat = '{{ user_data.date_format if user_data.date_format else "mm/dd/yy" }}';

        // Global date formatting function
        function formatDateWithUserFormat(dateStr) {
            if (!dateStr) return '';
            const d = new Date(dateStr);
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            const year = String(d.getFullYear()).slice(-2);

            switch (window.userDateFormat) {
                case 'dd/mm/yy':
                    return `${day}/${month}/${year}`;
                case 'yy/mm/dd':
                    return `${year}/${month}/${day}`;
                case 'mm/dd/yy':
                default:
                    return `${month}/${day}/${year}`;
            }
        }

        // Get the date format label text based on current format
        function getDateFormatLabel() {
            return window.userDateFormat || 'mm/dd/yy';
        }

        // Update all date format labels on the page
        function updateDateFormatLabels() {
            const formatLabel = getDateFormatLabel();
            document.querySelectorAll('.date-format-label').forEach(el => {
                const template = el.getAttribute('data-label-template');
                if (template) {
                    el.textContent = template.replace('%FORMAT%', formatLabel);
                }
            });
        }

        // Format ISO date (YYYY-MM-DD) to user's format
        function formatDateToUserFormat(isoDate) {
            if (!isoDate) return '';
            const [year, month, day] = isoDate.split('-');
            const shortYear = year.slice(-2);
            switch (window.userDateFormat) {
                case 'dd/mm/yy':
                    return `${day}/${month}/${shortYear}`;
                case 'yy/mm/dd':
                    return `${shortYear}/${month}/${day}`;
                case 'mm/dd/yy':
                default:
                    return `${month}/${day}/${shortYear}`;
            }
        }

        // Parse user format date string to ISO (YYYY-MM-DD)
        function parseUserDateToISO(dateStr) {
            if (!dateStr) return null;
            const parts = dateStr.split('/');
            if (parts.length !== 3) return null;

            let day, month, year;
            switch (window.userDateFormat) {
                case 'dd/mm/yy':
                    [day, month, year] = parts;
                    break;
                case 'yy/mm/dd':
                    [year, month, day] = parts;
                    break;
                case 'mm/dd/yy':
                default:
                    [month, day, year] = parts;
                    break;
            }

            // Convert 2-digit year to 4-digit (assume 2000s)
            if (year && year.length === 2) {
                year = '20' + year;
            }

            const d = parseInt(day), m = parseInt(month), y = parseInt(year);
            if (isNaN(d) || isNaN(m) || isNaN(y)) return null;
            if (d < 1 || d > 31 || m < 1 || m > 12 || y < 1900 || y > 2100) return null;

            // Validate the date is real
            const testDate = new Date(y, m - 1, d);
            if (testDate.getDate() !== d || testDate.getMonth() !== m - 1) return null;

            return `${y}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
        }

        // Sync text input from hidden date picker
        function syncTextFromPicker(pickerId, skipSwapCheck) {
            const picker = document.getElementById(pickerId);
            const textInput = document.querySelector(`.custom-date-text[data-picker="${pickerId}"]`);
            if (!picker || !textInput || !picker.value) return;

            // Get min/max from the picker
            const minDate = picker.min || null;
            const maxDate = picker.max || null;

            // Clamp to valid range
            let validDate = picker.value;
            if (minDate && validDate < minDate) {
                validDate = minDate;
                picker.value = validDate;
            }
            if (maxDate && validDate > maxDate) {
                validDate = maxDate;
                picker.value = validDate;
            }

            textInput.value = formatDateToUserFormat(validDate);

            // Handle date swapping for from/to pairs (only if not already in a swap operation)
            if (!skipSwapCheck) {
                const isStartPicker = pickerId.includes('start');
                const isEndPicker = pickerId.includes('end');

                if (isStartPicker) {
                    const endPickerId = pickerId.replace('start', 'end');
                    const endPicker = document.getElementById(endPickerId);
                    if (endPicker && endPicker.value && validDate > endPicker.value) {
                        const temp = endPicker.value;
                        endPicker.value = validDate;
                        picker.value = temp;
                        textInput.value = formatDateToUserFormat(temp);
                        syncTextFromPicker(endPickerId, true);
                    }
                } else if (isEndPicker) {
                    const startPickerId = pickerId.replace('end', 'start');
                    const startPicker = document.getElementById(startPickerId);
                    if (startPicker && startPicker.value && validDate < startPicker.value) {
                        const temp = startPicker.value;
                        startPicker.value = validDate;
                        picker.value = temp;
                        textInput.value = formatDateToUserFormat(temp);
                        syncTextFromPicker(startPickerId, true);
                    }
                }
            }
        }

        // Sync hidden date picker from text input with validation
        function syncPickerFromText(textInput) {
            const pickerId = textInput.getAttribute('data-picker');
            const picker = document.getElementById(pickerId);
            if (!picker) return;

            const isoDate = parseUserDateToISO(textInput.value);
            if (!isoDate) {
                // Invalid date format - revert to the current picker value
                textInput.value = formatDateToUserFormat(picker.value);
                return;
            }

            // Get min/max from the picker (set by analytics initialization)
            const minDate = picker.min || null;
            const maxDate = picker.max || null;

            // Clamp to valid range
            let validDate = isoDate;
            if (minDate && validDate < minDate) {
                validDate = minDate;
            }
            if (maxDate && validDate > maxDate) {
                validDate = maxDate;
            }

            // Update picker value
            picker.value = validDate;

            // Update text to show the (possibly clamped) date
            textInput.value = formatDateToUserFormat(validDate);

            // Handle date swapping for from/to pairs
            const isStartPicker = pickerId.includes('start');
            const isEndPicker = pickerId.includes('end');

            if (isStartPicker) {
                // Find corresponding end picker
                const endPickerId = pickerId.replace('start', 'end');
                const endPicker = document.getElementById(endPickerId);
                const endTextInput = document.querySelector(`.custom-date-text[data-picker="${endPickerId}"]`);

                if (endPicker && endPicker.value && validDate > endPicker.value) {
                    // Swap: start > end, so swap them
                    const temp = endPicker.value;
                    endPicker.value = validDate;
                    picker.value = temp;
                    textInput.value = formatDateToUserFormat(temp);
                    if (endTextInput) endTextInput.value = formatDateToUserFormat(validDate);
                }
            } else if (isEndPicker) {
                // Find corresponding start picker
                const startPickerId = pickerId.replace('end', 'start');
                const startPicker = document.getElementById(startPickerId);
                const startTextInput = document.querySelector(`.custom-date-text[data-picker="${startPickerId}"]`);

                if (startPicker && startPicker.value && validDate < startPicker.value) {
                    // Swap: end < start, so swap them
                    const temp = startPicker.value;
                    startPicker.value = validDate;
                    picker.value = temp;
                    textInput.value = formatDateToUserFormat(temp);
                    if (startTextInput) startTextInput.value = formatDateToUserFormat(validDate);
                }
            }

        }

        // Update all text inputs from their hidden pickers
        function updateCustomDateDisplays() {
            document.querySelectorAll('.custom-date-text[data-picker]').forEach(textInput => {
                const pickerId = textInput.getAttribute('data-picker');
                syncTextFromPicker(pickerId);
            });
        }

        // Initialize custom date input system
        function initCustomDateInputs() {
            // Calendar trigger click opens date picker
            document.querySelectorAll('.calendar-trigger[data-picker]').forEach(trigger => {
                trigger.addEventListener('click', function() {
                    const pickerId = this.getAttribute('data-picker');
                    const picker = document.getElementById(pickerId);
                    if (picker && picker.showPicker) {
                        picker.showPicker();
                    }
                });
            });

            // Hidden date picker change updates text input
            document.querySelectorAll('.hidden-date-picker').forEach(picker => {
                picker.addEventListener('change', function() {
                    syncTextFromPicker(this.id);
                });
            });

            // Text input blur validates and syncs to hidden picker
            document.querySelectorAll('.custom-date-text[data-picker]').forEach(textInput => {
                textInput.addEventListener('blur', function() {
                    syncPickerFromText(this);
                });
                textInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        syncPickerFromText(this);
                        this.blur();
                        // Trigger the appropriate apply function
                        const pickerId = this.getAttribute('data-picker');
                        if (pickerId.startsWith('personal-')) {
                            if (typeof applyPersonalDateRange === 'function') {
                                applyPersonalDateRange();
                            }
                        } else if (pickerId.startsWith('analytics-')) {
                            if (typeof applyDateRange === 'function') {
                                applyDateRange();
                            }
                        }
                    }
                });
            });

            // Initial sync
            updateCustomDateDisplays();
        }

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', function() {
            initCustomDateInputs();
            updateDateFormatLabels();
        });
        // Also try immediately in case DOMContentLoaded already fired
        if (document.readyState !== 'loading') {
            initCustomDateInputs();
            updateDateFormatLabels();
        }

        // Listen for date format changes from settings popup
        window.addEventListener('dateFormatChanged', function(e) {
            updateDateFormatLabels();
            // Re-sync all text inputs with new format
            updateCustomDateDisplays();
            // Refresh analytics data to update displayed dates
            if (typeof loadPersonalAnalyticsSummary === 'function') {
                loadPersonalAnalyticsSummary();
            }
            // Refresh team analytics if the dialog is open
            if (typeof loadAnalyticsInfo === 'function') {
                const analyticsDialog = document.getElementById('analytics-dialog');
                if (analyticsDialog && analyticsDialog.style.display !== 'none') {
                    loadAnalyticsInfo();
                }
            }
        });

        // Tag Limit Modal - using customAlert popup system
        async function showTagLimitModal() {
            await customAlert('Tag limit reached', 'Maximum 6 tags allowed. Please remove a tag before adding a new one.', 'OK');
        }

        // Tag Character Limit Modal - using customAlert popup system
        async function showTagCharLimitModal() {
            await customAlert('Tag character limit exceeded', 'Each tag can only have 10 characters.', 'Ok');
        }

        // Channel Limit Modal - using customAlert popup system
        async function showChannelLimitModal(limit) {
            await customAlert('Channel limit reached', `You can only select up to ${limit} channel${limit !== 1 ? 's' : ''} per server on your current plan.`, 'OK');
        }
        // Prevent page from being stored in cache
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                window.location.reload();
            }
        });

        // Global function to show send results (used by both Personal and Team panels)
        async function showSendResults(succeeded, rateLimited, failed, wasCancelled = false) {
            // Determine title based on results
            let title;
            if (wasCancelled) {
                title = 'Sending cancelled';
            } else {
                title = succeeded.length > 0 ? 'Send succeeded' : 'Failed to send';
            }

            // Build content HTML for scroll frame - no gaps between items
            let contentHTML = '';

            // Success section
            if (succeeded.length > 0) {
                contentHTML += `<div style="color: #dcddde; font-size: 0.85rem; font-weight: 500;">Succeeded (${succeeded.length})</div>`;
                contentHTML += succeeded.map(ch => `<div style="color: #81828A; font-size: 0.75rem;"># ${ch}</div>`).join('');
            }

            // Rate limited section
            if (rateLimited.length > 0) {
                if (contentHTML) contentHTML += `<div style="height: 8px;"></div>`;
                contentHTML += `<div style="color: #dcddde; font-size: 0.85rem; font-weight: 500;">Rate limited (${rateLimited.length})</div>`;
                contentHTML += rateLimited.map(ch => `<div style="color: #81828A; font-size: 0.75rem;"># ${ch}</div>`).join('');
            }

            // Failed section
            if (failed.length > 0) {
                if (contentHTML) contentHTML += `<div style="height: 8px;"></div>`;
                contentHTML += `<div style="color: #dcddde; font-size: 0.85rem; font-weight: 500;">Failed (${failed.length})</div>`;
                contentHTML += failed.map(ch => `<div style="color: #81828A; font-size: 0.75rem;"># ${ch}</div>`).join('');
            }

            await customAlert(title, '', { contentHtml: contentHTML });
        }

        // Account switcher popup function
        async function showAccountSwitcher(linkedAccounts) {
            // Build account cards HTML
            let contentHTML = '';

            for (const account of linkedAccounts) {
                const avatarUrl = account.avatar
                    ? `https://cdn.discordapp.com/avatars/${account.discord_id}/${account.avatar}.png?size=64`
                    : `https://cdn.discordapp.com/embed/avatars/0.png`;

                const decorationHtml = account.avatar_decoration
                    ? `<img class="avatar-decoration" src="https://cdn.discordapp.com/avatar-decoration-presets/${account.avatar_decoration}.png?size=160&passthrough=true" alt="" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 120%; height: 120%; pointer-events: none; z-index: 1;">`
                    : '';

                contentHTML += `
                    <div class="account-switcher-card" data-account-id="${account.id}" style="display: flex; align-items: center; gap: 10px; padding: 13px; cursor: pointer; border-radius: 6px; border: 1px solid #222225; margin-bottom: 8px;">
                        <div style="position: relative; width: 32px; height: 32px; flex-shrink: 0; overflow: visible;">
                            <img src="${avatarUrl}" alt="Avatar" style="width: 100%; height: 100%; border-radius: 50%;">
                            ${decorationHtml}
                        </div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="color: #dcddde; font-size: 0.85rem; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${account.username}</div>
                            <div style="color: #81828A; font-size: 0.75rem;">${account.discord_id}</div>
                        </div>
                    </div>
                `;
            }

            // Add click handlers before showing popup
            setTimeout(() => {
                document.querySelectorAll('.account-switcher-card').forEach(card => {
                    card.addEventListener('click', async function() {
                        const accountId = parseInt(this.getAttribute('data-account-id'));
                        const operationId = `switch_account_${accountId}`;

                        if (AsyncButton.isProcessing(operationId)) return;
                        AsyncButton.startOperation(operationId);

                        // Close the popup first
                        closePopup(true);

                        // Call API to switch account
                        try {
                            const response = await fetch('/api/switch-discord-account', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRF-Token': '{{ csrf_token }}'
                                },
                                body: JSON.stringify({ account_id: accountId })
                            });

                            const data = await response.json();

                            if (data.success) {
                                // Reload page to refresh with new account
                                window.location.reload();
                            } else {
                                await customAlert('Error', data.error || 'Failed to switch account');
                            }
                        } catch (error) {
                            console.error('Error switching account:', error);
                            await customAlert('Error', 'Failed to switch account. Please try again.');
                        } finally {
                            AsyncButton.endOperation(operationId);
                        }
                    });
                });
            }, 50);

            await customAlert('Switch account', 'Select which Discord account to use:', { contentHtml: contentHTML, hideButton: true });
        }

        // Mobile dashboard navigation
        function isDashboardMobile() {
            return window.innerWidth <= 900;
        }

        function dashboardMobileBack() {
            const wrapper = document.querySelector('.main-content-wrapper');
            if (wrapper) {
                wrapper.classList.remove('mobile-page-active');
            }
        }

        function showDashboardMobilePage(pageName) {
            const wrapper = document.querySelector('.main-content-wrapper');
            const titleEl = document.getElementById('dashboard-mobile-page-title');

            // Update title based on page
            const pageTitles = {
                'personal-panel': 'Personal panel',
                'team-panel': 'Team panel',
                'team-management': 'Team management',
                'analytics': 'Analytics'
            };

            if (titleEl && pageTitles[pageName]) {
                titleEl.textContent = pageTitles[pageName];
            }

            if (wrapper) {
                wrapper.classList.add('mobile-page-active');
            }
        }

        // Side menu page switching
        document.addEventListener('DOMContentLoaded', async function() {
            const menuItems = document.querySelectorAll('.menu-item[data-page]');
            const pageContents = document.querySelectorAll('.page-content');

            // Server-side validated access flags (cannot be bypassed via inspect element)
            const discordLinked = {{ 'true' if discord_linked else 'false' }};
            let hasGuilds = false; // Will be set true after guilds load async
            const hasTeam = {{ 'true' if has_team else 'false' }};
            const isTeamOwner = {{ 'true' if is_team_owner else 'false' }};
            const currentDiscordAccountId = {{ primary_account.id if primary_account else 'null' }};

            // Function to update hasGuilds and UI when guilds are loaded
            window.updateHasGuilds = function(guildsLoaded) {
                hasGuilds = guildsLoaded;
            };

            // Check for suspended/deleted accounts detected during page load
            const suspendedAccounts = {{ suspended_accounts | tojson | safe }};
            if (suspendedAccounts && suspendedAccounts.length > 0) {
                // Show popup for each suspended account
                for (const account of suspendedAccounts) {
                    await showSuspendedAccountPopup(account);
                }
            }

            // Profile section click handler for account switching
            const profileSection = document.querySelector('.profile-section');
            if (profileSection) {
                profileSection.addEventListener('click', async function() {
                    // Fetch fresh linked accounts data for real-time updates
                    let linkedAccounts = [];
                    try {
                        const response = await fetch('/api/linked-accounts/current');
                        const data = await response.json();
                        if (data.success) {
                            linkedAccounts = data.accounts;
                        }
                    } catch (error) {
                        console.error('Error fetching linked accounts:', error);
                        // Fallback to server-rendered data
                        linkedAccounts = {{ linked_accounts | tojson | safe }};
                    }

                    const linkedAccountsCount = linkedAccounts ? linkedAccounts.length : 0;

                    if (linkedAccountsCount === 0) {
                        // Show same popup as when no Discord account linked
                        const shouldLinkAccount = await customConfirm(
                            'Link a Discord account',
                            'In order to use all dashboard features you need a linked Discord account.',
                            'Link an account'
                        );

                        if (shouldLinkAccount) {
                            openSettings();
                            setTimeout(() => {
                                const discordAccountsBtn = document.querySelector('[data-settings-page="discord-accounts"]');
                                if (discordAccountsBtn) {
                                    discordAccountsBtn.click();
                                }
                            }, 100);
                        }
                    } else if (linkedAccountsCount === 1) {
                        // Show "No other accounts" popup
                        const shouldAddAccount = await customConfirm(
                            'No other accounts',
                            'In order to switch your Discord account in the dashboard you must first add more than 1 total Discord accounts in settings.',
                            'Add'
                        );

                        if (shouldAddAccount) {
                            openSettings();
                            setTimeout(() => {
                                const discordAccountsBtn = document.querySelector('[data-settings-page="discord-accounts"]');
                                if (discordAccountsBtn) {
                                    discordAccountsBtn.click();
                                }
                            }, 100);
                        }
                    } else {
                        // Show account switcher popup (2+ accounts)
                        showAccountSwitcher(linkedAccounts);
                    }
                });
            }

            // Show popup on page load if user has no Discord account linked
            if (!discordLinked) {
                // Show confirm dialog with custom button text
                const shouldLinkAccount = await customConfirm(
                    'Link a Discord account',
                    'In order to use all dashboard features you need a linked Discord account.',
                    'Link an account'
                );

                // Only redirect to Discord settings if user clicked the button (not X or outside)
                if (shouldLinkAccount) {
                    // Open settings popup and navigate to Discord accounts page
                    openSettings();
                    setTimeout(() => {
                        const discordAccountsBtn = document.querySelector('[data-settings-page="discord-accounts"]');
                        if (discordAccountsBtn) {
                            discordAccountsBtn.click();
                        }
                    }, 100);
                }
                // Continue to set up menu handlers even if no Discord account linked
            }
            // Note: hasGuilds check moved to loadGuildsAsync() since guilds load asynchronously

            menuItems.forEach(item => {
                item.addEventListener('click', () => {
                    const targetPage = item.dataset.page;

                    // Prevent clicks on disabled buttons
                    if (item.disabled || item.classList.contains('disabled')) {
                        return;
                    }

                    // Server-side validated access control (cannot bypass with inspect element)
                    if (targetPage === 'personal-panel' && isTeamOwner) {
                        return;
                    }
                    if (targetPage === 'team-panel' && !hasTeam) {
                        return;
                    }
                    if (targetPage === 'team-management' && !isTeamOwner) {
                        return;
                    }

                    // Check if user is banned before accessing panels
                    const isBanned = {{ 'true' if db_user and db_user.banned else 'false' }};
                    if ((targetPage === 'personal-panel' || targetPage === 'team-panel') && isBanned) {
                        showSuspendPopup();
                        // Force back to analytics
                        setTimeout(() => {
                            const analyticsBtn = document.querySelector('[data-page="analytics"]');
                            if (analyticsBtn) analyticsBtn.click();
                        }, 100);
                        return;
                    }

                    // Update active state on menu items
                    menuItems.forEach(mi => mi.classList.remove('active'));
                    item.classList.add('active');

                    // Show/hide pages
                    pageContents.forEach(page => {
                        if (page.id === `page-${targetPage}`) {
                            // Set display to flex and restore appropriate flex-direction
                            page.style.display = 'flex';
                            // Team management and analytics use row layout, panels use column
                            page.style.flexDirection = (targetPage === 'team-management' || targetPage === 'analytics') ? 'row' : 'column';
                        } else {
                            page.style.display = 'none';
                        }
                    });

                    // On mobile, show the page with slide animation
                    if (isDashboardMobile()) {
                        showDashboardMobilePage(targetPage);
                    }

                    // Redraw personal chart when analytics page becomes visible
                    if (targetPage === 'analytics') {
                        setTimeout(() => {
                            // Initialize analytics if not already done
                            if (typeof initPersonalAnalytics === 'function') {
                                initPersonalAnalytics();
                            }
                            if (typeof drawPersonalChart === 'function') {
                                drawPersonalChart();
                            }
                        }, 50);
                    }

                    // Update team send button when team panel becomes visible
                    if (targetPage === 'team-panel') {
                        setTimeout(() => {
                            if (typeof window.teamUpdateSendButton === 'function') {
                                window.teamUpdateSendButton();
                            }
                        }, 50);
                    }
                });
            });
        });

        // Wait for all elements to load before initializing
        document.addEventListener('DOMContentLoaded', function() {
            const serverSidebar = document.getElementById('server-sidebar');
            const channelsList = document.getElementById('channels-list');
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const charCount = document.getElementById('char-count');
            const channelSearch = document.getElementById('channel-search');
            const searchTagsContainer = document.getElementById('search-tags');
            const MESSAGE_LIMIT = 2000; // Character limit for messages
            const currentDiscordAccountId = {{ primary_account.id if primary_account else 'null' }};

            // Shared data - stored in window so team panel can access the same data
            window.guilds = window.guilds || [];
            window.serverChannels = window.serverChannels || {};
            window.channelsLoadingComplete = false;
            window.guildsLoaded = false;

            // Local references for convenience
            const guilds = window.guilds;
            const serverChannels = window.serverChannels;
            let selectedChannels = []; // Personal panel selected channels
            let selectedGuild = null; // Currently selected guild
            let searchTags = []; // Search filter tags
            let searchText = ''; // Search text for selected server mode (live filtering)
            let currentServerColor = 'rgba(21, 216, 188, 0.6)'; // Current server's dominant color
            let isSending = false; // Track if messages are being sent
            let isChecking = false; // Track if checking guilds/channels before send
            let shouldCancelSend = false; // Track if user wants to cancel
            let sendAbortController = null; // AbortController for cancelling fetch requests
            let failedChannels = new Map(); // Track channels that failed to send with failure type
            let viewMode = 'servers'; // 'servers', 'channels', or 'selected'
            let channelsOnlySearchText = ''; // Search filter for channels-only mode
            let channelsOnlySearchTags = []; // Search filter tags for channels-only mode
            let selectedChannelsModeSearchText = ''; // Search filter for selected channels mode
            const maxChannelsPerServer = {{ plan_status.max_channels_per_server if plan_status and plan_status.max_channels_per_server is defined else 2 }}; // -1 = unlimited

            // View mode toggle elements
            const viewModeRadios = document.querySelectorAll('input[name="view-mode"]');
            const serversModeHeader = document.querySelector('.servers-mode-header');
            const channelsOnlyHeader = document.querySelector('.channels-only-header');
            const selectedChannelsModeHeader = document.querySelector('.selected-channels-mode-header');
            const serversModeSections = document.querySelectorAll('.servers-mode-section');
            const channelsOnlySection = document.querySelector('.channels-only-section');
            const selectedChannelsModeSection = document.querySelector('.selected-channels-mode-section');
            const channelsOnlyList = document.getElementById('channels-only-list');
            const selectedChannelsModeList = document.getElementById('selected-channels-mode-list');
            const channelsOnlySearch = document.getElementById('channels-only-search');
            const selectedChannelsModeSearch = document.getElementById('selected-channels-mode-search');
            const channelsOnlySearchTagsContainer = document.getElementById('channels-only-search-tags');

            // View mode toggle handler (radio buttons)
            viewModeRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    const mode = radio.value;
                    if (mode === viewMode) return;

                    viewMode = mode;

                    // Hide all headers and sections first
                    serversModeHeader.style.display = 'none';
                    channelsOnlyHeader.style.display = 'none';
                    selectedChannelsModeHeader.style.display = 'none';
                    serversModeSections.forEach(s => s.style.display = 'none');
                    channelsOnlySection.style.display = 'none';
                    selectedChannelsModeSection.style.display = 'none';

                    // Show the appropriate mode
                    if (mode === 'servers') {
                        serversModeHeader.style.display = '';
                        serversModeSections.forEach(s => s.style.display = '');
                    } else if (mode === 'channels') {
                        channelsOnlyHeader.style.display = '';
                        channelsOnlySection.style.display = 'flex';
                        // Show loading dots immediately, then render asynchronously
                        channelsOnlyList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';
                        requestAnimationFrame(() => {
                            setTimeout(() => renderChannelsOnlyMode(), 0);
                        });
                    } else if (mode === 'selected') {
                        selectedChannelsModeHeader.style.display = '';
                        selectedChannelsModeSection.style.display = 'flex';
                        // Show loading dots immediately, then render asynchronously
                        selectedChannelsModeList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';
                        requestAnimationFrame(() => {
                            setTimeout(() => renderSelectedChannelsMode(), 0);
                        });
                    }
                });
            });

            // Selected channels mode search handler
            if (selectedChannelsModeSearch) {
                selectedChannelsModeSearch.addEventListener('input', (e) => {
                    selectedChannelsModeSearchText = e.target.value.toLowerCase();
                    renderSelectedChannelsMode();
                });
            }

            // Render channels in selected channels mode (with event delegation)
            function renderSelectedChannelsMode() {
                if (!selectedChannelsModeList) return;

                if (selectedChannels.length === 0) {
                    selectedChannelsModeList.innerHTML = '<div class="no-selection">No channels selected</div>';
                    return;
                }

                // Filter by search text (channel name only, consistent with other modes)
                let filteredChannels = selectedChannels;
                if (selectedChannelsModeSearchText) {
                    filteredChannels = selectedChannels.filter(ch =>
                        ch.name.toLowerCase().includes(selectedChannelsModeSearchText)
                    );
                }

                if (filteredChannels.length === 0) {
                    selectedChannelsModeList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                selectedChannelsModeList.innerHTML = filteredChannels.map(channel => {
                    const iconUrl = channel.guildIcon
                        ? `https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png`
                        : null;
                    const serverIconHtml = iconUrl
                        ? `<img class="server-icon-small" src="${iconUrl}" alt="">`
                        : `<div class="server-icon-placeholder-small">${channel.guildName[0].toUpperCase()}</div>`;
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    const failedInfo = failedChannels.get(channelKey);
                    const isFailed = !!failedInfo;
                    const failedClass = isFailed ? ' failed' : '';
                    const statusText = failedInfo?.type === 'ratelimit' ? 'Rate limited' : 'Missing permission';
                    const statusTagHtml = isFailed ? `<span class="channel-status-tag">${statusText}</span>` : '';
                    return `<div class="channel-item selected${failedClass}" data-channel-id="${channel.id}" data-channel-name="${channel.name}" data-guild-id="${channel.guildId}" data-guild-name="${channel.guildName}" data-guild-icon="${channel.guildIcon || ''}">${serverIconHtml}<span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right">${statusTagHtml}<img class="channel-tick" src="{{ url_for('static', filename='x.png') }}" alt="x"></div></div>`;
                }).join('');
            }

            // Event delegation for selected channels mode clicks (remove channel)
            if (selectedChannelsModeList) {
                selectedChannelsModeList.addEventListener('click', (e) => {
                    const item = e.target.closest('.channel-item');
                    if (!item) return;

                    const channelId = item.dataset.channelId;
                    const guildId = item.dataset.guildId;

                    // Remove from selected channels
                    selectedChannels = selectedChannels.filter(ch =>
                        !(ch.id === channelId && ch.guildId === guildId)
                    );

                    saveSelectedChannels();
                    saveUserDataToDB();
                    renderSelectedChannelsMode();
                    updateServerCount(guildId);
                    updateSendButton();

                    // Also update other views if they exist
                    if (selectedGuild && selectedGuild.id === guildId) {
                        renderChannels();
                    }
                });
            }

            // Channels-only search handler
            if (channelsOnlySearch) {
                channelsOnlySearch.addEventListener('input', (e) => {
                    channelsOnlySearchText = e.target.value.toLowerCase();
                    renderChannelsOnlyMode();
                });
                channelsOnlySearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && channelsOnlySearch.value.trim()) {
                        addChannelsOnlySearchTag(channelsOnlySearch.value);
                    }
                });
            }

            // Add search tag for channels-only mode
            function addChannelsOnlySearchTag(text) {
                if (channelsOnlySearchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                const trimmedText = text.trim().toLowerCase();
                if (trimmedText.length > 10) {
                    showTagCharLimitModal();
                    return;
                }
                if (!channelsOnlySearchTags.includes(trimmedText) && trimmedText) {
                    channelsOnlySearchTags.push(trimmedText);
                    updateChannelsOnlySearchTagsDisplay();
                    channelsOnlySearch.value = '';
                    channelsOnlySearchText = '';
                    renderChannelsOnlyMode();
                }
            }

            // Remove search tag for channels-only mode
            function removeChannelsOnlySearchTag(tag) {
                channelsOnlySearchTags = channelsOnlySearchTags.filter(t => t !== tag);
                updateChannelsOnlySearchTagsDisplay();
                renderChannelsOnlyMode();
            }

            // Update search tags display for channels-only mode
            function updateChannelsOnlySearchTagsDisplay() {
                if (!channelsOnlySearchTagsContainer) return;
                channelsOnlySearchTagsContainer.innerHTML = '';
                channelsOnlySearchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}"></span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        removeChannelsOnlySearchTag(tag);
                    });
                    channelsOnlySearchTagsContainer.appendChild(tagEl);
                });
            }

            // Render channels in channels-only mode (with event delegation)
            function renderChannelsOnlyMode() {
                if (!channelsOnlyList) return;

                // Collect all channels from all servers
                let allChannels = [];
                for (const guild of guilds) {
                    const channels = serverChannels[guild.id] || [];
                    for (const channel of channels) {
                        allChannels.push({
                            ...channel,
                            guildId: guild.id,
                            guildName: guild.name,
                            guildIcon: guild.icon
                        });
                    }
                }

                // Filter by search tags (OR logic - any tag matches channel name only)
                if (channelsOnlySearchTags.length > 0) {
                    allChannels = allChannels.filter(ch =>
                        channelsOnlySearchTags.some(tag => ch.name.toLowerCase().includes(tag))
                    );
                }

                // Filter by search text (channel name only, same as Selected server mode)
                if (channelsOnlySearchText) {
                    allChannels = allChannels.filter(ch =>
                        ch.name.toLowerCase().includes(channelsOnlySearchText)
                    );
                }

                if (allChannels.length === 0) {
                    if (!window.channelsLoadingComplete) {
                        channelsOnlyList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';
                    } else if (channelsOnlySearchText || channelsOnlySearchTags.length > 0) {
                        channelsOnlyList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    } else {
                        channelsOnlyList.innerHTML = '<div class="no-selection">No channels found</div>';
                    }
                    return;
                }

                channelsOnlyList.innerHTML = allChannels.map(channel => renderChannelItemHtml(channel, selectedChannels)).join('');
            }

            // Helper function to render a single channel item HTML (shared via window)
            window.renderChannelItemHtml = function(channel, selectedList) {
                const isSelected = selectedList.some(ch => ch.id === channel.id);
                const iconUrl = channel.guildIcon
                    ? `https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png`
                    : null;
                const serverIconHtml = iconUrl
                    ? `<img class="server-icon-small" src="${iconUrl}" alt="">`
                    : `<div class="server-icon-placeholder-small">${channel.guildName[0].toUpperCase()}</div>`;
                return `<div class="channel-item ${isSelected ? 'selected' : ''}" data-channel-id="${channel.id}" data-channel-name="${channel.name}" data-guild-id="${channel.guildId}" data-guild-name="${channel.guildName}" data-guild-icon="${channel.guildIcon || ''}">${serverIconHtml}<span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right"><img class="channel-tick" src="{{ url_for('static', filename='tick.png') }}" alt=""></div></div>`;
            };
            const renderChannelItemHtml = window.renderChannelItemHtml;

            // Event delegation for channels-only list clicks (much faster than individual handlers)
            if (channelsOnlyList) {
                channelsOnlyList.addEventListener('click', (e) => {
                    const item = e.target.closest('.channel-item');
                    if (!item) return;

                    const channelId = item.dataset.channelId;
                    const channelName = item.dataset.channelName;
                    const guildId = item.dataset.guildId;
                    const guildName = item.dataset.guildName;
                    const guildIcon = item.dataset.guildIcon;

                    toggleChannelSelection({
                        id: channelId,
                        name: channelName,
                        guildId: guildId,
                        guildName: guildName,
                        guildIcon: guildIcon
                    });

                    const isNowSelected = selectedChannels.some(ch => ch.id === channelId);
                    if (isNowSelected) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });
            }

            // Check session on API error
            async function handleSessionError(response) {
                if (response.status === 401) {
                    // Session expired or token invalid - redirect to settings
                    window.location.href = '/settings';
                }
                return false;
            }

            // Warn user before leaving if messages are being sent
            window.addEventListener('beforeunload', (e) => {
                if (isSending) {
                    e.preventDefault();
                    e.returnValue = '';
                    return '';
                }
            });

            // Menu item navigation (skip if disabled)
            const menuItems = document.querySelectorAll('.menu-item');
            menuItems.forEach(item => {
                item.addEventListener('click', function() {
                    // Skip if button is disabled
                    if (this.disabled || this.classList.contains('disabled')) {
                        return;
                    }
                    menuItems.forEach(i => i.classList.remove('active'));
                    this.classList.add('active');
                });
            });

            // Load saved data from localStorage (persists across sessions)
            // Uses per-account storage key when account ID is available
            function loadSelectedChannels() {
                // Use account-specific key if we have an account ID
                const storageKey = currentDiscordAccountId
                    ? `selectedChannels_${currentDiscordAccountId}`
                    : 'selectedChannels';
                const saved = localStorage.getItem(storageKey);
                if (saved) {
                    try {
                        selectedChannels = JSON.parse(saved);
                        // Update send button state after loading channels
                        updateSendButton();
                    } catch (e) {
                        console.error('Error loading saved channels:', e);
                        selectedChannels = [];
                    }
                }
            }

            function loadMessageText() {
                const saved = localStorage.getItem('messageText');
                if (saved && messageInput) {
                    messageInput.value = saved;
                    updateCharCount();
                    // Update send button state after loading message
                    updateSendButton();
                }
            }

            // Load user data from database
            async function loadUserDataFromDB() {
                try {
                    // Include discord_account_id to get per-account selected channels
                    const url = currentDiscordAccountId
                        ? `/api/get-user-data?discord_account_id=${currentDiscordAccountId}`
                        : '/api/get-user-data';
                    const response = await fetch(url);
                    if (response.ok) {
                        const result = await response.json();
                        const data = result.data || result;

                        // Load selected channels for this Discord account (always use DB data, clear if empty)
                        if (data.selected_channels && Array.isArray(data.selected_channels)) {
                            selectedChannels = data.selected_channels;
                        } else {
                            // No channels saved for this account - start fresh
                            selectedChannels = [];
                        }
                        // Use account-specific localStorage key
                        const storageKey = currentDiscordAccountId
                            ? `selectedChannels_${currentDiscordAccountId}`
                            : 'selectedChannels';
                        localStorage.setItem(storageKey, JSON.stringify(selectedChannels));

                        // Load business selected channels if available
                        if (data.business_selected_channels && Array.isArray(data.business_selected_channels)) {
                            teamSelectedChannels = data.business_selected_channels;
                            localStorage.setItem('teamSelectedChannels', JSON.stringify(teamSelectedChannels));
                        }

                        // Load draft message if available
                        if (data.draft_message !== null && data.draft_message !== undefined && messageInput) {
                            messageInput.value = data.draft_message;
                            localStorage.setItem('messageText', data.draft_message);
                            updateCharCount();
                        }

                        // Update send button state after loading data
                        updateSendButton();

                        return true;
                    } else {
                        console.warn('Failed to load user data from database, using localStorage fallback');
                        return false;
                    }
                } catch (error) {
                    console.error('Error loading user data from database:', error);
                    return false;
                }
            }

            // Save user data to database
            async function saveUserDataToDB() {
                try {
                    const payload = {
                        selected_channels: selectedChannels,
                        draft_message: messageInput ? messageInput.value : ''
                    };

                    // Include discord_account_id to save channels per-account
                    if (currentDiscordAccountId) {
                        payload.discord_account_id = currentDiscordAccountId;
                    }

                    const response = await fetch('/api/save-user-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-Token': '{{ csrf_token }}'
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        console.warn('Failed to save user data to database');
                        return false;
                    }

                    return true;
                } catch (error) {
                    console.error('Error saving user data to database:', error);
                    return false;
                }
            }

            // Save data to localStorage (persists across sessions)
            // Uses per-account storage key when account ID is available
            function saveSelectedChannels() {
                // Use account-specific key if we have an account ID
                const storageKey = currentDiscordAccountId
                    ? `selectedChannels_${currentDiscordAccountId}`
                    : 'selectedChannels';
                localStorage.setItem(storageKey, JSON.stringify(selectedChannels));
                // Also save to database
                saveUserDataToDB();
            }

            function saveMessageText() {
                if (messageInput) {
                    localStorage.setItem('messageText', messageInput.value);
                    // Also save to database
                    saveUserDataToDB();
                }
            }

            // Add search tag
            function addSearchTag(text) {
                if (searchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                const trimmedText = text.trim().toLowerCase();
                if (trimmedText.length > 10) {
                    showTagCharLimitModal();
                    return;
                }
                if (!searchTags.includes(trimmedText) && trimmedText) {
                    searchTags.push(trimmedText);
                    updateSearchTagsDisplay();
                    channelSearch.value = '';
                    searchText = '';
                    if (selectedGuild) {
                        renderChannels();
                    }
                }
            }

            // Remove search tag
            function removeSearchTag(tag) {
                searchTags = searchTags.filter(t => t !== tag);
                updateSearchTagsDisplay();
                if (selectedGuild) {
                    renderChannels();
                }
            }

            // Update search tags display
            function updateSearchTagsDisplay() {
                searchTagsContainer.innerHTML = '';
                searchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}"></span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        removeSearchTag(tag);
                    });
                    searchTagsContainer.appendChild(tagEl);
                });
            }

            // Handle channel search input
            if (channelSearch) {
                channelSearch.addEventListener('input', (e) => {
                    searchText = e.target.value.toLowerCase();
                    renderChannels();
                });
                channelSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && channelSearch.value.trim()) {
                        addSearchTag(channelSearch.value);
                    }
                });
            }

            // Render Discord-style server sidebar icons
            function renderServers() {
                if (!serverSidebar) return;

                serverSidebar.innerHTML = '';

                if (!guilds || guilds.length === 0) {
                    return;
                }

                guilds.forEach(guild => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'server-icon-wrapper';
                    wrapper.dataset.guildId = guild.id;
                    wrapper.title = guild.name;

                    const iconHtml = guild.icon
                        ? `<img src="https://cdn.discordapp.com/icons/${guild.id}/${guild.icon}.png?size=96" alt="${guild.name}">`
                        : `<span class="server-icon-placeholder">${guild.name.charAt(0).toUpperCase()}</span>`;

                    wrapper.innerHTML = `
                        <div class="server-icon-pill"></div>
                        <div class="server-icon-holder">
                            ${iconHtml}
                        </div>
                    `;

                    wrapper.addEventListener('click', () => selectServer(guild));
                    serverSidebar.appendChild(wrapper);

                    // Restore active state if this is the selected guild
                    if (selectedGuild && selectedGuild.id === guild.id) {
                        wrapper.classList.add('active');
                    }
                });
            }

            // Abort controller for channel preloading
            let channelLoadAbortController = null;

            // Preload all channels for all guilds (shared data in window.serverChannels)
            async function preloadAllChannels() {
                // Abort any previous loading
                if (channelLoadAbortController) {
                    channelLoadAbortController.abort();
                }
                channelLoadAbortController = new AbortController();
                const signal = channelLoadAbortController.signal;

                const failedGuilds = [];

                // First pass: load all in parallel (fast)
                const promises = guilds.map(async (guild) => {
                    if (serverChannels[guild.id] !== undefined) return;
                    if (signal.aborted) return;

                    try {
                        const response = await fetch(`/api/guild/${guild.id}/channels`, { signal });

                        if (signal.aborted) return;

                        // Track rate limited for retry
                        if (response.status === 429) {
                            failedGuilds.push(guild);
                            return;
                        }

                        // Handle other errors - don't retry, just set empty
                        if (!response.ok) {
                            serverChannels[guild.id] = [];
                            return;
                        }

                        const data = await response.json();

                        if (signal.aborted) return;

                        if (data.token_invalid) {
                            serverChannels[guild.id] = [];
                            return;
                        }

                        if (data.channels) {
                            serverChannels[guild.id] = data.channels.sort((a, b) => a.position - b.position);
                        } else {
                            serverChannels[guild.id] = [];
                        }

                        // Update view progressively
                        if (viewMode === 'channels') {
                            renderChannelsOnlyMode();
                        } else if (viewMode === 'servers' && selectedGuild && selectedGuild.id === guild.id) {
                            renderChannels();
                        }
                    } catch (error) {
                        if (error.name === 'AbortError') return;
                        console.error(`Error loading channels for ${guild.name}:`, error);
                        serverChannels[guild.id] = []; // Set empty instead of retrying
                    }
                });

                await Promise.all(promises);

                if (signal.aborted) return;

                // Retry failed guilds one by one with delay
                for (const guild of failedGuilds) {
                    if (signal.aborted) return;
                    await new Promise(r => setTimeout(r, 1000));
                    if (signal.aborted) return;

                    try {
                        const response = await fetch(`/api/guild/${guild.id}/channels`, { signal });
                        if (signal.aborted) return;

                        const data = await response.json();

                        if (data.channels) {
                            serverChannels[guild.id] = data.channels.sort((a, b) => a.position - b.position);
                        } else {
                            serverChannels[guild.id] = [];
                        }

                        if (viewMode === 'channels') {
                            renderChannelsOnlyMode();
                        } else if (viewMode === 'servers' && selectedGuild && selectedGuild.id === guild.id) {
                            renderChannels();
                        }
                    } catch (error) {
                        if (error.name === 'AbortError') return;
                        serverChannels[guild.id] = [];
                    }
                }

                if (signal.aborted) return;

                // Mark loading as complete
                window.channelsLoadingComplete = true;
                if (viewMode === 'channels') {
                    renderChannelsOnlyMode();
                }
                // Also update team panel if it's showing channels
                if (typeof window.teamRenderChannelsOnlyMode === 'function') {
                    window.teamRenderChannelsOnlyMode();
                }
            }

            // Fetch all guilds and build UI
            async function initializeUI() {
                // Load from localStorage first (instant)
                loadSelectedChannels();
                loadMessageText();

                // Then load from database (syncs across devices)
                await loadUserDataFromDB();

                // Update selected display with cached data
                updateSelectedDisplay();
                updateSendButton();
                updateCharCount();

                // Hide loading and show content for personal message box immediately
                const personalMsgLoadingEl = document.getElementById('personal-message-loading');
                const personalMsgContentEl = document.getElementById('personal-message-content');
                if (personalMsgLoadingEl) personalMsgLoadingEl.style.display = 'none';
                if (personalMsgContentEl) {
                    personalMsgContentEl.style.opacity = '1';
                    personalMsgContentEl.style.pointerEvents = 'auto';
                }

                // Load guilds asynchronously (doesn't block page load)
                loadGuildsAsync();
            }

            async function loadGuildsAsync() {
                // If already loaded, skip
                if (window.guildsLoaded) return;

                try {
                    const response = await fetch('/api/guilds');

                    // Handle server errors
                    if (!response.ok) {
                        let data = {};
                        try {
                            data = await response.json();
                        } catch (e) {
                            // JSON parse failed
                        }

                        // Check for token invalid
                        if (data.token_invalid) {
                            showTokenUpdatePopup(data.account_info, (success) => {
                                if (success) window.location.reload();
                            });
                            return;
                        }

                        // Check for suspended
                        if (data.suspended) {
                            await showSuspendedAccountPopup(data.account_info);
                            window.location.reload();
                            return;
                        }

                        console.error('Failed to load guilds:', response.status, data);
                        return;
                    }

                    const data = await response.json();

                    // Check for token invalid (can also come with 200 status in some cases)
                    if (data.token_invalid) {
                        showTokenUpdatePopup(data.account_info, (success) => {
                            if (success) window.location.reload();
                        });
                        return;
                    }

                    // Check for suspended account
                    if (data.suspended) {
                        await showSuspendedAccountPopup(data.account_info);
                        window.location.reload();
                        return;
                    }

                    if (data.success) {
                        // Abort any ongoing channel loading
                        if (channelLoadAbortController) {
                            channelLoadAbortController.abort();
                            channelLoadAbortController = null;
                        }

                        // Clear shared data for fresh load
                        guilds.length = 0;
                        (data.guilds || []).forEach(g => guilds.push(g));
                        // Clear channel cache (new guilds = new channels)
                        Object.keys(serverChannels).forEach(key => delete serverChannels[key]);
                        window.channelsLoadingComplete = false;
                        window.guildsLoaded = true;

                        // Update global hasGuilds flag
                        if (window.updateHasGuilds) {
                            window.updateHasGuilds(guilds.length > 0);
                        }

                        // Show "no servers" popup if user has Discord linked but no servers
                        if (guilds.length === 0 && !data.no_account && !data.no_token) {
                            await customAlert(
                                "You're not in any servers",
                                'To send messages join a server/guild'
                            );
                        }

                        // Remove selected channels from servers that no longer exist
                        const guildIds = new Set(guilds.map(g => g.id));
                        const originalLength = selectedChannels.length;
                        selectedChannels = selectedChannels.filter(ch => guildIds.has(ch.guildId));
                        if (selectedChannels.length !== originalLength) {
                            saveSelectedChannels();
                            saveUserDataToDB();
                        }

                        // Render personal panel
                        renderServers();
                        updateSelectedDisplay();
                        updateSendButton();

                        // Preload channels in background
                        preloadAllChannels().catch(err => console.error('Error preloading channels:', err));
                    }
                } catch (error) {
                    console.error('Error loading guilds:', error);
                }
            }

            // Extract dominant color from image
            function getDominantColor(imageUrl, callback) {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    let r = 0, g = 0, b = 0, count = 0;

                    // Sample every 10th pixel for performance
                    for (let i = 0; i < data.length; i += 40) {
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        count++;
                    }

                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    callback(`rgb(${r}, ${g}, ${b})`);
                };
                img.onerror = function() {
                    callback('rgba(21, 216, 188, 0.6)'); // Fallback to default turquoise
                };
                img.src = imageUrl;
            }

            // Select a server and load its channels
            async function selectServer(guild) {
                // Set selected guild immediately
                selectedGuild = guild;
                const guildId = guild.id;

                // Update active state in server sidebar (only personal panel, not team panel)
                document.querySelectorAll('#server-sidebar .server-icon-wrapper').forEach(item => {
                    item.classList.remove('active');
                });

                const activeItem = serverSidebar.querySelector(`[data-guild-id="${guildId}"]`);
                if (activeItem) {
                    activeItem.classList.add('active');
                }

                // Apply dominant color from server icon
                if (guild.icon) {
                    const iconUrl = `https://cdn.discordapp.com/icons/${guildId}/${guild.icon}.png`;
                    getDominantColor(iconUrl, (color) => {
                        // Only update if this guild is still selected
                        if (selectedGuild && selectedGuild.id === guildId) {
                            currentServerColor = color;
                        }
                    });
                } else {
                    // Use default color for servers without icons
                    currentServerColor = 'rgba(21, 216, 188, 0.6)';
                }

                // Load channels if not cached
                if (!serverChannels[guildId]) {
                    channelsList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';

                    try {
                        const response = await fetch(`/api/guild/${guildId}/channels`);

                        // Check if this guild is still selected
                        if (!selectedGuild || selectedGuild.id !== guildId) {
                            return;
                        }

                        const data = await response.json();

                        // Check for token_invalid error - show token update popup
                        if (data.token_invalid && data.account_info) {
                            channelsList.innerHTML = '<div class="no-selection">Token expired - please update</div>';
                            showTokenUpdatePopup(data.account_info, (success) => {
                                if (success) {
                                    // Token updated, reload the page to refresh everything
                                    window.location.reload();
                                } else {
                                    // User closed without updating, unlink the account
                                    fetch(`/api/linked-accounts/${data.account_info.account_id}/unlink`, {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'X-CSRF-Token': window.csrfToken || '{{ csrf_token }}'
                                        }
                                    }).then(() => {
                                        window.location.reload();
                                    });
                                }
                            });
                            return;
                        }

                        if (!response.ok) {
                            await handleSessionError(response);
                            return;
                        }

                        if (data.channels) {
                            serverChannels[guildId] = data.channels.filter(ch => ch.type === 0).sort((a, b) => a.position - b.position);
                        } else {
                            serverChannels[guildId] = [];
                        }
                    } catch (error) {
                        console.error(`Error fetching channels:`, error);
                        serverChannels[guildId] = [];
                    }
                }

                // Only render if this guild is still selected
                if (selectedGuild && selectedGuild.id === guildId) {
                    renderChannels();
                }

                // Also update channels-only mode if active
                if (viewMode === 'channels') {
                    renderChannelsOnlyMode();
                }
            }

            // Render channels for selected server (with event delegation)
            function renderChannels() {
                if (!selectedGuild) {
                    channelsList.innerHTML = '<div class="no-selection">Select a server to view channels</div>';
                    return;
                }

                const currentGuildId = selectedGuild.id;
                const channels = serverChannels[selectedGuild.id] || [];

                if (channels.length === 0) {
                    channelsList.innerHTML = '<div class="no-selection">No channels found</div>';
                    return;
                }

                // Filter channels by search tags (OR logic - any tag matches)
                let filteredChannels = channels;
                if (searchTags.length > 0) {
                    filteredChannels = channels.filter(channel =>
                        searchTags.some(tag => channel.name.toLowerCase().includes(tag))
                    );
                }

                // Filter by search text (live filtering as you type)
                if (searchText) {
                    filteredChannels = filteredChannels.filter(channel =>
                        channel.name.toLowerCase().includes(searchText)
                    );
                }

                if (filteredChannels.length === 0) {
                    channelsList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                channelsList.innerHTML = filteredChannels.map(channel => {
                    const isSelected = selectedChannels.some(ch => ch.id === channel.id && ch.guildId === currentGuildId);
                    return `<div class="channel-item ${isSelected ? 'selected' : ''}" data-channel-id="${channel.id}" data-channel-name="${channel.name}"><span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right"><img class="channel-tick" src="{{ url_for('static', filename='tick.png') }}" alt=""></div></div>`;
                }).join('');
            }

            // Event delegation for server channels list clicks
            if (channelsList) {
                channelsList.addEventListener('click', (e) => {
                    const item = e.target.closest('.channel-item');
                    if (!item || !selectedGuild) return;

                    const channelId = item.dataset.channelId;
                    const channelName = item.dataset.channelName;
                    const channels = serverChannels[selectedGuild.id] || [];
                    const channel = channels.find(ch => ch.id === channelId);
                    if (!channel) return;

                    const currentlySelected = selectedChannels.some(ch =>
                        ch.id === channel.id && ch.guildId === selectedGuild.id
                    );
                    toggleChannel(channel, !currentlySelected);
                });
            }

            // Toggle channel selection for channels-only mode
            function toggleChannelSelection(channel) {
                const isCurrentlySelected = selectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === channel.guildId
                );

                if (!isCurrentlySelected) {
                    // Check channel limit per server (-1 means unlimited)
                    if (maxChannelsPerServer !== -1) {
                        const currentServerChannelCount = selectedChannels.filter(ch =>
                            ch.guildId === channel.guildId
                        ).length;

                        if (currentServerChannelCount >= maxChannelsPerServer) {
                            showChannelLimitModal(maxChannelsPerServer);
                            return;
                        }
                    }

                    selectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: channel.guildId,
                        guildName: channel.guildName,
                        guildIcon: channel.guildIcon || null
                    });
                    // Clear any failed status when re-selecting
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    failedChannels.delete(channelKey);
                } else {
                    selectedChannels = selectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === channel.guildId)
                    );
                }

                // Save to localStorage and database
                saveSelectedChannels();
                saveUserDataToDB();

                // Update UI
                updateServerCount(channel.guildId);
                updateSelectedDisplay();
                updateSendButton();
            }

            // Toggle channel selection
            function toggleChannel(channel, isChecked) {
                if (!selectedGuild) return;

                const isCurrentlySelected = selectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === selectedGuild.id
                );

                if (isChecked && !isCurrentlySelected) {
                    // Check channel limit per server (-1 means unlimited)
                    if (maxChannelsPerServer !== -1) {
                        const currentServerChannelCount = selectedChannels.filter(ch =>
                            ch.guildId === selectedGuild.id
                        ).length;

                        if (currentServerChannelCount >= maxChannelsPerServer) {
                            showChannelLimitModal(maxChannelsPerServer);
                            return;
                        }
                    }

                    selectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: selectedGuild.id,
                        guildName: selectedGuild.name,
                        guildIcon: selectedGuild.icon || null
                    });
                    // Clear any failed status when re-selecting
                    const channelKey = `${selectedGuild.id}-${channel.id}`;
                    failedChannels.delete(channelKey);
                } else if (!isChecked && isCurrentlySelected) {
                    selectedChannels = selectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === selectedGuild.id)
                    );
                }

                // Save to localStorage and database
                saveSelectedChannels();
                saveUserDataToDB();

                // Update UI
                renderChannels();
                updateServerCount(selectedGuild.id);
                updateSelectedDisplay();
                updateSendButton();
            }

            // Update count badge on server
            function updateServerCount(guildId) {
                const count = selectedChannels.filter(ch => ch.guildId === guildId).length;
                const serverItem = document.querySelector(`[data-guild-id="${guildId}"]`);
                if (serverItem) {
                    const countEl = serverItem.querySelector('.server-count');
                    if (countEl) {
                        if (count > 0) {
                            countEl.textContent = `${count} selected`;
                            countEl.style.display = 'block';
                            serverItem.classList.add('has-selection');
                        } else {
                            countEl.style.display = 'none';
                            serverItem.classList.remove('has-selection');
                        }
                    }
                }
            }

            // Update only a specific channel's failed status - only refreshes Selected channels view
            function updateFailedChannelStatus(channel) {
                // Failed status only shows in Selected channels mode
                if (viewMode === 'selected') {
                    renderSelectedChannelsMode();
                }
            }

            // Update selected channels display (now just updates the selected channels mode view)
            function updateSelectedDisplay() {
                // Update selected channels mode view if it's active
                if (viewMode === 'selected') {
                    renderSelectedChannelsMode();
                }
                // Also update channels-only mode to reflect selection changes
                if (viewMode === 'channels') {
                    renderChannelsOnlyMode();
                }
            }

            // Update send button state
            function updateSendButton() {
                if (sendBtn && messageInput) {
                    const isOverLimit = messageInput.value.length > MESSAGE_LIMIT;
                    sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim() || isOverLimit;
                }
            }

            // Update character count display
            function updateCharCount() {
                if (charCount && messageInput) {
                    const remaining = MESSAGE_LIMIT - messageInput.value.length;
                    charCount.textContent = remaining;

                    // Apply red color when negative (over limit)
                    if (remaining < 0) {
                        charCount.style.color = '#991a35'; // Red from delete account button gradient
                    } else {
                        charCount.style.color = '#81828A'; // Default grey
                    }
                }
            }

            // Message input listener
            if (messageInput) {
                messageInput.addEventListener('input', function() {
                    updateCharCount();
                    saveMessageText();
                    updateSendButton();
                });
            }

            // Emoji button is just an icon - no picker functionality

            // Send button handler - uses AsyncButton for double-click prevention
            if (sendBtn) {
                sendBtn.addEventListener('click', async function() {
                    // If cancelled during checking, allow user to continue
                    if (shouldCancelSend && isChecking) {
                        const continueConfirmed = await customConfirm('Continue', 'You have cancelled this operation, would you like for it to continue?', 'Yes');
                        if (continueConfirmed) {
                            shouldCancelSend = false;
                            sendBtn.innerHTML = '<span id="send-progress">Checking</span>';
                        }
                        return;
                    }

                    // If already cancelling during send, ignore further clicks
                    if (shouldCancelSend) {
                        return;
                    }

                    // If currently checking, handle cancel (checking continues but send will be skipped)
                    if (isChecking) {
                        const cancelConfirmed = await customConfirm('Message sending', 'Are you sure you would like to cancel? This will stop any further actions.', 'Yes');
                        if (cancelConfirmed) {
                            shouldCancelSend = true;
                            sendBtn.innerHTML = '<span id="send-progress">Checking (messages wont send)</span>';
                        }
                        return;
                    }

                    // If currently sending, cancel instantly
                    if (isSending) {
                        const cancelConfirmed = await customConfirm('Message sending', 'Are you sure you would like to cancel? This will stop any further actions.', 'Yes');
                        if (cancelConfirmed) {
                            shouldCancelSend = true;
                        }
                        return;
                    }

                    // Prevent double-clicks during initial processing (before isSending/isChecking are set)
                    if (AsyncButton.isProcessing('personal_send')) {
                        return;
                    }

                    if (selectedChannels.length > 0 && messageInput && messageInput.value.trim()) {
                        // Mark operation as started to prevent duplicate clicks
                        AsyncButton.startOperation('personal_send');

                        // Check for filtered content before proceeding
                        const message = messageInput.value.trim();
                        const filteredWords = {{ BLACKLISTED_WORDS|tojson }};
                        const phraseExceptions = {{ PHRASE_EXCEPTIONS|tojson }};

                        // Function to check if a word occurrence is within an exception phrase
                        function isWordInException(word, messageLower) {
                            const wordLower = word.toLowerCase();
                            const exceptions = phraseExceptions[wordLower] || [];

                            if (exceptions.length === 0) return false;

                            // Find all occurrences of the blacklisted word
                            let startIndex = 0;
                            while (true) {
                                const pos = messageLower.indexOf(wordLower, startIndex);
                                if (pos === -1) break;

                                const wordEnd = pos + wordLower.length;
                                let isException = false;

                                // Check if this occurrence is within any exception phrase
                                for (const exception of exceptions) {
                                    const excLower = exception.toLowerCase();
                                    const excPos = messageLower.indexOf(excLower);
                                    if (excPos !== -1 && excPos <= pos && (excPos + excLower.length) >= wordEnd) {
                                        isException = true;
                                        break;
                                    }
                                }

                                // If any occurrence is not an exception, word is blocked
                                if (!isException) return false;

                                startIndex = pos + 1;
                            }

                            return true; // All occurrences are within exceptions
                        }

                        // Check message against blacklist (case-insensitive) - find ALL matches
                        const messageLower = message.toLowerCase();
                        let foundWords = [];

                        for (const word of filteredWords) {
                            if (messageLower.includes(word.toLowerCase())) {
                                // Check if word is part of an exception phrase
                                if (!isWordInException(word, messageLower)) {
                                    foundWords.push(word);
                                }
                            }
                        }

                        if (foundWords.length > 0) {
                            // Flag the user for using banned words
                            try {
                                await fetch('/api/flag-self', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({ words: foundWords })
                                });
                            } catch (e) {
                                console.error('Failed to report flagged content:', e);
                            }

                            await customAlert('Warning', `Your message contains prohibited content:\n ${foundWords.join('\n ')}`);
                            AsyncButton.endOperation('personal_send');
                            return; // Stop execution
                        }

                        // Show confirmation popup
                        const channelCount = selectedChannels.length;
                        const confirmed = await customConfirm('Send Message', `Send message to ${channelCount} channel${channelCount !== 1 ? 's' : ''}?`, 'Send');
                        if (!confirmed) {
                            AsyncButton.endOperation('personal_send');
                            return;
                        }

                        // Reset cancel flag
                        shouldCancelSend = false;

                        // Phase 1: Check and refresh guilds/channels
                        isChecking = true;
                        sendBtn.disabled = false; // Keep enabled for cancel
                        sendBtn.innerHTML = '<span id="send-progress">Checking</span>';

                        try {
                            const refreshResponse = await fetch('/api/refresh-guilds-channels', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRF-Token': '{{ csrf_token }}'
                                }
                            });

                            // Check for cancel
                            if (shouldCancelSend) {
                                isChecking = false;
                                shouldCancelSend = false;
                                sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                sendBtn.innerHTML = 'Send';
                                return;
                            }

                            const refreshData = await refreshResponse.json();

                            if (refreshData.token_invalid && refreshData.account_info) {
                                isChecking = false;
                                sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                sendBtn.innerHTML = 'Send';
                                await showTokenUpdatePopup(refreshData.account_info, () => {
                                    window.location.reload();
                                });
                                return;
                            }

                            if (refreshData.account_suspended && refreshData.account_info) {
                                isChecking = false;
                                sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                sendBtn.innerHTML = 'Send';
                                await showSuspendedAccountPopup(refreshData.account_info);
                                window.location.reload();
                                return;
                            }

                            if (!refreshResponse.ok || !refreshData.guilds) {
                                isChecking = false;
                                sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                sendBtn.innerHTML = 'Send';
                                await customAlert('Error', 'Failed to verify channels. Please try again.');
                                return;
                            }

                            // Check for cancel again
                            if (shouldCancelSend) {
                                isChecking = false;
                                shouldCancelSend = false;
                                sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                sendBtn.innerHTML = 'Send';
                                return;
                            }

                            // Build a map of valid guild IDs and channel IDs from refresh
                            const validGuilds = new Map();
                            const validChannels = new Set();
                            for (const guild of refreshData.guilds) {
                                validGuilds.set(guild.id, guild);
                                for (const channel of guild.channels) {
                                    validChannels.add(`${guild.id}-${channel.id}`);
                                }
                            }

                            // Update shared guilds array (clear and push to keep reference)
                            guilds.length = 0;
                            refreshData.guilds.forEach(g => guilds.push({
                                id: g.id,
                                name: g.name,
                                icon: g.icon
                            }));

                            // Update shared serverChannels cache
                            // First remove old guilds that no longer exist
                            const oldGuildIds = Object.keys(serverChannels);
                            for (const guildId of oldGuildIds) {
                                if (!validGuilds.has(guildId)) {
                                    delete serverChannels[guildId];
                                }
                            }

                            // Then update with fresh channel data
                            for (const guild of refreshData.guilds) {
                                serverChannels[guild.id] = guild.channels;
                            }

                            // Filter out selected channels that no longer exist
                            const removedChannels = [];
                            const originalCount = selectedChannels.length;
                            selectedChannels = selectedChannels.filter(ch => {
                                const key = `${ch.guildId}-${ch.id}`;
                                const exists = validChannels.has(key);
                                if (!exists) {
                                    removedChannels.push(ch);
                                }
                                return exists;
                            });

                            // If channels were removed, update UI and save
                            if (removedChannels.length > 0) {
                                // Save updated selection
                                saveSelectedChannels();
                                saveUserDataToDB();

                                // Update all UI elements
                                renderServers();
                                updateSelectedDisplay();
                                updateSendButton();

                                // Update server counts for affected guilds
                                const affectedGuilds = new Set(removedChannels.map(ch => ch.guildId));
                                for (const guildId of affectedGuilds) {
                                    updateServerCount(guildId);
                                }
                            }

                            // Re-render personal panel with updated data
                            renderServers();
                            if (viewMode === 'channels') {
                                renderChannelsOnlyMode();
                            } else if (viewMode === 'selected') {
                                renderSelectedChannelsMode();
                            }

                            // Also update team panel UI if functions are available
                            if (typeof window.teamRenderServers === 'function') {
                                window.teamRenderServers();
                                window.teamUpdateSelectedDisplay();
                                window.teamUpdateSendButton();
                            }

                            isChecking = false;

                            // Check for cancel after checking phase
                            if (shouldCancelSend) {
                                shouldCancelSend = false;
                                sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                sendBtn.innerHTML = 'Send';
                                AsyncButton.endOperation('personal_send');
                                return;
                            }

                            // Check if bridge is still connected after checking phase
                            const bridgeStillConnected = await checkBridgeConnected();
                            if (!bridgeStillConnected) {
                                sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                sendBtn.innerHTML = 'Send';
                                AsyncButton.endOperation('personal_send');
                                return;
                            }

                            // If no channels left after filtering, stop
                            if (selectedChannels.length === 0) {
                                sendBtn.disabled = true;
                                sendBtn.innerHTML = 'Send';
                                await customAlert('No channels', 'All selected channels are no longer available. Please select new channels.');
                                return;
                            }

                            // Clear previous failed channels
                            failedChannels.clear();

                            // Phase 2: Start sending
                            isSending = true;
                            sendBtn.disabled = false; // Keep enabled for cancel
                            sendBtn.innerHTML = `<span id="send-progress">Sending (1/${selectedChannels.length})</span>`;

                            // Send messages one by one for real-time usage tracking
                            let succeededChannels = [];
                            let rateLimitedChannels = [];
                            let failedChannelsList = [];

                            // Helper function to wait/delay
                            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

                            // Get custom delay setting from global variable (updated by settings popup)
                            const getCustomDelay = () => window.userMessageDelay || 1000;

                            // Get progress element for smooth updates
                            const progressEl = document.getElementById('send-progress');

                            // Helper to check bridge status quickly (without showing popup)
                            const quickBridgeCheck = async () => {
                                try {
                                    const resp = await fetch('/api/bridge/status');
                                    const data = await resp.json();
                                    return data.success && data.is_online;
                                } catch {
                                    return false;
                                }
                            };

                            for (let i = 0; i < selectedChannels.length; i++) {
                                // Check for cancel before each message
                                if (shouldCancelSend) {
                                    shouldCancelSend = false;
                                    isSending = false;
                                    sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                    sendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('personal_send');
                                    // Show partial results if any
                                    if (succeededChannels.length > 0 || rateLimitedChannels.length > 0 || failedChannelsList.length > 0) {
                                        await showSendResults(succeededChannels, rateLimitedChannels, failedChannelsList, true);
                                    }
                                    return;
                                }

                                // Check if bridge is still connected before each message
                                const bridgeOk = await quickBridgeCheck();
                                if (!bridgeOk) {
                                    isSending = false;
                                    sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                    sendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('personal_send');
                                    // Show bridge disconnected popup only (no partial results)
                                    await checkBridgeConnected();
                                    return;
                                }

                                const channel = selectedChannels[i];

                                // Update progress text only (keeps spinner smooth)
                                if (progressEl) {
                                    progressEl.textContent = `Sending (${i + 1}/${selectedChannels.length})`;
                                }

                                // Send message (no retry for rate limits)
                                const response = await fetch('/api/send-message-single', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({
                                        channel: channel,
                                        message: messageInput.value,
                                        discord_account_id: currentDiscordAccountId
                                    })
                                });

                                const result = await response.json();

                                // Check if send was successful (200/201 response)
                                if (response.ok && result.success) {
                                    succeededChannels.push(channel.name);
                                    // Clear any previous failure status for this channel
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.delete(channelKey);
                                    updateFailedChannelStatus(channel);
                                } else if (result.account_suspended) {
                                    // Account is suspended/deleted - cancel all and show popup
                                    const accountInfo = result.account_info || {
                                        username: 'Unknown',
                                        discord_id: 'Unknown'
                                    };
                                    isSending = false;
                                    sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                    sendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('personal_send');
                                    await showSuspendedAccountPopup(accountInfo);
                                    window.location.reload();
                                    return; // Stop execution
                                } else if (result.token_invalid) {
                                    // Token is invalid - cancel all and show token update popup
                                    const accountInfo = result.account_info || {
                                        username: 'Unknown',
                                        discord_id: result.account_id || 'Unknown',
                                        account_id: result.account_id
                                    };
                                    isSending = false;
                                    sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                    sendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('personal_send');
                                    await showTokenUpdatePopup(accountInfo, () => {
                                        window.location.reload();
                                    });
                                    return; // Stop execution
                                } else if (result.limit_reached) {
                                    // Usage limit reached - cancel all and redirect to billing
                                    isSending = false;
                                    sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                    sendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('personal_send');
                                    await customAlert('Limit reached', 'Usage limit reached!\n\nYou have reached your message limit for this period.\nRedirecting to billing...');
                                    window.location.href = '/settings#billing';
                                    return; // Stop execution
                                } else if (result.bridge_required) {
                                    // Bridge not connected - cancel all and show popup
                                    isSending = false;
                                    sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                    sendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('personal_send');
                                    await customAlert('Bridge Required', 'Your Adzsend Bridge app is not connected.\n\nPlease open the Bridge app and activate it to send messages.');
                                    return; // Stop execution
                                } else if (result.user_flagged) {
                                    // User was flagged - cancel all and update UI
                                    isSending = false;
                                    AsyncButton.endOperation('personal_send');
                                    if (result.user_banned) {
                                        // Auto-banned - BLOCK EVERYTHING IMMEDIATELY
                                        // Disable send button and message input
                                        if (sendBtn) sendBtn.disabled = true;
                                        sendBtn.innerHTML = 'Send';
                                        if (messageInput) {
                                            messageInput.disabled = true;
                                            messageInput.value = '';
                                            messageInput.placeholder = 'Account suspended - cannot send messages';
                                        }

                                        // Update status bar to show suspended
                                        updateAccountStatus('banned');

                                        // Show ban popup
                                        await customAlert('Account Suspended', 'Your account has been suspended due to multiple violations. You have been automatically banned after 3 flags.');

                                        // Force redirect to analytics
                                        window.location.href = '/dashboard?page=analytics';
                                    } else {
                                        // Just flagged - update status bar to show flagged
                                        sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                                        sendBtn.innerHTML = 'Send';
                                        updateAccountStatus('flagged');
                                        // Show warning
                                        await customAlert('Content Violation', result.error || 'Your message contains prohibited content and your account has been flagged.');
                                    }
                                    return; // Stop execution
                                } else if (response.status === 429) {
                                    // Rate limited by Discord - mark and skip (don't retry)
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.set(channelKey, { type: 'ratelimit' });
                                    rateLimitedChannels.push(channel.name);
                                    updateFailedChannelStatus(channel);
                                } else {
                                    // Other error (permissions, etc.)
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.set(channelKey, { type: 'permission' });
                                    failedChannelsList.push(channel.name);
                                    updateFailedChannelStatus(channel);
                                }

                                // Add delay between messages based on user setting
                                // Only delay if there are more messages to send
                                const currentDelay = getCustomDelay();
                                if (i < selectedChannels.length - 1 && currentDelay > 0) {
                                    await delay(currentDelay);
                                }
                            }

                            // Show collapsible results
                            await showSendResults(succeededChannels, rateLimitedChannels, failedChannelsList);
                        } catch (error) {
                            console.error('Send error:', error);
                            await customAlert('Error', `Error sending message: ${error.message}`);
                        } finally {
                            isSending = false;
                            isChecking = false;
                            shouldCancelSend = false;
                            sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                            sendBtn.innerHTML = 'Send';
                            AsyncButton.endOperation('personal_send');
                        }
                    }
                });
            }

            // Expose personal panel render functions for team panel to call after refresh
            window.personalRenderServers = renderServers;
            window.personalRenderChannelsOnlyMode = renderChannelsOnlyMode;
            window.personalRenderSelectedChannelsMode = renderSelectedChannelsMode;
            window.personalUpdateSelectedDisplay = updateSelectedDisplay;
            window.personalUpdateSendButton = updateSendButton;

            // Initialize on load
            initializeUI();
        });

        // ============================================
        // TEAM PANEL JavaScript
        // Separate functionality for the Team panel
        // ============================================
        document.addEventListener('DOMContentLoaded', function() {
            // Check if team panel elements exist
            const teamServerSidebar = document.getElementById('team-server-sidebar');
            if (!teamServerSidebar) return; // Exit if no team panel

            const teamChannelsList = document.getElementById('team-channels-list');
            const teamMessageInput = document.getElementById('team-message-input');
            const teamSendBtn = document.getElementById('team-send-btn');
            const teamCharCount = document.getElementById('team-char-count');
            const teamChannelSearch = document.getElementById('team-channel-search');
            const teamSearchTagsContainer = document.getElementById('team-search-tags');
            const MESSAGE_LIMIT = 2000;

            // Team panel uses shared data from window (loaded by personal panel)
            const guilds = window.guilds;
            const serverChannels = window.serverChannels;
            let teamSelectedChannels = []; // Team's own selected channels
            let teamSelectedGuild = null; // Currently selected guild
            let teamSearchTags = []; // Search filter tags
            let teamSearchText = ''; // Search text for selected server mode (live filtering)
            let teamCurrentServerColor = 'rgba(21, 216, 188, 0.6)';
            let teamIsSending = false;
            let teamShouldCancelSend = false; // Track if user wants to cancel team send
            let teamFailedChannels = new Map();
            let teamViewMode = 'servers';
            let teamChannelsOnlySearchText = '';
            let teamChannelsOnlySearchTags = [];
            let teamSelectedChannelsModeSearchText = '';
            const teamMaxChannelsPerServer = {{ plan_status.max_channels_per_server if plan_status and plan_status.max_channels_per_server is defined else 2 }};

            // Team panel view mode toggle elements
            const teamViewModeRadios = document.querySelectorAll('input[name="team-view-mode"]');
            const teamServersModeHeader = document.querySelector('.team-servers-mode-header');
            const teamChannelsOnlyHeader = document.querySelector('.team-channels-only-header');
            const teamSelectedChannelsModeHeader = document.querySelector('.team-selected-channels-mode-header');
            const teamServersModeSections = document.querySelectorAll('.team-servers-mode-section');
            const teamChannelsOnlySection = document.querySelector('.team-channels-only-section');
            const teamSelectedChannelsModeSection = document.querySelector('.team-selected-channels-mode-section');
            const teamChannelsOnlyList = document.getElementById('team-channels-only-list');
            const teamSelectedChannelsModeList = document.getElementById('team-selected-channels-mode-list');
            const teamChannelsOnlySearch = document.getElementById('team-channels-only-search');
            const teamSelectedChannelsModeSearch = document.getElementById('team-selected-channels-mode-search');
            const teamChannelsOnlySearchTagsContainer = document.getElementById('team-channels-only-search-tags');

            // Team view mode toggle handler
            teamViewModeRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    const mode = radio.value;
                    if (mode === teamViewMode) return;

                    teamViewMode = mode;

                    // Hide all headers and sections first
                    teamServersModeHeader.style.display = 'none';
                    teamChannelsOnlyHeader.style.display = 'none';
                    teamSelectedChannelsModeHeader.style.display = 'none';
                    teamServersModeSections.forEach(s => s.style.display = 'none');
                    teamChannelsOnlySection.style.display = 'none';
                    teamSelectedChannelsModeSection.style.display = 'none';

                    // Show the appropriate mode
                    if (mode === 'servers') {
                        teamServersModeHeader.style.display = '';
                        teamServersModeSections.forEach(s => s.style.display = '');
                    } else if (mode === 'channels') {
                        teamChannelsOnlyHeader.style.display = '';
                        teamChannelsOnlySection.style.display = 'flex';
                        // Show loading dots immediately, then render asynchronously
                        teamChannelsOnlyList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';
                        requestAnimationFrame(() => {
                            setTimeout(() => teamRenderChannelsOnlyMode(), 0);
                        });
                    } else if (mode === 'selected') {
                        teamSelectedChannelsModeHeader.style.display = '';
                        teamSelectedChannelsModeSection.style.display = 'flex';
                        // Show loading dots immediately, then render asynchronously
                        teamSelectedChannelsModeList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';
                        requestAnimationFrame(() => {
                            setTimeout(() => teamRenderSelectedChannelsMode(), 0);
                        });
                    }
                });
            });

            // Team selected channels mode search handler
            if (teamSelectedChannelsModeSearch) {
                teamSelectedChannelsModeSearch.addEventListener('input', (e) => {
                    teamSelectedChannelsModeSearchText = e.target.value.toLowerCase();
                    teamRenderSelectedChannelsMode();
                });
            }

            // Render channels in team selected channels mode (with event delegation)
            function teamRenderSelectedChannelsMode() {
                if (!teamSelectedChannelsModeList) return;

                if (teamSelectedChannels.length === 0) {
                    teamSelectedChannelsModeList.innerHTML = '<div class="no-selection">No channels selected</div>';
                    return;
                }

                // Filter by search text (channel name only, consistent with other modes)
                let filteredChannels = teamSelectedChannels;
                if (teamSelectedChannelsModeSearchText) {
                    filteredChannels = teamSelectedChannels.filter(ch =>
                        ch.name.toLowerCase().includes(teamSelectedChannelsModeSearchText)
                    );
                }

                if (filteredChannels.length === 0) {
                    teamSelectedChannelsModeList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                teamSelectedChannelsModeList.innerHTML = filteredChannels.map(channel => {
                    const iconUrl = channel.guildIcon
                        ? `https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png`
                        : null;
                    const serverIconHtml = iconUrl
                        ? `<img class="server-icon-small" src="${iconUrl}" alt="">`
                        : `<div class="server-icon-placeholder-small">${channel.guildName[0].toUpperCase()}</div>`;
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    const failedInfo = teamFailedChannels.get(channelKey);
                    const isFailed = !!failedInfo;
                    const failedClass = isFailed ? ' failed' : '';
                    const statusText = failedInfo?.type === 'ratelimit' ? 'Rate limited' : 'Missing permission';
                    const statusTagHtml = isFailed ? `<span class="channel-status-tag">${statusText}</span>` : '';
                    return `<div class="channel-item selected${failedClass}" data-channel-id="${channel.id}" data-channel-name="${channel.name}" data-guild-id="${channel.guildId}" data-guild-name="${channel.guildName}" data-guild-icon="${channel.guildIcon || ''}">${serverIconHtml}<span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right">${statusTagHtml}<img class="channel-tick" src="{{ url_for('static', filename='x.png') }}" alt="x"></div></div>`;
                }).join('');
            }

            // Event delegation for team selected channels mode clicks (remove channel)
            if (teamSelectedChannelsModeList) {
                teamSelectedChannelsModeList.addEventListener('click', (e) => {
                    const item = e.target.closest('.channel-item');
                    if (!item) return;

                    const channelId = item.dataset.channelId;
                    const guildId = item.dataset.guildId;

                    teamSelectedChannels = teamSelectedChannels.filter(ch =>
                        !(ch.id === channelId && ch.guildId === guildId)
                    );

                    teamSaveSelectedChannels();
                    teamRenderSelectedChannelsMode();
                    teamUpdateServerCount(guildId);
                    teamUpdateSendButton();

                    if (teamSelectedGuild && teamSelectedGuild.id === guildId) {
                        teamRenderChannels();
                    }
                });
            }

            // Team channels-only search handler
            if (teamChannelsOnlySearch) {
                teamChannelsOnlySearch.addEventListener('input', (e) => {
                    teamChannelsOnlySearchText = e.target.value.toLowerCase();
                    teamRenderChannelsOnlyMode();
                });
                teamChannelsOnlySearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && teamChannelsOnlySearch.value.trim()) {
                        teamAddChannelsOnlySearchTag(teamChannelsOnlySearch.value);
                    }
                });
            }

            function teamAddChannelsOnlySearchTag(text) {
                if (teamChannelsOnlySearchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                const trimmedText = text.trim().toLowerCase();
                if (trimmedText.length > 10) {
                    showTagCharLimitModal();
                    return;
                }
                if (!teamChannelsOnlySearchTags.includes(trimmedText) && trimmedText) {
                    teamChannelsOnlySearchTags.push(trimmedText);
                    teamUpdateChannelsOnlySearchTagsDisplay();
                    teamChannelsOnlySearch.value = '';
                    teamChannelsOnlySearchText = '';
                    teamRenderChannelsOnlyMode();
                }
            }

            function teamRemoveChannelsOnlySearchTag(tag) {
                teamChannelsOnlySearchTags = teamChannelsOnlySearchTags.filter(t => t !== tag);
                teamUpdateChannelsOnlySearchTagsDisplay();
                teamRenderChannelsOnlyMode();
            }

            function teamUpdateChannelsOnlySearchTagsDisplay() {
                if (!teamChannelsOnlySearchTagsContainer) return;
                teamChannelsOnlySearchTagsContainer.innerHTML = '';
                teamChannelsOnlySearchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}"></span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        teamRemoveChannelsOnlySearchTag(tag);
                    });
                    teamChannelsOnlySearchTagsContainer.appendChild(tagEl);
                });
            }

            // Render channels in team channels-only mode (with event delegation)
            const renderChannelItemHtml = window.renderChannelItemHtml;

            function teamRenderChannelsOnlyMode() {
                if (!teamChannelsOnlyList) return;

                let allChannels = [];
                for (const guild of guilds) {
                    const channels = serverChannels[guild.id] || [];
                    for (const channel of channels) {
                        allChannels.push({
                            ...channel,
                            guildId: guild.id,
                            guildName: guild.name,
                            guildIcon: guild.icon
                        });
                    }
                }

                // Filter by search tags (OR logic - any tag matches channel name only)
                if (teamChannelsOnlySearchTags.length > 0) {
                    allChannels = allChannels.filter(ch =>
                        teamChannelsOnlySearchTags.some(tag => ch.name.toLowerCase().includes(tag))
                    );
                }

                // Filter by search text (channel name only, same as Selected server mode)
                if (teamChannelsOnlySearchText) {
                    allChannels = allChannels.filter(ch =>
                        ch.name.toLowerCase().includes(teamChannelsOnlySearchText)
                    );
                }

                if (allChannels.length === 0) {
                    if (!window.channelsLoadingComplete) {
                        teamChannelsOnlyList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';
                    } else if (teamChannelsOnlySearchText || teamChannelsOnlySearchTags.length > 0) {
                        teamChannelsOnlyList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    } else {
                        teamChannelsOnlyList.innerHTML = '<div class="no-selection">No channels found</div>';
                    }
                    return;
                }

                teamChannelsOnlyList.innerHTML = allChannels.map(channel => renderChannelItemHtml(channel, teamSelectedChannels)).join('');
            }

            // Event delegation for team channels-only list clicks
            if (teamChannelsOnlyList) {
                teamChannelsOnlyList.addEventListener('click', (e) => {
                    const item = e.target.closest('.channel-item');
                    if (!item) return;

                    const channelId = item.dataset.channelId;
                    const channelName = item.dataset.channelName;
                    const guildId = item.dataset.guildId;
                    const guildName = item.dataset.guildName;
                    const guildIcon = item.dataset.guildIcon;

                    teamToggleChannelSelection({
                        id: channelId,
                        name: channelName,
                        guildId: guildId,
                        guildName: guildName,
                        guildIcon: guildIcon
                    });

                    const isNowSelected = teamSelectedChannels.some(ch => ch.id === channelId);
                    if (isNowSelected) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });
            }

            // Warn user before leaving if team messages are being sent
            window.addEventListener('beforeunload', (e) => {
                if (teamIsSending) {
                    e.preventDefault();
                    e.returnValue = '';
                    return '';
                }
            });

            // Load team saved data from localStorage
            function teamLoadSelectedChannels() {
                const saved = localStorage.getItem('teamSelectedChannels');
                if (saved) {
                    try {
                        teamSelectedChannels = JSON.parse(saved);
                    } catch (e) {
                        console.error('Error loading saved team channels:', e);
                        teamSelectedChannels = [];
                    }
                }
            }

            // Save team selected channels to localStorage and database
            async function teamSaveSelectedChannels() {
                localStorage.setItem('teamSelectedChannels', JSON.stringify(teamSelectedChannels));
                // Also save to database
                try {
                    await fetch('/api/save-user-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-Token': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({
                            business_selected_channels: teamSelectedChannels
                        })
                    });
                } catch (error) {
                    console.warn('Failed to save team channels to database:', error);
                }
            }

            // Add team search tag
            function teamAddSearchTag(text) {
                if (teamSearchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                const trimmedText = text.trim().toLowerCase();
                if (trimmedText.length > 10) {
                    showTagCharLimitModal();
                    return;
                }
                if (!teamSearchTags.includes(trimmedText) && trimmedText) {
                    teamSearchTags.push(trimmedText);
                    teamUpdateSearchTagsDisplay();
                    teamChannelSearch.value = '';
                    teamSearchText = '';
                    if (teamSelectedGuild) {
                        teamRenderChannels();
                    }
                }
            }

            function teamRemoveSearchTag(tag) {
                teamSearchTags = teamSearchTags.filter(t => t !== tag);
                teamUpdateSearchTagsDisplay();
                if (teamSelectedGuild) {
                    teamRenderChannels();
                }
            }

            function teamUpdateSearchTagsDisplay() {
                teamSearchTagsContainer.innerHTML = '';
                teamSearchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}"></span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        teamRemoveSearchTag(tag);
                    });
                    teamSearchTagsContainer.appendChild(tagEl);
                });
            }

            // Handle team channel search input
            if (teamChannelSearch) {
                teamChannelSearch.addEventListener('input', (e) => {
                    teamSearchText = e.target.value.toLowerCase();
                    teamRenderChannels();
                });
                teamChannelSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && teamChannelSearch.value.trim()) {
                        teamAddSearchTag(teamChannelSearch.value);
                    }
                });
            }

            // Render team server sidebar icons
            function teamRenderServers() {
                if (!teamServerSidebar) return;

                teamServerSidebar.innerHTML = '';

                if (!guilds || guilds.length === 0) {
                    return;
                }

                guilds.forEach(guild => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'server-icon-wrapper';
                    wrapper.dataset.guildId = guild.id;
                    wrapper.title = guild.name;

                    const iconHtml = guild.icon
                        ? `<img src="https://cdn.discordapp.com/icons/${guild.id}/${guild.icon}.png?size=96" alt="${guild.name}">`
                        : `<span class="server-icon-placeholder">${guild.name.charAt(0).toUpperCase()}</span>`;

                    wrapper.innerHTML = `
                        <div class="server-icon-pill"></div>
                        <div class="server-icon-holder">
                            ${iconHtml}
                        </div>
                    `;

                    wrapper.addEventListener('click', () => teamSelectServer(guild));
                    teamServerSidebar.appendChild(wrapper);

                    if (teamSelectedGuild && teamSelectedGuild.id === guild.id) {
                        wrapper.classList.add('active');
                    }
                });
            }

            // Initialize team UI (uses shared guilds/channels data from window)
            async function teamInitializeUI() {
                teamLoadSelectedChannels();
                teamUpdateSelectedDisplay();
                teamUpdateSendButton();

                // Hide loading and show content for team message box immediately
                const teamMsgLoadingEl = document.getElementById('team-message-loading');
                const teamMsgContentEl = document.getElementById('team-message-content');
                if (teamMsgLoadingEl) teamMsgLoadingEl.style.display = 'none';
                if (teamMsgContentEl) {
                    teamMsgContentEl.style.opacity = '1';
                    teamMsgContentEl.style.pointerEvents = 'auto';
                }

                // Wait for shared data to be loaded by personal panel, then render
                await waitForGuildsAndRender();
            }

            // Wait for guilds to load, then render team panel
            async function waitForGuildsAndRender() {
                // Poll until guilds are loaded (personal panel loads them)
                while (!window.guildsLoaded) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Clean up selected channels for servers that no longer exist
                const guildIds = new Set(guilds.map(g => g.id));
                const originalLength = teamSelectedChannels.length;
                teamSelectedChannels = teamSelectedChannels.filter(ch => guildIds.has(ch.guildId));
                if (teamSelectedChannels.length !== originalLength) {
                    teamSaveSelectedChannels();
                }

                // Render team panel
                teamRenderServers();
                teamUpdateSelectedDisplay();
                teamUpdateSendButton();
            }

            // Extract dominant color from image (team version)
            function teamGetDominantColor(imageUrl, callback) {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    let r = 0, g = 0, b = 0, count = 0;

                    for (let i = 0; i < data.length; i += 40) {
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        count++;
                    }

                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    callback(`rgb(${r}, ${g}, ${b})`);
                };
                img.onerror = function() {
                    callback('rgba(21, 216, 188, 0.6)');
                };
                img.src = imageUrl;
            }

            // Select a server and load its channels (team version)
            async function teamSelectServer(guild) {
                teamSelectedGuild = guild;
                const guildId = guild.id;

                document.querySelectorAll('#team-server-sidebar .server-icon-wrapper').forEach(item => {
                    item.classList.remove('active');
                });

                const activeItem = teamServerSidebar.querySelector(`[data-guild-id="${guildId}"]`);
                if (activeItem) {
                    activeItem.classList.add('active');
                }

                if (guild.icon) {
                    const iconUrl = `https://cdn.discordapp.com/icons/${guildId}/${guild.icon}.png`;
                    teamGetDominantColor(iconUrl, (color) => {
                        if (teamSelectedGuild && teamSelectedGuild.id === guildId) {
                            teamCurrentServerColor = color;
                        }
                    });
                } else {
                    teamCurrentServerColor = 'rgba(21, 216, 188, 0.6)';
                }

                if (!serverChannels[guildId]) {
                    teamChannelsList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';

                    try {
                        const response = await fetch(`/api/guild/${guildId}/channels`);

                        if (!teamSelectedGuild || teamSelectedGuild.id !== guildId) {
                            return;
                        }

                        const data = await response.json();

                        if (data.token_invalid) {
                            window.location.href = '/settings';
                            return;
                        }

                        if (!response.ok) {
                            return;
                        }

                        if (data.channels) {
                            serverChannels[guildId] = data.channels.filter(ch => ch.type === 0).sort((a, b) => a.position - b.position);
                        } else {
                            serverChannels[guildId] = [];
                        }
                    } catch (error) {
                        console.error(`Error fetching team channels:`, error);
                        serverChannels[guildId] = [];
                    }
                }

                if (teamSelectedGuild && teamSelectedGuild.id === guildId) {
                    teamRenderChannels();
                }

                if (teamViewMode === 'channels') {
                    teamRenderChannelsOnlyMode();
                }
            }

            // Render channels for selected team server (with event delegation)
            function teamRenderChannels() {
                if (!teamSelectedGuild) {
                    teamChannelsList.innerHTML = '<div class="no-selection">Select a server to view channels</div>';
                    return;
                }

                const currentGuildId = teamSelectedGuild.id;
                const channels = serverChannels[teamSelectedGuild.id] || [];

                if (channels.length === 0) {
                    teamChannelsList.innerHTML = '<div class="no-selection">No channels found</div>';
                    return;
                }

                let filteredChannels = channels;
                if (teamSearchTags.length > 0) {
                    filteredChannels = channels.filter(channel =>
                        teamSearchTags.some(tag => channel.name.toLowerCase().includes(tag))
                    );
                }

                // Filter by search text (live filtering as you type)
                if (teamSearchText) {
                    filteredChannels = filteredChannels.filter(channel =>
                        channel.name.toLowerCase().includes(teamSearchText)
                    );
                }

                if (filteredChannels.length === 0) {
                    teamChannelsList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                teamChannelsList.innerHTML = filteredChannels.map(channel => {
                    const isSelected = teamSelectedChannels.some(ch => ch.id === channel.id && ch.guildId === currentGuildId);
                    return `<div class="channel-item ${isSelected ? 'selected' : ''}" data-channel-id="${channel.id}" data-channel-name="${channel.name}"><span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right"><img class="channel-tick" src="{{ url_for('static', filename='tick.png') }}" alt=""></div></div>`;
                }).join('');
            }

            // Event delegation for team server channels list clicks
            if (teamChannelsList) {
                teamChannelsList.addEventListener('click', (e) => {
                    const item = e.target.closest('.channel-item');
                    if (!item || !teamSelectedGuild) return;

                    const channelId = item.dataset.channelId;
                    const channels = serverChannels[teamSelectedGuild.id] || [];
                    const channel = channels.find(ch => ch.id === channelId);
                    if (!channel) return;

                    const currentlySelected = teamSelectedChannels.some(ch =>
                        ch.id === channel.id && ch.guildId === teamSelectedGuild.id
                    );
                    teamToggleChannel(channel, !currentlySelected);
                });
            }

            // Toggle team channel selection for channels-only mode
            function teamToggleChannelSelection(channel) {
                const isCurrentlySelected = teamSelectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === channel.guildId
                );

                if (!isCurrentlySelected) {
                    if (teamMaxChannelsPerServer !== -1) {
                        const currentServerChannelCount = teamSelectedChannels.filter(ch =>
                            ch.guildId === channel.guildId
                        ).length;

                        if (currentServerChannelCount >= teamMaxChannelsPerServer) {
                            showChannelLimitModal(teamMaxChannelsPerServer);
                            return;
                        }
                    }

                    teamSelectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: channel.guildId,
                        guildName: channel.guildName,
                        guildIcon: channel.guildIcon || null
                    });
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    teamFailedChannels.delete(channelKey);
                } else {
                    teamSelectedChannels = teamSelectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === channel.guildId)
                    );
                }

                teamSaveSelectedChannels();
                teamUpdateServerCount(channel.guildId);
                teamUpdateSelectedDisplay();
                teamUpdateSendButton();
            }

            // Toggle team channel selection
            function teamToggleChannel(channel, isChecked) {
                if (!teamSelectedGuild) return;

                const isCurrentlySelected = teamSelectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === teamSelectedGuild.id
                );

                if (isChecked && !isCurrentlySelected) {
                    if (teamMaxChannelsPerServer !== -1) {
                        const currentServerChannelCount = teamSelectedChannels.filter(ch =>
                            ch.guildId === teamSelectedGuild.id
                        ).length;

                        if (currentServerChannelCount >= teamMaxChannelsPerServer) {
                            showChannelLimitModal(teamMaxChannelsPerServer);
                            return;
                        }
                    }

                    teamSelectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: teamSelectedGuild.id,
                        guildName: teamSelectedGuild.name,
                        guildIcon: teamSelectedGuild.icon || null
                    });
                    const channelKey = `${teamSelectedGuild.id}-${channel.id}`;
                    teamFailedChannels.delete(channelKey);
                } else if (!isChecked && isCurrentlySelected) {
                    teamSelectedChannels = teamSelectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === teamSelectedGuild.id)
                    );
                }

                teamSaveSelectedChannels();
                teamRenderChannels();
                teamUpdateServerCount(teamSelectedGuild.id);
                teamUpdateSelectedDisplay();
                teamUpdateSendButton();
            }

            // Update count badge on team server
            function teamUpdateServerCount(guildId) {
                const count = teamSelectedChannels.filter(ch => ch.guildId === guildId).length;
                const serverItem = teamServerSidebar.querySelector(`[data-guild-id="${guildId}"]`);
                if (serverItem) {
                    const countEl = serverItem.querySelector('.server-count');
                    if (countEl) {
                        if (count > 0) {
                            countEl.textContent = `${count} selected`;
                            countEl.style.display = 'block';
                            serverItem.classList.add('has-selection');
                        } else {
                            countEl.style.display = 'none';
                            serverItem.classList.remove('has-selection');
                        }
                    }
                }
            }

            // Update team failed channel status
            function teamUpdateFailedChannelStatus(channel) {
                if (teamViewMode === 'selected') {
                    teamRenderSelectedChannelsMode();
                }
            }

            // Update team selected channels display
            function teamUpdateSelectedDisplay() {
                if (teamViewMode === 'selected') {
                    teamRenderSelectedChannelsMode();
                }
                if (teamViewMode === 'channels') {
                    teamRenderChannelsOnlyMode();
                }
            }

            // Update team send button state
            function teamUpdateSendButton() {
                if (teamSendBtn && teamMessageInput) {
                    // Team message is read-only - check if there's a team message set
                    const teamMessage = teamMessageInput.value.trim();
                    teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessage;
                }
            }
            // Expose team functions globally so personal panel can update team UI after refresh
            window.teamUpdateSendButton = teamUpdateSendButton;
            window.teamRenderServers = teamRenderServers;
            window.teamRenderChannelsOnlyMode = teamRenderChannelsOnlyMode;
            window.teamRenderSelectedChannelsMode = teamRenderSelectedChannelsMode;
            window.teamUpdateSelectedDisplay = teamUpdateSelectedDisplay;

            // Team send button handler - uses AsyncButton for double-click prevention
            if (teamSendBtn) {
                teamSendBtn.addEventListener('click', async function() {
                    // If already cancelling during send, ignore further clicks
                    if (teamShouldCancelSend) {
                        return;
                    }

                    // If currently sending, cancel instantly
                    if (teamIsSending) {
                        const cancelConfirmed = await customConfirm('Message sending', 'Are you sure you would like to cancel? This will stop any further actions.', 'Yes');
                        if (cancelConfirmed) {
                            teamShouldCancelSend = true;
                        }
                        return;
                    }

                    // Prevent double-clicks
                    if (AsyncButton.isProcessing('team_send')) {
                        return;
                    }

                    const teamMessage = teamMessageInput ? teamMessageInput.value.trim() : '';
                    if (teamSelectedChannels.length > 0 && teamMessage) {
                        // Mark operation as started
                        AsyncButton.startOperation('team_send');

                        // Phase 1: Check and refresh guilds/channels
                        teamSendBtn.innerHTML = '<span id="team-send-progress">Checking</span>';

                        try {
                            const refreshResponse = await fetch('/api/refresh-guilds-channels', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRF-Token': '{{ csrf_token }}'
                                }
                            });

                            const refreshData = await refreshResponse.json();

                            if (refreshData.token_invalid || refreshData.account_suspended || !refreshResponse.ok || !refreshData.guilds) {
                                teamSendBtn.innerHTML = 'Send';
                                AsyncButton.endOperation('team_send');
                                if (refreshData.token_invalid) {
                                    await customAlert('Error', 'Discord token is invalid. Please reconnect your account.');
                                } else {
                                    await customAlert('Error', 'Failed to verify channels. Please try again.');
                                }
                                return;
                            }

                            // Build a map of valid guild IDs and channel IDs
                            const validGuilds = new Map();
                            const validChannels = new Set();
                            for (const guild of refreshData.guilds) {
                                validGuilds.set(guild.id, guild);
                                for (const channel of guild.channels) {
                                    validChannels.add(`${guild.id}-${channel.id}`);
                                }
                            }

                            // Update shared guilds array
                            guilds.length = 0;
                            refreshData.guilds.forEach(g => guilds.push({
                                id: g.id,
                                name: g.name,
                                icon: g.icon
                            }));

                            // Update shared serverChannels
                            const oldGuildIds = Object.keys(serverChannels);
                            for (const guildId of oldGuildIds) {
                                if (!validGuilds.has(guildId)) {
                                    delete serverChannels[guildId];
                                }
                            }
                            for (const guild of refreshData.guilds) {
                                serverChannels[guild.id] = guild.channels;
                            }

                            // Filter out team selected channels that no longer exist
                            const removedChannels = [];
                            teamSelectedChannels = teamSelectedChannels.filter(ch => {
                                const key = `${ch.guildId}-${ch.id}`;
                                const exists = validChannels.has(key);
                                if (!exists) removedChannels.push(ch);
                                return exists;
                            });

                            if (removedChannels.length > 0) {
                                teamSaveSelectedChannels();
                                teamRenderServers();
                                teamUpdateSelectedDisplay();
                                teamUpdateSendButton();

                                // If no channels left after cleanup, stop
                                if (teamSelectedChannels.length === 0) {
                                    teamSendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('team_send');
                                    await customAlert('Channels Removed', `${removedChannels.length} channel(s) were removed because they no longer exist.`);
                                    return;
                                }
                            }

                            // Re-render team panel with fresh data
                            teamRenderServers();
                            if (teamViewMode === 'channels') {
                                teamRenderChannelsOnlyMode();
                            } else if (teamViewMode === 'selected') {
                                teamRenderSelectedChannelsMode();
                            }

                            // Also update personal panel UI if functions are available
                            if (typeof window.personalRenderServers === 'function') {
                                window.personalRenderServers();
                                window.personalUpdateSelectedDisplay();
                                window.personalUpdateSendButton();
                            }
                        } catch (error) {
                            console.error('Error checking guilds/channels:', error);
                            teamSendBtn.innerHTML = 'Send';
                            AsyncButton.endOperation('team_send');
                            await customAlert('Error', 'Failed to verify channels. Please try again.');
                            return;
                        }

                        // Check for filtered content before proceeding
                        const filteredWords = {{ BLACKLISTED_WORDS|tojson }};
                        const phraseExceptions = {{ PHRASE_EXCEPTIONS|tojson }};

                        function isWordInException(word, messageLower) {
                            const wordLower = word.toLowerCase();
                            const exceptions = phraseExceptions[wordLower] || [];

                            if (exceptions.length === 0) return false;

                            let startIndex = 0;
                            while (true) {
                                const pos = messageLower.indexOf(wordLower, startIndex);
                                if (pos === -1) break;

                                const wordEnd = pos + wordLower.length;
                                let isException = false;

                                for (const exception of exceptions) {
                                    const excLower = exception.toLowerCase();
                                    const excPos = messageLower.indexOf(excLower);
                                    if (excPos !== -1 && excPos <= pos && (excPos + excLower.length) >= wordEnd) {
                                        isException = true;
                                        break;
                                    }
                                }

                                if (!isException) return false;

                                startIndex = pos + 1;
                            }

                            return true;
                        }

                        const messageLower = teamMessage.toLowerCase();
                        let foundWords = [];

                        for (const word of filteredWords) {
                            if (messageLower.includes(word.toLowerCase())) {
                                if (!isWordInException(word, messageLower)) {
                                    foundWords.push(word);
                                }
                            }
                        }

                        if (foundWords.length > 0) {
                            try {
                                await fetch('/api/flag-self', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({ words: foundWords })
                                });
                            } catch (e) {
                                console.error('Failed to report flagged content:', e);
                            }

                            await customAlert('Warning', `Your message contains prohibited content:\n ${foundWords.join('\n ')}`);
                            AsyncButton.endOperation('team_send');
                            return;
                        }

                        // Show confirmation popup
                        const channelCount = teamSelectedChannels.length;
                        const confirmed = await customConfirm('Send Message', `Send message to ${channelCount} channel${channelCount !== 1 ? 's' : ''}?`, 'Send');
                        if (!confirmed) {
                            AsyncButton.endOperation('team_send');
                            return;
                        }

                        teamFailedChannels.clear();

                        // Check if bridge is still connected before starting to send
                        const bridgeStillConnected = await checkBridgeConnected();
                        if (!bridgeStillConnected) {
                            AsyncButton.endOperation('team_send');
                            return;
                        }

                        teamIsSending = true;
                        teamSendBtn.disabled = false; // Keep enabled for cancel
                        teamSendBtn.innerHTML = `<span id="team-send-progress">Sending (1/${teamSelectedChannels.length})</span>`;

                        let succeededChannels = [];
                        let rateLimitedChannels = [];
                        let failedChannelsList = [];

                        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
                        const getCustomDelay = () => window.userMessageDelay || 1000;
                        const progressEl = document.getElementById('team-send-progress');

                        // Helper to check bridge status quickly (without showing popup)
                        const quickBridgeCheck = async () => {
                            try {
                                const resp = await fetch('/api/bridge/status');
                                const data = await resp.json();
                                return data.success && data.is_online;
                            } catch {
                                return false;
                            }
                        };

                        try {
                            for (let i = 0; i < teamSelectedChannels.length; i++) {
                                // Check for cancel before each message
                                if (teamShouldCancelSend) {
                                    teamShouldCancelSend = false;
                                    teamIsSending = false;
                                    teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessageInput.value.trim();
                                    teamSendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('team_send');
                                    // Show partial results if any
                                    if (succeededChannels.length > 0 || rateLimitedChannels.length > 0 || failedChannelsList.length > 0) {
                                        await showSendResults(succeededChannels, rateLimitedChannels, failedChannelsList, true);
                                    }
                                    return;
                                }

                                // Check if bridge is still connected before each message
                                const bridgeOk = await quickBridgeCheck();
                                if (!bridgeOk) {
                                    teamIsSending = false;
                                    teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessageInput.value.trim();
                                    teamSendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('team_send');
                                    // Show bridge disconnected popup only (no partial results)
                                    await checkBridgeConnected();
                                    return;
                                }

                                const channel = teamSelectedChannels[i];

                                if (progressEl) {
                                    progressEl.textContent = `Sending (${i + 1}/${teamSelectedChannels.length})`;
                                }

                                const response = await fetch('/api/send-message-single', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({
                                        channel: channel,
                                        message: teamMessage,
                                        discord_account_id: currentDiscordAccountId
                                    })
                                });

                                const result = await response.json();

                                if (response.ok && result.success) {
                                    succeededChannels.push(channel.name);
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    teamFailedChannels.delete(channelKey);
                                    teamUpdateFailedChannelStatus(channel);
                                } else if (result.account_suspended) {
                                    // Account is suspended/deleted - cancel all and show popup
                                    const accountInfo = result.account_info || {
                                        username: 'Unknown',
                                        discord_id: 'Unknown'
                                    };
                                    teamIsSending = false;
                                    teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessageInput.value.trim();
                                    teamSendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('team_send');
                                    await showSuspendedAccountPopup(accountInfo);
                                    window.location.reload();
                                    return;
                                } else if (result.token_invalid) {
                                    // Token is invalid - cancel all and show token update popup
                                    const accountInfo = result.account_info || {
                                        username: 'Unknown',
                                        discord_id: result.account_id || 'Unknown',
                                        account_id: result.account_id
                                    };
                                    teamIsSending = false;
                                    teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessageInput.value.trim();
                                    teamSendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('team_send');
                                    await showTokenUpdatePopup(accountInfo, () => {
                                        window.location.reload();
                                    });
                                    return;
                                } else if (result.limit_reached) {
                                    // Usage limit reached - cancel all and redirect to billing
                                    teamIsSending = false;
                                    teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessageInput.value.trim();
                                    teamSendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('team_send');
                                    await customAlert('Limit reached', 'Usage limit reached!\n\nYou have reached your message limit for this period.\nRedirecting to billing...');
                                    window.location.href = '/settings#billing';
                                    return;
                                } else if (result.bridge_required) {
                                    // Bridge not connected - cancel all and show popup
                                    teamIsSending = false;
                                    teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessageInput.value.trim();
                                    teamSendBtn.innerHTML = 'Send';
                                    AsyncButton.endOperation('team_send');
                                    await customAlert('Bridge Required', 'Your Adzsend Bridge app is not connected.\n\nPlease open the Bridge app and activate it to send messages.');
                                    return;
                                } else if (result.user_flagged) {
                                    // User was flagged - cancel all and update UI
                                    teamIsSending = false;
                                    AsyncButton.endOperation('team_send');
                                    if (result.user_banned) {
                                        // Auto-banned - BLOCK EVERYTHING IMMEDIATELY
                                        // Disable team send button and message
                                        if (teamSendBtn) teamSendBtn.disabled = true;
                                        teamSendBtn.innerHTML = 'Send';
                                        const teamMessageEl = document.getElementById('team-message');
                                        if (teamMessageEl) {
                                            teamMessageEl.disabled = true;
                                            teamMessageEl.value = '';
                                            teamMessageEl.placeholder = 'Account suspended - cannot send messages';
                                        }

                                        // Update status bar to show suspended
                                        updateAccountStatus('banned');

                                        // Show ban popup
                                        await customAlert('Account Suspended', 'Your account has been suspended due to multiple violations. You have been automatically banned after 3 flags.');

                                        // Force redirect to analytics
                                        window.location.href = '/dashboard?page=analytics';
                                    } else {
                                        // Just flagged - update status bar to show flagged
                                        teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessageInput.value.trim();
                                        teamSendBtn.innerHTML = 'Send';
                                        updateAccountStatus('flagged');
                                        // Show warning
                                        await customAlert('Content Violation', result.error || 'Your message contains prohibited content and your account has been flagged.');
                                    }
                                    return;
                                } else if (response.status === 429) {
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    teamFailedChannels.set(channelKey, { type: 'ratelimit' });
                                    rateLimitedChannels.push(channel.name);
                                    teamUpdateFailedChannelStatus(channel);
                                } else {
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    teamFailedChannels.set(channelKey, { type: 'permission' });
                                    failedChannelsList.push(channel.name);
                                    teamUpdateFailedChannelStatus(channel);
                                }

                                const currentDelay = getCustomDelay();
                                if (i < teamSelectedChannels.length - 1 && currentDelay > 0) {
                                    await delay(currentDelay);
                                }
                            }

                            await showSendResults(succeededChannels, rateLimitedChannels, failedChannelsList);
                        } catch (error) {
                            console.error('Team send error:', error);
                            await customAlert('Error', `Error sending message: ${error.message}`);
                        } finally {
                            teamIsSending = false;
                            teamShouldCancelSend = false;
                            teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessage;
                            teamSendBtn.innerHTML = 'Send';
                            AsyncButton.endOperation('team_send');
                        }
                    }
                });
            }

            // Initialize team panel on load
            teamInitializeUI();
        });
    </script>

    <!-- Team Management Script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Message box elements
            const mgmtMessageInput = document.getElementById('mgmt-team-message-input');
            const mgmtCharCount = document.getElementById('mgmt-char-count');
            const mgmtSaveBtn = document.getElementById('mgmt-save-btn');
            const MESSAGE_LIMIT = 2000;

            // Left half elements
            const mgmtAddSearch = document.getElementById('mgmt-add-search');
            const mgmtAddModeHeader = document.querySelector('.mgmt-add-mode-header');
            const mgmtAddModeSection = document.querySelector('.mgmt-add-mode-section');
            const mgmtMembersModeSection = document.querySelector('.mgmt-members-mode-section');
            const mgmtAddList = document.getElementById('mgmt-add-list');
            const mgmtMembersList = document.getElementById('mgmt-members-list');
            const mgmtAddEmpty = document.getElementById('mgmt-add-empty');
            const mgmtMembersEmpty = document.getElementById('mgmt-members-empty');

            // Track saved message to detect changes
            let savedMessage = mgmtMessageInput ? mgmtMessageInput.value : '';

            // =====================
            // MESSAGE BOX FUNCTIONS
            // =====================

            function updateMgmtSaveButton() {
                if (mgmtSaveBtn && mgmtMessageInput) {
                    const isOverLimit = mgmtMessageInput.value.length > MESSAGE_LIMIT;
                    const hasChanged = mgmtMessageInput.value !== savedMessage;
                    mgmtSaveBtn.disabled = isOverLimit || !hasChanged;
                }
            }

            function updateMgmtCharCount() {
                if (mgmtCharCount && mgmtMessageInput) {
                    const remaining = MESSAGE_LIMIT - mgmtMessageInput.value.length;
                    mgmtCharCount.textContent = remaining;

                    if (remaining < 0) {
                        mgmtCharCount.style.color = '#991a35';
                    } else {
                        mgmtCharCount.style.color = '#81828A';
                    }
                }
            }

            if (mgmtMessageInput) {
                mgmtMessageInput.addEventListener('input', function() {
                    updateMgmtCharCount();
                    updateMgmtSaveButton();
                });
            }

            updateMgmtSaveButton();

            if (mgmtSaveBtn) {
                mgmtSaveBtn.addEventListener('click', async function() {
                    if (AsyncButton.isProcessing('team_save_message')) return;
                    AsyncButton.startOperation('team_save_message');

                    const message = mgmtMessageInput ? mgmtMessageInput.value : '';

                    mgmtSaveBtn.disabled = true;
                    // Use visibility:hidden on text to maintain button size, position dots absolutely centered
                    mgmtSaveBtn.innerHTML = '<span style="visibility: hidden;">Save</span><div class="loading-dots" style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>';
                    mgmtSaveBtn.style.position = 'relative';

                    try {
                        const response = await fetch('/api/team/set-team-message', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ message: message })
                        });

                        const result = await response.json();

                        if (response.ok && result.success) {
                            const teamPanelTextarea = document.getElementById('team-message-input');
                            if (teamPanelTextarea) {
                                teamPanelTextarea.value = message;
                            }
                            const teamCharCount = document.getElementById('team-char-count');
                            if (teamCharCount) {
                                teamCharCount.textContent = MESSAGE_LIMIT - message.length;
                            }

                            savedMessage = message;
                            mgmtSaveBtn.innerHTML = 'Save';
                            updateMgmtSaveButton();
                        } else {
                            await customAlert('Error', result.error || 'Failed to save team message');
                            mgmtSaveBtn.innerHTML = 'Save';
                            updateMgmtSaveButton();
                        }
                    } catch (error) {
                        console.error('Save team message error:', error);
                        await customAlert('Error', 'Failed to save team message: ' + error.message);
                        mgmtSaveBtn.innerHTML = 'Save';
                        updateMgmtSaveButton();
                    } finally {
                        AsyncButton.endOperation('team_save_message');
                    }
                });
            }

            // =====================
            // RADIO TOGGLE (Add / Team members)
            // =====================

            const mgmtMembersModeHeader = document.querySelector('.mgmt-members-mode-header');

            const mgmtViewModeRadios = document.querySelectorAll('input[name="mgmt-view-mode"]');
            mgmtViewModeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    const mode = this.value;

                    if (mode === 'add') {
                        // Show Add mode
                        if (mgmtAddModeHeader) mgmtAddModeHeader.style.display = '';
                        if (mgmtMembersModeHeader) mgmtMembersModeHeader.style.display = 'none';
                        if (mgmtAddModeSection) mgmtAddModeSection.style.display = 'flex';
                        if (mgmtMembersModeSection) mgmtMembersModeSection.style.display = 'none';
                        // Show/hide empty states
                        if (mgmtMembersEmpty) mgmtMembersEmpty.style.display = 'none';
                        updateEmptyStates();
                    } else {
                        // Show Team members mode
                        if (mgmtAddModeHeader) mgmtAddModeHeader.style.display = 'none';
                        if (mgmtMembersModeHeader) mgmtMembersModeHeader.style.display = '';
                        if (mgmtAddModeSection) mgmtAddModeSection.style.display = 'none';
                        if (mgmtMembersModeSection) mgmtMembersModeSection.style.display = 'flex';
                        // Show/hide empty states
                        if (mgmtAddEmpty) mgmtAddEmpty.style.display = 'none';
                        updateEmptyStates();
                    }
                });
            });

            // =====================
            // HELPER: Update empty state messages
            // =====================

            function updateEmptyStates() {
                // Get current mode
                const currentMode = document.querySelector('input[name="mgmt-view-mode"]:checked');
                const isAddMode = currentMode ? currentMode.value === 'add' : true;

                // Check Add list
                if (mgmtAddList && mgmtAddEmpty) {
                    const items = mgmtAddList.querySelectorAll('.mgmt-member-item');
                    if (items.length === 0 && isAddMode) {
                        mgmtAddEmpty.style.display = '';
                    } else {
                        mgmtAddEmpty.style.display = 'none';
                    }
                }
                // Check Members list
                if (mgmtMembersList && mgmtMembersEmpty) {
                    const items = mgmtMembersList.querySelectorAll('.mgmt-member-item');
                    if (items.length === 0 && !isAddMode) {
                        mgmtMembersEmpty.style.display = '';
                    } else {
                        mgmtMembersEmpty.style.display = 'none';
                    }
                }
            }

            // =====================
            // ADD MEMBER (search bar enter to add)
            // =====================

            if (mgmtAddSearch) {
                // Only allow numeric input
                mgmtAddSearch.addEventListener('input', function() {
                    this.value = this.value.replace(/[^0-9]/g, '');
                });

                mgmtAddSearch.addEventListener('keypress', async function(e) {
                    if (e.key === 'Enter') {
                        const adzsendId = this.value.trim();

                        if (!adzsendId) {
                            return;
                        }

                        if (!/^\d{18}$/.test(adzsendId)) {
                            await customAlert('Failed', 'Adzsend account with this ID dose not exist, please check again.');
                            return;
                        }

                        const operationId = `add_member_${adzsendId}`;
                        if (AsyncButton.isProcessing(operationId)) return;
                        AsyncButton.startOperation(operationId);

                        try {
                            const response = await fetch('/api/team/add-member', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRF-Token': '{{ csrf_token }}'
                                },
                                body: JSON.stringify({ adzsend_id: adzsendId })
                            });

                            const result = await response.json();

                            if (response.ok && result.success) {
                                this.value = '';

                                // Hide empty state message
                                if (mgmtAddEmpty) mgmtAddEmpty.style.display = 'none';

                                // Add new member item to the list
                                const newItem = document.createElement('div');
                                newItem.className = 'channel-item mgmt-member-item';
                                newItem.dataset.adzsendId = adzsendId;
                                newItem.dataset.status = 'pending';
                                newItem.style.cursor = 'default';
                                const memberPhoto = result.profile_photo || 'Light_Blue.jpg';
                                newItem.innerHTML = `
                                    <div class="mgmt-member-avatar" style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden; flex-shrink: 0;">
                                        <img src="/static/profile_photos/${memberPhoto}" alt="Profile" style="width: 100%; height: 100%; object-fit: cover;">
                                    </div>
                                    <span class="channel-name">${adzsendId}</span>
                                    <div class="channel-right">
                                        <span class="channel-status-tag">Pending</span>
                                        <img class="mgmt-member-remove" src="{{ url_for('static', filename='x.png') }}" alt="x" style="width: 16px; height: 16px; cursor: pointer; opacity: 0.7;" data-action="cancel-invite">
                                    </div>
                                `;
                                mgmtAddList.appendChild(newItem);
                            } else {
                                await customAlert('Failed', 'Adzsend account with this ID dose not exist, please check again.');
                            }
                        } catch (error) {
                            console.error('Add member error:', error);
                            await customAlert('Failed', 'Adzsend account with this ID dose not exist, please check again.');
                        } finally {
                            AsyncButton.endOperation(operationId);
                        }
                    }
                });
            }

            // =====================
            // REMOVE HANDLERS (X button clicks)
            // =====================

            // Add list - cancel pending invite (no confirmation)
            if (mgmtAddList) {
                mgmtAddList.addEventListener('click', async function(e) {
                    const removeBtn = e.target.closest('.mgmt-member-remove');
                    if (!removeBtn) return;

                    const memberItem = removeBtn.closest('.mgmt-member-item');
                    if (!memberItem) return;

                    const adzsendId = memberItem.dataset.adzsendId;
                    const operationId = `cancel_invite_${adzsendId}`;

                    if (AsyncButton.isProcessing(operationId)) return;
                    AsyncButton.startOperation(operationId);

                    try {
                        const response = await fetch('/api/team/remove-member', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ adzsend_id: adzsendId })
                        });

                        const result = await response.json();

                        if (response.ok && result.success) {
                            // Remove item from DOM instantly
                            memberItem.remove();
                            updateEmptyStates();
                        } else {
                            await customAlert('Error', result.error || 'Failed to cancel invitation');
                        }
                    } catch (error) {
                        console.error('Cancel invitation error:', error);
                        await customAlert('Error', 'Failed to cancel invitation: ' + error.message);
                    } finally {
                        AsyncButton.endOperation(operationId);
                    }
                });
            }

            // Members list - remove team member (with confirmation)
            if (mgmtMembersList) {
                mgmtMembersList.addEventListener('click', async function(e) {
                    const removeBtn = e.target.closest('.mgmt-member-remove');
                    if (!removeBtn) return;

                    const memberItem = removeBtn.closest('.mgmt-member-item');
                    if (!memberItem) return;

                    const adzsendId = memberItem.dataset.adzsendId;
                    const operationId = `remove_member_${adzsendId}`;

                    if (AsyncButton.isProcessing(operationId)) return;

                    const confirmed = await customConfirm('Remove this team member?', 'Remove Member', { confirmText: 'Remove' });
                    if (!confirmed) return;

                    AsyncButton.startOperation(operationId);

                    try {
                        const response = await fetch('/api/team/remove-member', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ adzsend_id: adzsendId })
                        });

                        const result = await response.json();

                        if (response.ok && result.success) {
                            // Remove item from DOM instantly
                            memberItem.remove();
                            updateEmptyStates();
                        } else {
                            await customAlert(result.error || 'Failed to remove member', 'Error');
                        }
                    } catch (error) {
                        console.error('Remove member error:', error);
                        await customAlert('Failed to remove member: ' + error.message, 'Error');
                    } finally {
                        AsyncButton.endOperation(operationId);
                    }
                });
            }

        });
    </script>

    <!-- Analytics Team List Script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Analytics page - Click entire row to open analytics
            const analyticsTeamList = document.getElementById('analytics-team-list');
            if (analyticsTeamList) {
                analyticsTeamList.addEventListener('click', function(e) {
                    const memberItem = e.target.closest('.analytics-member-item');
                    if (!memberItem) return;

                    const adzsendId = memberItem.dataset.adzsendId;
                    const isOwner = memberItem.dataset.isOwner === 'true';
                    const displayName = isOwner ? `${adzsendId} (Owner)` : adzsendId;

                    if (adzsendId) {
                        openAnalyticsDialog(adzsendId, displayName);
                    }
                });
            }

        });
    </script>

    <script>
        // Global function for analytics team member search (called via oninput)
        function filterAnalyticsMembersList() {
            const searchInput = document.getElementById('analytics-team-search');
            const teamList = document.getElementById('analytics-team-list');

            if (!searchInput || !teamList) return;

            const searchValue = searchInput.value.toLowerCase().trim();
            const memberItems = teamList.querySelectorAll('.analytics-member-item');

            memberItems.forEach(item => {
                const adzsendId = (item.getAttribute('data-adzsend-id') || '').toLowerCase();

                // Show all if search is empty, otherwise filter by adzsend ID match
                if (searchValue === '') {
                    item.style.cssText = 'cursor: pointer;';
                } else if (adzsendId.includes(searchValue)) {
                    item.style.cssText = 'cursor: pointer;';
                } else {
                    item.style.cssText = 'display: none !important;';
                }
            });
        }

        // Copy Adzsend ID to clipboard
        function copyAdzsendId(id) {
            navigator.clipboard.writeText(id).then(() => {
                // Optional: show a brief confirmation
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }
    </script>

    <!-- Analytics Dialog Script -->
    <script>
// Global variable to store current status        window.userAccountStatus = null;        // Update account status in settings popup without page reload        function updateAccountStatus(status) {            // Store globally so it persists            window.userAccountStatus = status;            // Update the DOM            const updateSteps = () => {                const steps = document.querySelectorAll(".standing-step");                if (!steps || steps.length < 3) return false;                // Remove active class from all steps                steps.forEach(step => step.classList.remove("active"));                // Set active based on status                if (status === "banned") {                    steps[2].classList.add("active"); // Suspended                } else if (status === "flagged") {                    steps[1].classList.add("active"); // Flagged                } else {                    steps[0].classList.add("active"); // All good                }                return true;            };            updateSteps();        }        // Apply stored status when settings opens        document.addEventListener("click", function(e) {            // Check if settings was opened            if (e.target.closest("[onclick*=openSettings]") || e.target.id === "open-settings") {                setTimeout(() => {                    if (window.userAccountStatus) {                        updateAccountStatus(window.userAccountStatus);                    }                }, 100);            }        });

        // Analytics Dialog Variables
        let currentMemberId = null;
        let currentMemberName = null;
        let memberJoinDate = null;
        let serverDate = null;
        let chartData = [];

        function openAnalyticsDialog(memberId, memberName) {
            currentMemberId = memberId;
            currentMemberName = memberName;

            document.getElementById('analytics-dialog-title').textContent = `Analytics: ${memberName}`;
            document.getElementById('analytics-dialog-overlay').classList.add('show');

            // Reset date restrictions (will be set properly after loading info)
            const startInput = document.getElementById('analytics-start-date');
            const endInput = document.getElementById('analytics-end-date');
            startInput.min = '';
            startInput.max = '';
            endInput.min = '';
            endInput.max = '';

            // Set default date range (last 30 days) - will be adjusted after loading analytics
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 30);

            startInput.value = startDate.toISOString().split('T')[0];
            endInput.value = endDate.toISOString().split('T')[0];

            // Reset to information tab and load data
            switchAnalyticsTab('information');
        }

        function closeAnalyticsDialog() {
            document.getElementById('analytics-dialog-overlay').classList.remove('show');
            currentMemberId = null;
            currentMemberName = null;
        }

        // Close on overlay click
        document.getElementById('analytics-dialog-overlay').addEventListener('click', function(e) {
            if (e.target === this) {
                closeAnalyticsDialog();
            }
        });

        function switchAnalyticsTab(tabName) {
            // Update radio button state
            const radio = document.querySelector(`input[name="analytics-view-mode"][value="${tabName}"]`);
            if (radio) radio.checked = true;

            // Update panels
            document.querySelectorAll('.analytics-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === `panel-${tabName}`);
            });

            // Load data for the tab
            if (tabName === 'information') {
                loadAnalyticsInfo();
            } else if (tabName === 'dates') {
                loadDailyStats();
            }
        }

        async function loadAnalyticsInfo() {
            const container = document.getElementById('analytics-info-content');
            container.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';

            try {
                const response = await fetch(`/api/team/member/${currentMemberId}/analytics`);
                const data = await response.json();

                if (data.success) {
                    const analytics = data.analytics;
                    // Format date using user's preferred format
                    const joinedDate = analytics.joined_at ? formatDateWithUserFormat(analytics.joined_at) : 'Unknown';

                    // Store dates for calendar restrictions
                    memberJoinDate = analytics.joined_at ? analytics.joined_at.split('T')[0] : null;
                    serverDate = analytics.server_date || new Date().toISOString().split('T')[0];

                    // Apply date restrictions to inputs
                    const startInput = document.getElementById('analytics-start-date');
                    const endInput = document.getElementById('analytics-end-date');
                    if (memberJoinDate) {
                        startInput.min = memberJoinDate;
                        endInput.min = memberJoinDate;
                    }
                    startInput.max = serverDate;
                    endInput.max = serverDate;

                    // Adjust default date range if join date is more recent than 30 days ago
                    if (memberJoinDate && new Date(memberJoinDate) > new Date(startInput.value)) {
                        startInput.value = memberJoinDate;
                    }
                    // Adjust end date if it's after server date
                    if (serverDate && new Date(endInput.value) > new Date(serverDate)) {
                        endInput.value = serverDate;
                    }

                    // Update custom date displays to reflect the adjusted dates
                    if (typeof updateCustomDateDisplays === 'function') {
                        updateCustomDateDisplays();
                    }

                    container.innerHTML = `
                        <div class="analytics-stat-row">
                            <span class="analytics-stat-label">All-time ads sent</span>
                            <span class="analytics-stat-value">${analytics.all_time.toLocaleString()}</span>
                        </div>
                        <div class="analytics-stat-row">
                            <span class="analytics-stat-label">Current cycle ads</span>
                            <span class="analytics-stat-value">${analytics.current_cycle.toLocaleString()}</span>
                        </div>
                        <div class="analytics-stat-row">
                            <span class="analytics-stat-label">Joined team (${window.userDateFormat || 'mm/dd/yy'})</span>
                            <span class="analytics-stat-value">${joinedDate}</span>
                        </div>
                        <div class="analytics-stat-row" style="flex-direction: column; align-items: stretch;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                <span class="analytics-stat-label">Team contribution</span>
                                <span class="analytics-stat-value">${analytics.percentage}%</span>
                            </div>
                            <div class="analytics-progress-bar">
                                <div class="analytics-progress-fill" style="width: ${Math.min(analytics.percentage, 100)}%"></div>
                            </div>
                        </div>
                    `;
                } else {
                    container.innerHTML = `<div class="no-data-message">${data.error || 'Failed to load analytics'}</div>`;
                }
            } catch (error) {
                console.error('Error loading analytics:', error);
                container.innerHTML = '<div class="no-data-message">Error loading analytics</div>';
            }
        }

        // Date input change handlers to enforce restrictions
        document.getElementById('analytics-start-date').addEventListener('change', function() {
            if (memberJoinDate && this.value < memberJoinDate) {
                this.value = memberJoinDate;
            }
            if (serverDate && this.value > serverDate) {
                this.value = serverDate;
            }
            // Start date can't be after end date
            const endInput = document.getElementById('analytics-end-date');
            if (this.value > endInput.value) {
                endInput.value = this.value;
            }
        });

        document.getElementById('analytics-end-date').addEventListener('change', function() {
            if (memberJoinDate && this.value < memberJoinDate) {
                this.value = memberJoinDate;
            }
            if (serverDate && this.value > serverDate) {
                this.value = serverDate;
            }
            // End date can't be before start date
            const startInput = document.getElementById('analytics-start-date');
            if (this.value < startInput.value) {
                startInput.value = this.value;
            }
        });

        async function loadDailyStats() {
            const startDate = document.getElementById('analytics-start-date').value;
            const endDate = document.getElementById('analytics-end-date').value;
            const canvas = document.getElementById('analytics-chart');

            if (canvas) {
                // Show loading state on canvas
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                ctx.clearRect(0, 0, width, height);

                // Center the loading dots
                const loadingText = document.createElement('div');
                loadingText.style.position = 'absolute';
                loadingText.style.top = '50%';
                loadingText.style.left = '50%';
                loadingText.style.transform = 'translate(-50%, -50%)';
                loadingText.innerHTML = '<div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>';
                loadingText.id = 'analytics-chart-loading';
                canvas.parentElement.style.position = 'relative';
                canvas.parentElement.appendChild(loadingText);
            }

            try {
                const response = await fetch(`/api/team/member/${currentMemberId}/daily-stats?start_date=${startDate}&end_date=${endDate}`);
                const data = await response.json();

                if (data.success) {
                    chartData = data.data.stats || [];

                    // Update summary
                    document.getElementById('summary-total').textContent = data.data.total.toLocaleString();
                    document.getElementById('summary-avg').textContent = data.data.average.toFixed(1);
                    document.getElementById('summary-peak').textContent = data.data.peak.toLocaleString();

                    // Draw chart
                    drawChart();
                } else {
                    console.error('Failed to load daily stats:', data.error);
                }
            } catch (error) {
                console.error('Error loading daily stats:', error);
            } finally {
                // ALWAYS remove loading indicator
                const loadingEl = document.getElementById('analytics-chart-loading');
                if (loadingEl) loadingEl.remove();
            }
        }

        function applyDateRange() {
            loadDailyStats();
        }

        function drawChart() {
            const canvas = document.getElementById('analytics-chart');
            const ctx = canvas.getContext('2d');
            const wrapper = canvas.parentElement;

            // Set canvas size
            canvas.width = wrapper.offsetWidth;
            canvas.height = wrapper.offsetHeight;

            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 20, right: 20, bottom: 30, left: 40 };

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (chartData.length === 0) {
                ctx.fillStyle = '#81828A';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data for selected period', width / 2, height / 2);
                return;
            }

            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Find max value for scaling
            const maxCount = Math.max(...chartData.map(d => d.count), 1);

            // Calculate points
            const points = chartData.map((d, i) => ({
                x: padding.left + (i / (chartData.length - 1 || 1)) * chartWidth,
                y: padding.top + chartHeight - (d.count / maxCount) * chartHeight,
                date: d.date,
                count: d.count
            }));

            // Draw solid fill with opacity
            if (points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, height - padding.bottom);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.lineTo(points[points.length - 1].x, height - padding.bottom);
                ctx.closePath();
                ctx.fillStyle = 'rgba(21, 216, 188, 0.15)';
                ctx.fill();
            }

            // Draw line with round caps
            ctx.beginPath();
            ctx.strokeStyle = '#15d8bc';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            points.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            // Draw points (circles cover line completely)
            points.forEach(p => {
                // Draw background circle (border/stroke)
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#121215';
                ctx.fill();

                // Draw foreground circle (main color)
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#15d8bc';
                ctx.fill();
            });

            // Draw Y-axis labels
            ctx.fillStyle = '#81828A';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(maxCount.toString(), padding.left - 5, padding.top + 5);
            ctx.fillText('0', padding.left - 5, height - padding.bottom + 5);

            // Draw X-axis labels (first and last dates)
            if (chartData.length > 0) {
                ctx.textAlign = 'left';
                ctx.fillText(formatDateShort(chartData[0].date), padding.left, height - 5);
                ctx.textAlign = 'right';
                ctx.fillText(formatDateShort(chartData[chartData.length - 1].date), width - padding.right, height - 5);
            }

            // Store points for tooltip
            canvas.chartPoints = points;
        }

        function formatDateShort(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        // Chart tooltip
        document.addEventListener('DOMContentLoaded', function() {
            const chartCanvas = document.getElementById('analytics-chart');
            const chartTooltip = document.getElementById('chart-tooltip');

            if (chartCanvas && chartTooltip) {
                chartCanvas.addEventListener('mousemove', function(e) {
                    if (!this.chartPoints || this.chartPoints.length === 0) return;

                    const rect = this.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Find closest point
                    let closest = null;
                    let minDist = Infinity;

                    this.chartPoints.forEach(p => {
                        const dist = Math.sqrt(Math.pow(p.x - x, 2) + Math.pow(p.y - y, 2));
                        if (dist < minDist && dist < 20) {
                            minDist = dist;
                            closest = p;
                        }
                    });

                    if (closest) {
                        chartTooltip.style.display = 'block';
                        chartTooltip.innerHTML = `<strong>${closest.count}</strong><br>${formatDateShort(closest.date)}`;

                        // Position tooltip below the point
                        const tooltipHeight = chartTooltip.offsetHeight;
                        const tooltipWidth = chartTooltip.offsetWidth;

                        // Center horizontally under the point
                        let left = closest.x - (tooltipWidth / 2);
                        // Only clamp left edge (right side can overflow, chart has padding)
                        if (left < 0) left = 0;

                        // Position below the point
                        let top = closest.y + 15;
                        // If it would go off-screen below, position above instead
                        if (top + tooltipHeight > rect.height) {
                            top = closest.y - tooltipHeight - 10;
                        }

                        chartTooltip.style.left = left + 'px';
                        chartTooltip.style.top = top + 'px';
                    } else {
                        chartTooltip.style.display = 'none';
                    }
                });

                chartCanvas.addEventListener('mouseleave', function() {
                    chartTooltip.style.display = 'none';
                });
            }
        });

        // Redraw chart on window resize
        window.addEventListener('resize', function() {
            if (document.getElementById('analytics-dialog-overlay').classList.contains('show') &&
                document.getElementById('panel-dates').classList.contains('active')) {
                drawChart();
            }
            // Also redraw personal chart if on analytics page
            if (document.getElementById('page-analytics').style.display !== 'none') {
                drawPersonalChart();
            }
        });

        // Personal Analytics Chart
        let personalChartData = [];
        let personalAccountCreated = null;
        let personalServerDate = null;

        function hidePersonalAnalyticsLoading() {
            const loadingEl = document.getElementById('personal-analytics-loading');
            const contentEl = document.getElementById('personal-analytics-content');
            if (loadingEl) loadingEl.style.display = 'none';
            if (contentEl) {
                contentEl.style.opacity = '1';
                contentEl.style.pointerEvents = 'auto';
            }
        }

        // Initialize personal analytics when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Team analytics is server-rendered, just show it
            const teamLoadingEl = document.getElementById('team-analytics-loading');
            const teamContentEl = document.getElementById('team-analytics-content');
            if (teamLoadingEl) teamLoadingEl.style.display = 'none';
            if (teamContentEl) {
                teamContentEl.style.opacity = '1';
                teamContentEl.style.pointerEvents = 'auto';
            }

            setupPersonalDateHandlers();

            // Load analytics in background (non-blocking)
            loadPersonalAnalyticsAsync();
        });

        async function loadPersonalAnalyticsAsync() {
            try {
                await loadPersonalAnalyticsSummary();
                await initPersonalAnalytics();
            } catch (error) {
                console.error('Error loading personal analytics:', error);
            } finally {
                hidePersonalAnalyticsLoading();
            }
        }

        async function loadPersonalAnalyticsSummary() {
            try {
                const response = await fetch('/api/personal/analytics-summary');
                const data = await response.json();

                if (data.success) {
                    const summary = data.data;

                    // Update stat values (UI already exists in HTML)
                    document.getElementById('stat-personal-all-time').textContent = summary.personal_all_time.toLocaleString();
                    document.getElementById('stat-team-all-time').textContent = summary.team_all_time.toLocaleString();
                    document.getElementById('stat-total-all-time').textContent = summary.total_all_time.toLocaleString();

                    // Format dates using user's preferred format
                    document.getElementById('stat-peak-date-personal').textContent = formatDateWithUserFormat(summary.personal_peak_date);
                    document.getElementById('stat-peak-date-all').textContent = formatDateWithUserFormat(summary.all_peak_date);
                } else {
                    console.error('Failed to load personal analytics summary:', data.error);
                }
            } catch (error) {
                console.error('Error loading personal analytics summary:', error);
            }
        }

        async function initPersonalAnalytics() {
            const startInput = document.getElementById('personal-start-date');
            const endInput = document.getElementById('personal-end-date');

            if (!startInput || !endInput) {
                throw new Error('Personal analytics inputs not found');
            }

            try {
                const response = await fetch('/api/personal/analytics');
                const data = await response.json();

                if (data.success) {
                    personalAccountCreated = data.account_created ? data.account_created.split('T')[0] : null;
                    personalServerDate = data.server_date || new Date().toISOString().split('T')[0];

                    // Set date restrictions
                    if (personalAccountCreated) {
                        startInput.min = personalAccountCreated;
                        endInput.min = personalAccountCreated;
                    }
                    startInput.max = personalServerDate;
                    endInput.max = personalServerDate;

                    // Set default date range (last 30 days or from account creation)
                    const endDate = new Date(personalServerDate);
                    const startDate = new Date(personalServerDate);
                    startDate.setDate(startDate.getDate() - 30);

                    // Format dates as YYYY-MM-DD
                    let startValue = startDate.toISOString().split('T')[0];
                    let endValue = endDate.toISOString().split('T')[0];

                    // Adjust if account created after calculated start date
                    if (personalAccountCreated && startValue < personalAccountCreated) {
                        startValue = personalAccountCreated;
                    }
                    // Adjust if end date is after server date
                    if (endValue > personalServerDate) {
                        endValue = personalServerDate;
                    }

                    startInput.value = startValue;
                    endInput.value = endValue;

                    // Update the custom date displays
                    if (typeof updateCustomDateDisplays === 'function') {
                        updateCustomDateDisplays();
                    }

                    // Load initial data
                    await loadPersonalDailyStats();
                } else {
                    console.error('Personal analytics API error:', data.error);
                }
            } catch (error) {
                console.error('Error initializing personal analytics:', error);
            }
        }

        // Setup date input change handlers for personal analytics
        function setupPersonalDateHandlers() {
            const startInput = document.getElementById('personal-start-date');
            const endInput = document.getElementById('personal-end-date');

            if (startInput) {
                startInput.addEventListener('change', function() {
                    if (personalAccountCreated && this.value < personalAccountCreated) {
                        this.value = personalAccountCreated;
                    }
                    if (personalServerDate && this.value > personalServerDate) {
                        this.value = personalServerDate;
                    }
                    if (endInput && this.value > endInput.value) {
                        endInput.value = this.value;
                    }
                });
            }

            if (endInput) {
                endInput.addEventListener('change', function() {
                    if (personalAccountCreated && this.value < personalAccountCreated) {
                        this.value = personalAccountCreated;
                    }
                    if (personalServerDate && this.value > personalServerDate) {
                        this.value = personalServerDate;
                    }
                    if (startInput && this.value < startInput.value) {
                        startInput.value = this.value;
                    }
                });
            }
        }

        function applyPersonalDateRange() {
            loadPersonalDailyStats();
        }

        async function loadPersonalDailyStats() {
            const startDate = document.getElementById('personal-start-date').value;
            const endDate = document.getElementById('personal-end-date').value;

            try {
                const response = await fetch(`/api/personal/daily-stats?start_date=${startDate}&end_date=${endDate}`);
                const data = await response.json();

                if (data.success) {
                    personalChartData = data.data.stats || [];

                    // Update summary
                    document.getElementById('personal-summary-total').textContent = data.data.total.toLocaleString();
                    document.getElementById('personal-summary-avg').textContent = data.data.average.toFixed(1);
                    document.getElementById('personal-summary-peak').textContent = data.data.peak.toLocaleString();

                    // Draw chart
                    drawPersonalChart();
                } else {
                    console.error('Failed to load personal daily stats:', data.error);
                }
            } catch (error) {
                console.error('Error loading personal daily stats:', error);
            }
        }

        function drawPersonalChart() {
            const canvas = document.getElementById('personal-analytics-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const wrapper = canvas.parentElement;

            // Set canvas size
            canvas.width = wrapper.offsetWidth;
            canvas.height = wrapper.offsetHeight;

            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 20, right: 20, bottom: 30, left: 40 };

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (personalChartData.length === 0) {
                ctx.fillStyle = '#81828A';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data for selected period', width / 2, height / 2);
                return;
            }

            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Find max value for scaling
            const maxCount = Math.max(...personalChartData.map(d => d.count), 1);

            // Calculate points
            const points = personalChartData.map((d, i) => ({
                x: padding.left + (i / (personalChartData.length - 1 || 1)) * chartWidth,
                y: padding.top + chartHeight - (d.count / maxCount) * chartHeight,
                date: d.date,
                count: d.count
            }));

            // Draw solid fill with opacity
            if (points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, height - padding.bottom);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.lineTo(points[points.length - 1].x, height - padding.bottom);
                ctx.closePath();
                ctx.fillStyle = 'rgba(21, 216, 188, 0.15)';
                ctx.fill();
            }

            // Draw line with round caps
            ctx.beginPath();
            ctx.strokeStyle = '#15d8bc';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            points.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            // Draw points (circles cover line completely)
            points.forEach(p => {
                // Draw background circle (border/stroke)
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#121215';
                ctx.fill();

                // Draw foreground circle (main color)
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#15d8bc';
                ctx.fill();
            });

            // Draw Y-axis labels
            ctx.fillStyle = '#81828A';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(maxCount.toString(), padding.left - 5, padding.top + 5);
            ctx.fillText('0', padding.left - 5, height - padding.bottom + 5);

            // Draw X-axis labels (first and last dates)
            if (personalChartData.length > 0) {
                ctx.textAlign = 'left';
                ctx.fillText(formatDateShort(personalChartData[0].date), padding.left, height - 5);
                ctx.textAlign = 'right';
                ctx.fillText(formatDateShort(personalChartData[personalChartData.length - 1].date), width - padding.right, height - 5);
            }

            // Store points for tooltip
            canvas.chartPoints = points;
        }

        // Personal chart tooltip
        document.addEventListener('DOMContentLoaded', function() {
            const personalChartCanvas = document.getElementById('personal-analytics-chart');
            const personalChartTooltip = document.getElementById('personal-chart-tooltip');

            if (personalChartCanvas && personalChartTooltip) {
                personalChartCanvas.addEventListener('mousemove', function(e) {
                    if (!this.chartPoints || this.chartPoints.length === 0) return;

                    const rect = this.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Find closest point
                    let closest = null;
                    let minDist = Infinity;

                    this.chartPoints.forEach(p => {
                        const dist = Math.sqrt(Math.pow(p.x - x, 2) + Math.pow(p.y - y, 2));
                        if (dist < minDist && dist < 20) {
                            minDist = dist;
                            closest = p;
                        }
                    });

                    if (closest) {
                        personalChartTooltip.style.display = 'block';
                        personalChartTooltip.innerHTML = `<strong>${closest.count}</strong><br>${formatDateShort(closest.date)}`;

                        const tooltipHeight = personalChartTooltip.offsetHeight;
                        const tooltipWidth = personalChartTooltip.offsetWidth;

                        // Center horizontally under the point
                        let left = closest.x - (tooltipWidth / 2);
                        // Only clamp left edge (right side can overflow, chart has padding)
                        if (left < 0) left = 0;

                        let top = closest.y + 15;
                        if (top + tooltipHeight > rect.height) {
                            top = closest.y - tooltipHeight - 10;
                        }

                        personalChartTooltip.style.left = left + 'px';
                        personalChartTooltip.style.top = top + 'px';
                    } else {
                        personalChartTooltip.style.display = 'none';
                    }
                });

                personalChartCanvas.addEventListener('mouseleave', function() {
                    personalChartTooltip.style.display = 'none';
                });
            }
        });
    </script>

    <!-- Centralized Image Loader (additional instance for late-loaded images) -->
    <script src="{{ url_for('static', filename='image_loader.js') }}"></script>
</body>
</html>
