<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ site_config.page_titles.login }}</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="{{ get_page_description('login') }}">

    <!-- Open Graph / Facebook -->
    {% set embed = get_page_embed('login') %}
    <meta property="og:type" content="website">
    <meta property="og:title" content="{{ embed.title }}">
    <meta property="og:description" content="{{ embed.description }}">
    {% if embed.image %}
    <meta property="og:image" content="{{ url_for('static', filename=embed.image, _external=True) }}">
    {% endif %}
    <meta name="theme-color" content="{{ embed.color }}">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="{{ embed.title }}">
    <meta name="twitter:description" content="{{ embed.description }}">
    {% if embed.image %}
    <meta name="twitter:image" content="{{ url_for('static', filename=embed.image, _external=True) }}">
    {% endif %}

    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='responsive.css') }}">
    {% include 'partials/config_styles.html' %}
    <style>
        #ripple-canvas {
            position: fixed;
            top: 60px;
            left: 0;
            width: 100%;
            height: calc(100vh - 60px);
            pointer-events: none;
            z-index: 1;
        }
        .panel {
            position: relative;
            z-index: 2;
        }
        .navbar {
            position: relative;
            z-index: 1000;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .email-input {
            width: 100%;
            padding: 1rem;
            background: #212227;
            border: none;
            border-radius: 8px;
            color: #ffffff;
            font-size: 1rem;
            margin-bottom: 1rem;
        }
        .email-input:focus {
            outline: none;
        }
        .email-input::placeholder {
            color: #949BA4;
        }
        /* Override submit button to use teal gradient */
        #login-btn {
            background: linear-gradient(to bottom, #15d8bc, #006e59) !important;
            color: #121215 !important;
            border: none !important;
        }
        #login-btn:hover:not(:disabled) {
            background: linear-gradient(to bottom, #10b89e, #004e40) !important;
        }
    </style>
</head>
<body>
    <canvas id="ripple-canvas"></canvas>
    <div class="panel">
        <nav class="navbar">
            <div class="navbar-content">
                <div class="navbar-left">
                    <div class="menu-icon" id="menu-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="3" y1="12" x2="21" y2="12"></line>
                            <line x1="3" y1="6" x2="21" y2="6"></line>
                            <line x1="3" y1="18" x2="21" y2="18"></line>
                        </svg>
                    </div>
                    <div class="navbar-text">
                        <h1 class="navbar-title">Ad <span class="gradient-z">Z</span> send</h1>
                        <p class="navbar-subtitle">Login to your account</p>
                    </div>
                </div>
                <div class="nav-right">
                    <div class="auth-buttons">
                        <a href="{{ url_for('signup_page') }}" class="auth-btn signup-btn">Sign Up</a>
                    </div>
                </div>
            </div>

            <!-- Dropdown Menu -->
            <div class="dropdown-menu" id="dropdown-menu">
                <a href="{{ url_for('home') }}" class="dropdown-item">Home</a>
                <a href="{{ url_for('purchase') }}" class="dropdown-item">Purchase</a>
                <div class="dropdown-divider"></div>
                <a href="https://discord.gg/KWt6rvCukp" target="_blank" class="dropdown-item discord-item">Discord Server</a>
            </div>
        </nav>

        <div class="panel-container">
            <div class="login-container">
                <div class="token-form">
                    <h2 class="form-title">Login</h2>
                    {% if error %}
                        <div class="error-message">{{ error }}</div>
                    {% endif %}

                    <form method="POST" action="{{ url_for('login_page') }}" id="login-form">
                        <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
                        <div class="form-group-login">
                            <input type="email" name="email" class="email-input" placeholder="Enter your email address..." required>
                            <button type="submit" class="submit-btn" id="login-btn">Login</button>
                        </div>
                    </form>

                    <p style="margin-top: 1.5rem; color: #949BA4; font-size: 0.9rem; text-align: center;">
                        Don't have an account? <a href="{{ url_for('signup_page') }}" style="color: #15d8bc;">Sign up here</a>
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Dropdown menu toggle
        const menuIcon = document.getElementById('menu-icon');
        const dropdownMenu = document.getElementById('dropdown-menu');

        if (menuIcon) {
            menuIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdownMenu.classList.toggle('show');
            });
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (dropdownMenu && !dropdownMenu.contains(e.target) && menuIcon && !menuIcon.contains(e.target)) {
                dropdownMenu.classList.remove('show');
            }
        });

        // Login form loading state
        const loginForm = document.getElementById('login-form');
        const loginBtn = document.getElementById('login-btn');
        let isSubmitting = false;

        if (loginForm && loginBtn) {
            loginForm.addEventListener('submit', function(e) {
                if (isSubmitting) {
                    e.preventDefault();
                    return false;
                }

                isSubmitting = true;
                loginBtn.disabled = true;
                loginBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spinner" style="animation: spin 1s linear infinite;"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2 A10 10 0 0 1 22 12" stroke-linecap="round"></path></svg> Sending Code...';
                loginBtn.style.opacity = '0.7';
                loginBtn.style.cursor = 'not-allowed';
            });
        }

        // Liquid push effect
        (function() {
            const canvas = document.getElementById('ripple-canvas');
            const ctx = canvas.getContext('2d');
            const navbarHeight = 60;

            let mouseX = -1000;
            let mouseY = -1000;
            let particles = [];

            const isMobile = window.innerWidth <= 768;
            const particleCount = isMobile ? 200 : 600;
            const pushRadius = isMobile ? 60 : 80;
            const pushStrength = 0.15;
            const connectionDistance = isMobile ? 40 : 60;

            // Get proper viewport dimensions accounting for mobile browsers
            function getViewportHeight() {
                if (window.visualViewport) {
                    return window.visualViewport.height;
                }
                return window.innerHeight;
            }

            // Track last known dimensions and zoom level
            let lastWidth = 0;
            let lastHeight = 0;
            let lastDpr = window.devicePixelRatio || 1;

            function resizeCanvas() {
                const cssWidth = window.innerWidth;
                const cssHeight = getViewportHeight() - navbarHeight;
                const currentDpr = window.devicePixelRatio || 1;

                // Check if dimensions or zoom level actually changed
                const dimensionsChanged = Math.abs(cssWidth - lastWidth) > 1 || Math.abs(cssHeight - lastHeight) > 1;
                const zoomChanged = Math.abs(currentDpr - lastDpr) > 0.01;

                if (!dimensionsChanged && !zoomChanged) {
                    return;
                }

                lastWidth = cssWidth;
                lastHeight = cssHeight;
                lastDpr = currentDpr;

                canvas.width = cssWidth;
                canvas.height = cssHeight;
                canvas.style.width = cssWidth + 'px';
                canvas.style.height = cssHeight + 'px';

                // Always reinitialize particles on resize/zoom
                initParticles();
            }

            class Particle {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.originX = this.x;
                    this.originY = this.y;
                    this.vx = 0;
                    this.vy = 0;
                    this.radius = Math.random() * 2 + 1;
                    this.opacity = Math.random() * 0.3 + 0.1;
                }

                update() {
                    const dx = this.x - mouseX;
                    const dy = this.y - mouseY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < pushRadius && distance > 0) {
                        const force = (pushRadius - distance) / pushRadius;
                        const angle = Math.atan2(dy, dx);
                        this.vx += Math.cos(angle) * force * pushStrength;
                        this.vy += Math.sin(angle) * force * pushStrength;
                    }

                    const returnSpeed = 0.02;
                    this.vx += (this.originX - this.x) * returnSpeed;
                    this.vy += (this.originY - this.y) * returnSpeed;

                    this.vx *= 0.92;
                    this.vy *= 0.92;

                    this.x += this.vx;
                    this.y += this.vy;
                }

                draw() {
                    const displacement = Math.sqrt(
                        Math.pow(this.x - this.originX, 2) +
                        Math.pow(this.y - this.originY, 2)
                    );
                    const glowOpacity = Math.min(this.opacity + displacement * 0.01, 0.6);

                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${glowOpacity})`;
                    ctx.fill();

                    if (!isMobile) {
                        particles.forEach(other => {
                            if (other === this) return;
                            const dx = other.x - this.x;
                            const dy = other.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < connectionDistance) {
                                ctx.beginPath();
                                ctx.moveTo(this.x, this.y);
                                ctx.lineTo(other.x, other.y);
                                ctx.strokeStyle = `rgba(255, 255, 255, ${0.05 * (1 - dist / connectionDistance)})`;
                                ctx.lineWidth = 0.5;
                                ctx.stroke();
                            }
                        });
                    }
                }
            }

            function initParticles() {
                particles = [];
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle());
                }
            }

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('load', resizeCanvas);

            document.addEventListener('mousemove', function(e) {
                if (e.clientY > navbarHeight) {
                    mouseX = e.clientX;
                    mouseY = e.clientY - navbarHeight;
                } else {
                    mouseX = -1000;
                    mouseY = -1000;
                }
            });

            document.addEventListener('touchmove', function(e) {
                const touch = e.touches[0];
                if (touch.clientY > navbarHeight) {
                    mouseX = touch.clientX;
                    mouseY = touch.clientY - navbarHeight;
                }
            }, { passive: true });

            document.addEventListener('touchstart', function(e) {
                const touch = e.touches[0];
                if (touch.clientY > navbarHeight) {
                    mouseX = touch.clientX;
                    mouseY = touch.clientY - navbarHeight;
                }
            }, { passive: true });

            document.addEventListener('touchend', function() {
                mouseX = -1000;
                mouseY = -1000;
            });

            document.addEventListener('mouseleave', function() {
                mouseX = -1000;
                mouseY = -1000;
            });

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });
                requestAnimationFrame(animate);
            }

            animate();
        })();
    </script>
</body>
</html>
