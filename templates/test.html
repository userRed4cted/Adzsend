<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Panel - New Design</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='responsive.css') }}">
    {% include 'partials/config_styles.html' %}
    <script src="{{ url_for('static', filename='tab_enforcement.js') }}"></script>
    <script src="{{ url_for('static', filename='status_polling.js') }}"></script>
    <script>
        window.DB_VERSION = {{ db_version }};
        window.DB_WIPE_MESSAGE = "{{ db_wipe_message }}";
    </script>
    <script src="{{ url_for('static', filename='db_wipe_notice.js') }}"></script>
    <script src="{{ url_for('static', filename='custom_modals.js') }}"></script>
    <style>
        /* Prevent page scrolling */
        body {
            overflow: hidden;
            height: 100vh;
        }

        .panel {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* New panel design - wrapper for side menu + content */
        .test-panel-container {
            padding: 1rem;
            flex: 1;
            overflow: hidden;
        }

        .test-main-frame {
            background: transparent;
            border: 1px solid #222225;
            border-radius: 12px;
            display: flex;
            height: 100%;
            overflow: hidden;
        }

        /* Side menu */
        .side-menu {
            width: 240px;
            background: #1A1A1E;
            border-right: 1px solid #222225;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            gap: 1rem;
            flex-shrink: 0;
        }

        /* Discord profile section */
        .profile-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .profile-card {
            background: transparent;
            border-radius: 8px;
            padding: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
        }

        .profile-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: visible;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2a2a30;
            position: relative;
        }

        .profile-avatar img.avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }

        .profile-avatar .avatar-decoration {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120%;
            height: 120%;
            pointer-events: none;
            z-index: 1;
        }

        .profile-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .profile-name {
            color: #dcddde;
            font-weight: 500;
            font-size: 0.9rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            line-height: 1.2;
            margin: 0;
        }

        .change-account-text {
            color: #81828A;
            font-size: 0.75rem;
            line-height: 1.2;
            margin: 0;
        }

        /* Menu sections */
        .menu-section {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .menu-category {
            color: #81828A;
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            padding: 0.25rem 0.75rem;
            margin-top: 0.25rem;
        }

        .menu-category:first-child {
            margin-top: 0;
        }

        .menu-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-radius: 6px;
            color: #dcddde;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            background: transparent;
            border: none;
            width: 100%;
            text-align: left;
        }

        .menu-item.active {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
            color: #121215;
        }

        .menu-divider {
            height: 1px;
            background: rgba(255,255,255,0.05);
            margin: 0.25rem 0;
        }

        /* Main content wrapper - takes up remaining space */
        .main-content-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: visible;
            min-width: 0;
        }

        /* Custom radio button styling matching settings.html */
        input[type="radio"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid #15d8bc;
            border-radius: 50%;
            background: transparent;
            cursor: pointer;
            position: relative;
        }
        input[type="radio"]:checked {
            background: #15d8bc;
            border-color: #15d8bc;
        }
        input[type="radio"]:checked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: #fff;
            border-radius: 50%;
        }
        input[type="radio"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Override main-layout for test panel - add divider */
        .main-content-wrapper .main-layout {
            display: flex;
            gap: 0;
            height: 100%;
        }

        .main-content-wrapper .main-layout .selection-panel {
            flex: 1;
            margin: 0;
            padding: 0;
            background: transparent;
            border-radius: 0;
        }

        .main-content-wrapper .main-layout .action-panel {
            flex: 1;
            margin: 0.75rem;
        }

        /* Vertical divider between panels */
        .panel-divider {
            width: 1px;
            background: #222225;
            margin: 0;
            flex-shrink: 0;
        }

        /* View mode toggle - centered */
        .view-mode-toggle {
            display: flex;
            gap: 1.5rem;
            padding: 0.5rem 0.5rem;
            justify-content: center;
            margin-top: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .view-mode-toggle label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .view-mode-toggle span {
            color: #dcddde;
            font-weight: 500;
            font-size: 0.85rem;
        }

        /* Selected channels mode - channels list with x.png for remove */
        .selected-channels-mode .channels-list .channel-item .channel-tick {
            content: url("{{ url_for('static', filename='x.png') }}");
        }

        /* Reduced height searchbar for selection panel */
        .selection-panel .search-input {
            padding: 0.35rem 0.75rem;
            padding-left: 2.5rem;
            font-size: 0.85rem;
            width: 100%;
            box-sizing: border-box;
            color: #81828A;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            background-color: #1A1A1E;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%2381828A' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: 0.75rem center;
            background-size: 16px 16px;
            border: 1px solid #222225;
            border-radius: 8px;
        }

        /* Full-width channels list with horizontal padding to match searchbar */
        .selection-panel .channels-list {
            padding: 0 0.5rem;
            margin: 0;
            border-radius: 0;
        }

        .selection-panel .channels-list .channel-item {
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            border-radius: 4px;
        }

        .selection-panel .channels-section,
        .selection-panel .channels-only-section {
            padding: 0;
            margin: 0;
            border-radius: 0;
        }

        .selection-panel .unified-header {
            padding: 0 0.5rem;
            margin-bottom: 0.25rem;
        }

        /* Fixed height for both headers to prevent rescaling */
        .selection-panel .servers-mode-header,
        .selection-panel .channels-only-header {
            min-height: 2.5rem;
        }

        .selection-panel .servers-mode-header .header-section,
        .selection-panel .channels-only-header .header-section {
            width: 100%;
        }

        .selection-panel .channels-search {
            width: 100%;
        }

        /* Discord-style server sidebar on far left */
        .server-sidebar {
            width: 72px;
            background: transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem 0;
            gap: 0.5rem;
            overflow-y: auto;
            overflow-x: visible;
            flex-shrink: 0;
            position: relative;
        }

        .server-sidebar::-webkit-scrollbar {
            width: 0;
        }

        .server-icon-wrapper {
            position: relative;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .server-icon-pill {
            position: absolute;
            left: -12px;
            width: 4px;
            background: #FBFBFB;
            border-radius: 0 4px 4px 0;
            transition: height 0.15s ease-out, opacity 0.15s ease-out;
            height: 0;
            opacity: 0;
        }

        .server-icon-wrapper:hover .server-icon-pill {
            height: 20px;
            opacity: 1;
        }

        .server-icon-wrapper.active .server-icon-pill {
            height: 40px;
            opacity: 1;
        }

        .server-icon-holder {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #1A1A1E;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: border-radius 0.15s ease-out;
        }

        .server-icon-wrapper:hover .server-icon-holder {
            border-radius: 16px;
        }

        .server-icon-wrapper.active .server-icon-holder {
            border-radius: 16px;
        }

        .server-icon-holder img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .server-icon-placeholder {
            color: #dcddde;
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* Divider between content and server sidebar */
        .server-sidebar-divider {
            width: 1px;
            background: #222225;
            margin: 0;
            flex-shrink: 0;
        }

        /* Discord-style channel list overrides */
        .channels-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 0 0.5rem;
        }

        .channels-list .channel-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            border: none;
            transition: none;
        }

        .channels-list .channel-item:hover {
            transform: none;
            background: #1A1A1E;
        }

        .channels-list .channel-item:hover .channel-hash,
        .channels-list .channel-item:hover .channel-name {
            color: #fff;
        }

        .channels-list .channel-item.selected {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
            border: none;
            box-shadow: none;
        }

        .channels-list .channel-item.selected:hover {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
        }

        .channels-list .channel-item .channel-hash {
            color: #81828A;
            font-size: 1rem;
            font-weight: 500;
            flex-shrink: 0;
        }

        .channels-list .channel-item.selected .channel-hash {
            color: #121215;
        }

        .channels-list .channel-item .channel-name {
            color: #81828A;
            font-size: 0.9rem;
            font-weight: 500;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .channels-list .channel-item.selected .channel-name {
            color: #121215;
        }

        .channels-list .channel-item .channel-tick {
            display: none;
            width: 22px;
            height: 22px;
            flex-shrink: 0;
            filter: brightness(0) saturate(100%);
            margin-left: auto;
        }

        /* Keep x.png at smaller size */
        .channels-list .channel-item .channel-tick[alt="x"] {
            width: 11px;
            height: 11px;
        }

        .channels-list .channel-item.selected .channel-tick {
            display: block;
        }

        /* Failed channel status tag */
        .channels-list .channel-item .channel-status-tag {
            display: none;
            background: #121215;
            color: #81828A;
            font-size: 0.65rem;
            font-weight: 500;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            white-space: nowrap;
            width: 90px;
            text-align: center;
            margin-left: auto;
            flex-shrink: 0;
        }

        .channels-list .channel-item.failed .channel-status-tag {
            display: block;
        }

        /* Failed channel styling - red gradient background */
        .channels-list .channel-item.failed {
            background: linear-gradient(to bottom, #991a35, #6b1226);
        }

        .channels-list .channel-item.failed:hover {
            background: linear-gradient(to bottom, #991a35, #6b1226);
        }

        .channels-list .channel-item.failed .channel-hash,
        .channels-list .channel-item.failed .channel-name {
            color: #121215;
        }

        .channels-list .channel-item.failed .channel-tick {
            display: block;
            filter: brightness(0) saturate(100%);
        }

        /* Server icon for channels-only mode */
        .channels-list .channel-item .server-icon-small {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            flex-shrink: 0;
            object-fit: cover;
        }

        .channels-list .channel-item .server-icon-placeholder-small {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #5865f2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            font-weight: 600;
            flex-shrink: 0;
        }

        /* Keep server icon unchanged when selected */
        .channels-list .channel-item.selected .server-icon-small,
        .channels-list .channel-item.selected .server-icon-placeholder-small {
            /* No changes - keep original appearance */
        }
    </style>
</head>
<body>
    <div class="panel">
        <nav class="navbar">
            <div class="navbar-content">
                <div class="navbar-left">
                    <div class="menu-icon" id="menu-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="3" y1="12" x2="21" y2="12"></line>
                            <line x1="3" y1="6" x2="21" y2="6"></line>
                            <line x1="3" y1="18" x2="21" y2="18"></line>
                        </svg>
                    </div>
                    <div class="navbar-text">
                        <h1 class="navbar-title">Ad <span class="gradient-z">Z</span> send</h1>
                        <p class="navbar-subtitle">Select in which servers and channels you would like to automate your marketing</p>
                    </div>
                </div>
                <div class="nav-right"></div>
            </div>

            <!-- Dropdown Menu -->
            <div class="dropdown-menu" id="dropdown-menu">
                <a href="{{ url_for('home') }}" class="dropdown-item">Home</a>
                <a href="{{ url_for('panel') }}" class="dropdown-item">Personal Panel</a>
                <a href="{{ url_for('settings') }}" class="dropdown-item">Settings</a>
                <div class="dropdown-divider"></div>
                <a href="https://discord.gg/KWt6rvCukp" target="_blank" class="dropdown-item discord-item">Discord Server</a>
                <a href="{{ url_for('logout') }}" class="dropdown-item logout-item">Logout</a>
            </div>
        </nav>

        <div class="test-panel-container">
            <div class="test-main-frame">
                <!-- Side Menu -->
                <div class="side-menu">
                    <!-- Discord Profile -->
                    <div class="profile-section">
                        {% if discord_linked and discord_info %}
                        <div class="profile-card">
                            <div class="profile-avatar">
                                {% if discord_info.avatar %}
                                <img class="avatar-img" src="https://cdn.discordapp.com/avatars/{{ discord_info.id }}/{{ discord_info.avatar }}.png?size=128" alt="Avatar">
                                {% else %}
                                <img class="avatar-img" src="https://cdn.discordapp.com/embed/avatars/{{ discord_info.discriminator|int % 5 }}.png" alt="Default Avatar">
                                {% endif %}
                                {% if discord_info.avatar_decoration_data and discord_info.avatar_decoration_data.asset %}
                                <img class="avatar-decoration" src="https://cdn.discordapp.com/avatar-decoration-presets/{{ discord_info.avatar_decoration_data.asset }}.png?size=160&passthrough=true" alt="">
                                {% endif %}
                            </div>
                            <div class="profile-info">
                                <div class="profile-name">{{ discord_info.username }}</div>
                                <div class="change-account-text">Change account</div>
                            </div>
                        </div>
                        {% else %}
                        <div class="profile-card">
                            <div class="profile-info">
                                <div class="profile-name">No Discord Account</div>
                                <div class="change-account-text">Change account</div>
                            </div>
                        </div>
                        {% endif %}
                    </div>

                    <!-- Menu Items -->
                    <div class="menu-section">
                        <div class="menu-category">Main</div>

                        <button class="menu-item active" data-page="personal-panel">
                            Personal panel
                        </button>

                        <button class="menu-item" data-page="team-panel">
                            Team panel
                        </button>

                        <div class="menu-divider"></div>

                        <div class="menu-category">Management</div>

                        <button class="menu-item" data-page="team-management">
                            Team management
                        </button>

                        <button class="menu-item" data-page="analytics">
                            Analytics
                        </button>

                        <div class="menu-divider"></div>

                        <div class="menu-category">Settings</div>

                        <button class="menu-item" data-page="interval">
                            Interval
                        </button>
                    </div>
                </div>

                <!-- Main Content Area (uses styles.css classes) -->
                <div class="main-content-wrapper">
                    {% if guilds %}
                    <div class="main-layout" style="height: 100%;">
                        <!-- Left: Discord-style Server Sidebar -->
                        <div class="server-sidebar" id="server-sidebar">
                            <!-- Server icons will be populated by JavaScript -->
                        </div>

                        <!-- Divider after server sidebar -->
                        <div class="server-sidebar-divider"></div>

                        <!-- Channel Selection -->
                        <div class="selection-panel">
                            <!-- View Mode Toggle with Radio Buttons - Centered -->
                            <div class="view-mode-toggle">
                                <label>
                                    <input type="radio" name="view-mode" value="servers" checked>
                                    <span>Selected server</span>
                                </label>
                                <label>
                                    <input type="radio" name="view-mode" value="channels">
                                    <span>All channels</span>
                                </label>
                                <label>
                                    <input type="radio" name="view-mode" value="selected">
                                    <span>Selected channels</span>
                                </label>
                            </div>

                            <!-- Channels Header (Servers Mode) -->
                            <div class="unified-header servers-mode-header">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="channel-search" class="search-input" placeholder="Search (press enter to add tag)">
                                        <div class="search-tags" id="search-tags"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Channels Only Mode Header -->
                            <div class="unified-header channels-only-header" style="display: none;">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="channels-only-search" class="search-input" placeholder="Search (press enter to add tag)">
                                        <div class="search-tags" id="channels-only-search-tags"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Channels List (Servers Mode) -->
                            <div class="channels-section servers-mode-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                                <div id="channels-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="no-selection">Select a server to view channels</div>
                                </div>
                            </div>

                            <!-- Channels Only List (Channels Only Mode) -->
                            <div class="channels-only-section" style="display: none; flex: 1; flex-direction: column; min-height: 0;">
                                <div id="channels-only-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>
                                </div>
                            </div>

                            <!-- Selected Channels Mode Header -->
                            <div class="unified-header selected-channels-mode-header" style="display: none;">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="selected-channels-mode-search" class="search-input" placeholder="Search">
                                    </div>
                                </div>
                            </div>

                            <!-- Selected Channels Mode List -->
                            <div class="selected-channels-mode-section" style="display: none; flex: 1; flex-direction: column; min-height: 0;">
                                <div id="selected-channels-mode-list" class="channels-list selected-channels-mode" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="no-selection">No channels selected</div>
                                </div>
                            </div>
                        </div>

                        <!-- Vertical Divider -->
                        <div class="panel-divider"></div>

                        <!-- Middle: Message Composer Only -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; background: transparent; padding: 0 0.75rem; padding-top: 2.75rem; border: none; box-sizing: border-box;">
                            <!-- Message Composer -->
                            <div class="message-section" style="display: flex; flex-direction: column; width: 100%; flex: 1; min-height: 0;">
                                <div class="message-input-container" style="flex: 1; display: flex; flex-direction: column; background: #1A1A1E; border: 1px solid #222225; border-radius: 8px; position: relative; min-height: 0;">
                                    <!-- Emoji button - top right corner -->
                                    <button id="emoji-btn" type="button" style="position: absolute; top: 8px; right: 8px; background: transparent; border: none; cursor: pointer; padding: 0; z-index: 2;">
                                        <img src="{{ url_for('static', filename='emojimain.png') }}" alt="Emoji" style="width: 20px; height: 20px; opacity: 0.7;">
                                    </button>
                                    <!-- Character count - bottom right corner -->
                                    <span id="char-count" style="position: absolute; bottom: 8px; right: 8px; color: #81828A; font-size: 0.85rem; font-weight: 500; z-index: 1; pointer-events: none;">2000</span>
                                    <!-- Textarea with padding barriers for emoji (top-right) and counter (bottom-right) -->
                                    <textarea id="message-input" class="message-input" placeholder="Message" style="flex: 1; width: 100%; padding: 8px; padding-top: 8px; padding-right: 40px; padding-bottom: 32px; background: transparent; border: none; color: #dcddde; font-size: 0.9rem; resize: none; box-sizing: border-box; line-height: 1.4; vertical-align: top;"></textarea>
                                </div>
                                <div class="message-footer" style="flex-shrink: 0; padding: 0.75rem 0;">
                                    <button id="send-btn" class="send-button" disabled style="width: 100%; justify-content: center;">
                                        Send
                                    </button>
                                </div>
                            </div>
                        </div>

                    </div>
                    {% else %}
                        {% if not discord_linked %}
                        <!-- No Discord account linked -->
                        <div class="empty-state" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%;">
                            <h2 style="color: #dcddde; font-size: 1.5rem; margin-bottom: 1rem;">No Discord account linked</h2>
                            <button class="discord-btn" onclick="window.location.href='{{ url_for('settings') }}'" style="padding: 0.75rem 1.5rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                                </svg>
                                Link Discord Account
                            </button>
                        </div>
                        {% else %}
                        <!-- Discord linked but no servers -->
                        <div class="empty-state" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%;">
                            <h2 style="color: #dcddde; font-size: 1.5rem;">Not in any Discord servers with linked account</h2>
                        </div>
                        {% endif %}
                    {% endif %}
                </div>
            </div>
        </div>
    </div>

    <!-- Tag Limit Popup Modal -->
    <div id="tag-limit-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: #191A1F; border-radius: 12px; padding: 1.5rem; max-width: 400px; width: 90%; text-align: center; display: flex; flex-direction: column; gap: 1rem;">
            <h2 style="color: #dcddde; margin: 0; font-size: 1.25rem;">Tag limit reached</h2>
            <p style="color: #81828A; margin: 0; font-size: 0.9rem;">Maximum 6 tags allowed. Please remove a tag before adding a new one.</p>
            <button class="grey-btn" onclick="closeTagLimitModal()" style="padding: 0.6rem 2rem;">OK</button>
        </div>
    </div>

    <!-- Channel Limit Per Server Modal -->
    <div id="channel-limit-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: #191A1F; border-radius: 12px; padding: 1.5rem; max-width: 400px; width: 90%; text-align: center; display: flex; flex-direction: column; gap: 1rem;">
            <h2 style="color: #dcddde; margin: 0; font-size: 1.25rem;">Channel limit reached</h2>
            <p id="channel-limit-message" style="color: #81828A; margin: 0; font-size: 0.9rem;">You can only select up to X channels per server on your current plan.</p>
            <button class="grey-btn" onclick="closeChannelLimitModal()" style="padding: 0.6rem 2rem;">OK</button>
        </div>
    </div>

    <script>
        // Tag Limit Modal functions
        function showTagLimitModal() {
            document.getElementById('tag-limit-modal').style.display = 'flex';
        }

        function closeTagLimitModal() {
            document.getElementById('tag-limit-modal').style.display = 'none';
        }

        // Channel Limit Modal functions
        function showChannelLimitModal(limit) {
            document.getElementById('channel-limit-message').textContent =
                `You can only select up to ${limit} channel${limit !== 1 ? 's' : ''} per server on your current plan.`;
            document.getElementById('channel-limit-modal').style.display = 'flex';
        }

        function closeChannelLimitModal() {
            document.getElementById('channel-limit-modal').style.display = 'none';
        }

        // Close modals when clicking outside
        document.getElementById('tag-limit-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeTagLimitModal();
            }
        });
        document.getElementById('channel-limit-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeChannelLimitModal();
            }
        });
        // Prevent page from being stored in cache
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                window.location.reload();
            }
        });

        // Wait for all elements to load before initializing
        document.addEventListener('DOMContentLoaded', function() {
            const serverSidebar = document.getElementById('server-sidebar');
            const channelsList = document.getElementById('channels-list');
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const charCount = document.getElementById('char-count');
            const channelSearch = document.getElementById('channel-search');
            const searchTagsContainer = document.getElementById('search-tags');
            const MESSAGE_LIMIT = 2000; // Character limit for messages

            let guilds = [];
            let serverChannels = {}; // Cache for channels by guild ID
            let selectedChannels = []; // Array for multiple channel selection
            let selectedGuild = null; // Currently selected guild
            let searchTags = []; // Search filter tags
            let currentServerColor = 'rgba(21, 216, 188, 0.6)'; // Current server's dominant color
            let isSending = false; // Track if messages are being sent
            let failedChannels = new Map(); // Track channels that failed to send with failure type
            let viewMode = 'servers'; // 'servers', 'channels', or 'selected'
            let channelsOnlySearchText = ''; // Search filter for channels-only mode
            let channelsOnlySearchTags = []; // Search filter tags for channels-only mode
            let selectedChannelsModeSearchText = ''; // Search filter for selected channels mode
            const maxChannelsPerServer = {{ plan_status.max_channels_per_server if plan_status and plan_status.max_channels_per_server is defined else 2 }}; // -1 = unlimited

            // View mode toggle elements
            const viewModeRadios = document.querySelectorAll('input[name="view-mode"]');
            const serversModeHeader = document.querySelector('.servers-mode-header');
            const channelsOnlyHeader = document.querySelector('.channels-only-header');
            const selectedChannelsModeHeader = document.querySelector('.selected-channels-mode-header');
            const serversModeSections = document.querySelectorAll('.servers-mode-section');
            const channelsOnlySection = document.querySelector('.channels-only-section');
            const selectedChannelsModeSection = document.querySelector('.selected-channels-mode-section');
            const channelsOnlyList = document.getElementById('channels-only-list');
            const selectedChannelsModeList = document.getElementById('selected-channels-mode-list');
            const channelsOnlySearch = document.getElementById('channels-only-search');
            const selectedChannelsModeSearch = document.getElementById('selected-channels-mode-search');
            const channelsOnlySearchTagsContainer = document.getElementById('channels-only-search-tags');

            // View mode toggle handler (radio buttons)
            viewModeRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    const mode = radio.value;
                    if (mode === viewMode) return;

                    viewMode = mode;

                    // Hide all headers and sections first
                    serversModeHeader.style.display = 'none';
                    channelsOnlyHeader.style.display = 'none';
                    selectedChannelsModeHeader.style.display = 'none';
                    serversModeSections.forEach(s => s.style.display = 'none');
                    channelsOnlySection.style.display = 'none';
                    selectedChannelsModeSection.style.display = 'none';

                    // Show the appropriate mode
                    if (mode === 'servers') {
                        serversModeHeader.style.display = '';
                        serversModeSections.forEach(s => s.style.display = '');
                    } else if (mode === 'channels') {
                        channelsOnlyHeader.style.display = '';
                        channelsOnlySection.style.display = 'flex';
                        renderChannelsOnlyMode();
                    } else if (mode === 'selected') {
                        selectedChannelsModeHeader.style.display = '';
                        selectedChannelsModeSection.style.display = 'flex';
                        renderSelectedChannelsMode();
                    }
                });
            });

            // Selected channels mode search handler
            if (selectedChannelsModeSearch) {
                selectedChannelsModeSearch.addEventListener('input', (e) => {
                    selectedChannelsModeSearchText = e.target.value.toLowerCase();
                    renderSelectedChannelsMode();
                });
            }

            // Render channels in selected channels mode (shows selected channels with x.png to remove)
            function renderSelectedChannelsMode() {
                if (!selectedChannelsModeList) return;

                if (selectedChannels.length === 0) {
                    selectedChannelsModeList.innerHTML = '<div class="no-selection">No channels selected</div>';
                    return;
                }

                // Filter by search text
                let filteredChannels = selectedChannels;
                if (selectedChannelsModeSearchText) {
                    filteredChannels = selectedChannels.filter(ch =>
                        ch.name.toLowerCase().includes(selectedChannelsModeSearchText) ||
                        ch.guildName.toLowerCase().includes(selectedChannelsModeSearchText)
                    );
                }

                if (filteredChannels.length === 0) {
                    selectedChannelsModeList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                selectedChannelsModeList.innerHTML = filteredChannels.map(channel => {
                    const iconUrl = channel.guildIcon
                        ? `https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png`
                        : null;

                    const serverIconHtml = iconUrl
                        ? `<img class="server-icon-small" src="${iconUrl}" alt="">`
                        : `<div class="server-icon-placeholder-small">${channel.guildName[0].toUpperCase()}</div>`;

                    // Check if channel failed
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    const failedInfo = failedChannels.get(channelKey);
                    const isFailed = !!failedInfo;
                    const failedClass = isFailed ? ' failed' : '';
                    const statusText = failedInfo?.type === 'ratelimit' ? 'Rate limited' : 'Missing permission';
                    const statusTagHtml = isFailed ? `<span class="channel-status-tag">${statusText}</span>` : '';

                    return `
                        <div class="channel-item selected${failedClass}"
                             data-channel-id="${channel.id}"
                             data-channel-name="${channel.name}"
                             data-guild-id="${channel.guildId}"
                             data-guild-name="${channel.guildName}"
                             data-guild-icon="${channel.guildIcon || ''}">
                            ${serverIconHtml}
                            <span class="channel-hash">#</span>
                            <span class="channel-name">${channel.name}</span>
                            ${statusTagHtml}
                            <img class="channel-tick" src="{{ url_for('static', filename='x.png') }}" alt="x">
                        </div>
                    `;
                }).join('');

                // Add click handlers to remove channels
                selectedChannelsModeList.querySelectorAll('.channel-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const channelId = item.dataset.channelId;
                        const guildId = item.dataset.guildId;

                        // Remove from selected channels
                        selectedChannels = selectedChannels.filter(ch =>
                            !(ch.id === channelId && ch.guildId === guildId)
                        );

                        saveSelectedChannels();
                        renderSelectedChannelsMode();
                        updateServerCount(guildId);
                        updateSendButton();

                        // Also update other views if they exist
                        if (selectedGuild && selectedGuild.id === guildId) {
                            renderChannels();
                        }
                    });
                });
            }

            // Channels-only search handler
            if (channelsOnlySearch) {
                channelsOnlySearch.addEventListener('input', (e) => {
                    channelsOnlySearchText = e.target.value.toLowerCase();
                    renderChannelsOnlyMode();
                });
                channelsOnlySearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && channelsOnlySearch.value.trim()) {
                        addChannelsOnlySearchTag(channelsOnlySearch.value);
                    }
                });
            }

            // Add search tag for channels-only mode
            function addChannelsOnlySearchTag(text) {
                if (channelsOnlySearchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                if (!channelsOnlySearchTags.includes(text.toLowerCase()) && text.trim()) {
                    channelsOnlySearchTags.push(text.toLowerCase());
                    updateChannelsOnlySearchTagsDisplay();
                    channelsOnlySearch.value = '';
                    channelsOnlySearchText = '';
                    renderChannelsOnlyMode();
                }
            }

            // Remove search tag for channels-only mode
            function removeChannelsOnlySearchTag(tag) {
                channelsOnlySearchTags = channelsOnlySearchTags.filter(t => t !== tag);
                updateChannelsOnlySearchTagsDisplay();
                renderChannelsOnlyMode();
            }

            // Update search tags display for channels-only mode
            function updateChannelsOnlySearchTagsDisplay() {
                if (!channelsOnlySearchTagsContainer) return;
                channelsOnlySearchTagsContainer.innerHTML = '';
                channelsOnlySearchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}">✕</span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        removeChannelsOnlySearchTag(tag);
                    });
                    channelsOnlySearchTagsContainer.appendChild(tagEl);
                });
            }

            // Render channels in channels-only mode (with server icons)
            function renderChannelsOnlyMode() {
                if (!channelsOnlyList) return;

                // Check if any channels have been loaded
                const hasLoadedChannels = Object.keys(serverChannels).length > 0;

                // Collect all channels from all servers
                let allChannels = [];
                for (const guild of guilds) {
                    const channels = serverChannels[guild.id] || [];
                    for (const channel of channels) {
                        allChannels.push({
                            ...channel,
                            guildId: guild.id,
                            guildName: guild.name,
                            guildIcon: guild.icon
                        });
                    }
                }

                // Filter by search tags (OR logic - any tag matches)
                if (channelsOnlySearchTags.length > 0) {
                    allChannels = allChannels.filter(ch =>
                        channelsOnlySearchTags.some(tag =>
                            ch.name.toLowerCase().includes(tag) ||
                            ch.guildName.toLowerCase().includes(tag)
                        )
                    );
                }

                // Filter by search text
                if (channelsOnlySearchText) {
                    allChannels = allChannels.filter(ch =>
                        ch.name.toLowerCase().includes(channelsOnlySearchText) ||
                        ch.guildName.toLowerCase().includes(channelsOnlySearchText)
                    );
                }

                if (allChannels.length === 0) {
                    if (!hasLoadedChannels) {
                        // Channels haven't been loaded yet - show loading message
                        channelsOnlyList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';
                    } else if (channelsOnlySearchText || channelsOnlySearchTags.length > 0) {
                        // Channels loaded but filtered to empty
                        channelsOnlyList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    } else {
                        // Channels loaded but none available
                        channelsOnlyList.innerHTML = '<div class="no-selection">No channels found</div>';
                    }
                    return;
                }

                channelsOnlyList.innerHTML = allChannels.map(channel => {
                    const isSelected = selectedChannels.some(ch => ch.id === channel.id);
                    const iconUrl = channel.guildIcon
                        ? `https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png`
                        : null;

                    const serverIconHtml = iconUrl
                        ? `<img class="server-icon-small" src="${iconUrl}" alt="">`
                        : `<div class="server-icon-placeholder-small">${channel.guildName[0].toUpperCase()}</div>`;

                    // Check if channel failed
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    const failedInfo = failedChannels.get(channelKey);
                    const isFailed = isSelected && !!failedInfo;
                    const failedClass = isFailed ? ' failed' : '';
                    const statusText = failedInfo?.type === 'ratelimit' ? 'Rate limited' : 'Missing permission';
                    const statusTagHtml = isFailed ? `<span class="channel-status-tag">${statusText}</span>` : '';

                    return `
                        <div class="channel-item ${isSelected ? 'selected' : ''}${failedClass}"
                             data-channel-id="${channel.id}"
                             data-channel-name="${channel.name}"
                             data-guild-id="${channel.guildId}"
                             data-guild-name="${channel.guildName}"
                             data-guild-icon="${channel.guildIcon || ''}">
                            ${serverIconHtml}
                            <span class="channel-hash">#</span>
                            <span class="channel-name">${channel.name}</span>
                            ${statusTagHtml}
                            <img class="channel-tick" src="{{ url_for('static', filename='tick.png') }}" alt="✓">
                        </div>
                    `;
                }).join('');

                // Add click handlers
                channelsOnlyList.querySelectorAll('.channel-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const channelId = item.dataset.channelId;
                        const channelName = item.dataset.channelName;
                        const guildId = item.dataset.guildId;
                        const guildName = item.dataset.guildName;
                        const guildIcon = item.dataset.guildIcon;

                        toggleChannelSelection({
                            id: channelId,
                            name: channelName,
                            guildId: guildId,
                            guildName: guildName,
                            guildIcon: guildIcon
                        });

                        // Update selection state (no glow effects)
                        const isNowSelected = selectedChannels.some(ch => ch.id === channelId);
                        if (isNowSelected) {
                            item.classList.add('selected');
                        } else {
                            item.classList.remove('selected');
                        }
                    });
                });
            }

            // Check session on API error
            async function handleSessionError(response) {
                if (response.status === 401) {
                    // Session expired or token invalid - redirect to settings
                    window.location.href = '/settings';
                }
                return false;
            }

            // Warn user before leaving if messages are being sent
            window.addEventListener('beforeunload', (e) => {
                if (isSending) {
                    e.preventDefault();
                    e.returnValue = '';
                    return '';
                }
            });

            // Dropdown menu toggle
            const menuIcon = document.getElementById('menu-icon');
            const dropdownMenu = document.getElementById('dropdown-menu');

            if (menuIcon) {
                menuIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    dropdownMenu.classList.toggle('show');
                });
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (dropdownMenu && !dropdownMenu.contains(e.target) && menuIcon && !menuIcon.contains(e.target)) {
                    dropdownMenu.classList.remove('show');
                }
            });

            // Menu item navigation
            const menuItems = document.querySelectorAll('.menu-item');
            menuItems.forEach(item => {
                item.addEventListener('click', function() {
                    menuItems.forEach(i => i.classList.remove('active'));
                    this.classList.add('active');
                });
            });

            // Load saved data from localStorage (persists across sessions)
            function loadSelectedChannels() {
                const saved = localStorage.getItem('selectedChannels');
                if (saved) {
                    try {
                        selectedChannels = JSON.parse(saved);
                    } catch (e) {
                        console.error('Error loading saved channels:', e);
                        selectedChannels = [];
                    }
                }
            }

            function loadMessageText() {
                const saved = localStorage.getItem('messageText');
                if (saved && messageInput) {
                    messageInput.value = saved;
                    updateCharCount();
                }
            }

            // Load user data from database
            async function loadUserDataFromDB() {
                try {
                    const response = await fetch('/api/get-user-data');
                    if (response.ok) {
                        const data = await response.json();

                        // Load selected channels if available
                        if (data.selected_channels && Array.isArray(data.selected_channels)) {
                            selectedChannels = data.selected_channels;
                            localStorage.setItem('selectedChannels', JSON.stringify(selectedChannels));
                        }

                        // Load draft message if available
                        if (data.draft_message !== null && data.draft_message !== undefined && messageInput) {
                            messageInput.value = data.draft_message;
                            localStorage.setItem('messageText', data.draft_message);
                            updateCharCount();
                        }

                        return true;
                    } else {
                        console.warn('Failed to load user data from database, using localStorage fallback');
                        return false;
                    }
                } catch (error) {
                    console.error('Error loading user data from database:', error);
                    return false;
                }
            }

            // Save user data to database
            async function saveUserDataToDB() {
                try {
                    const response = await fetch('/api/save-user-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-Token': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({
                            selected_channels: selectedChannels,
                            draft_message: messageInput ? messageInput.value : ''
                        })
                    });

                    if (!response.ok) {
                        console.warn('Failed to save user data to database');
                        return false;
                    }

                    return true;
                } catch (error) {
                    console.error('Error saving user data to database:', error);
                    return false;
                }
            }

            // Save data to localStorage (persists across sessions)
            function saveSelectedChannels() {
                localStorage.setItem('selectedChannels', JSON.stringify(selectedChannels));
                // Also save to database
                saveUserDataToDB();
            }

            function saveMessageText() {
                if (messageInput) {
                    localStorage.setItem('messageText', messageInput.value);
                    // Also save to database
                    saveUserDataToDB();
                }
            }

            // Add search tag
            function addSearchTag(text) {
                if (searchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                if (!searchTags.includes(text.toLowerCase()) && text.trim()) {
                    searchTags.push(text.toLowerCase());
                    updateSearchTagsDisplay();
                    channelSearch.value = '';
                    if (selectedGuild) {
                        renderChannels();
                    }
                }
            }

            // Remove search tag
            function removeSearchTag(tag) {
                searchTags = searchTags.filter(t => t !== tag);
                updateSearchTagsDisplay();
                if (selectedGuild) {
                    renderChannels();
                }
            }

            // Update search tags display
            function updateSearchTagsDisplay() {
                searchTagsContainer.innerHTML = '';
                searchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}">✕</span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        removeSearchTag(tag);
                    });
                    searchTagsContainer.appendChild(tagEl);
                });
            }

            // Handle channel search input
            if (channelSearch) {
                channelSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && channelSearch.value.trim()) {
                        addSearchTag(channelSearch.value);
                    }
                });
            }

            // Render Discord-style server sidebar icons
            function renderServers() {
                if (!serverSidebar) return;

                serverSidebar.innerHTML = '';

                if (!guilds || guilds.length === 0) {
                    return;
                }

                guilds.forEach(guild => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'server-icon-wrapper';
                    wrapper.dataset.guildId = guild.id;
                    wrapper.title = guild.name;

                    const iconHtml = guild.icon
                        ? `<img src="https://cdn.discordapp.com/icons/${guild.id}/${guild.icon}.png?size=96" alt="${guild.name}">`
                        : `<span class="server-icon-placeholder">${guild.name.charAt(0).toUpperCase()}</span>`;

                    wrapper.innerHTML = `
                        <div class="server-icon-pill"></div>
                        <div class="server-icon-holder">
                            ${iconHtml}
                        </div>
                    `;

                    wrapper.addEventListener('click', () => selectServer(guild));
                    serverSidebar.appendChild(wrapper);

                    // Restore active state if this is the selected guild
                    if (selectedGuild && selectedGuild.id === guild.id) {
                        wrapper.classList.add('active');
                    }
                });
            }

            // Preload all channels for all guilds (for channels-only mode)
            async function preloadAllChannels() {
                const promises = guilds.map(async (guild) => {
                    if (!serverChannels[guild.id]) {
                        try {
                            const response = await fetch(`/api/guild/${guild.id}/channels`);
                            const data = await response.json();

                            if (data.token_invalid) {
                                return; // Skip, will handle redirect elsewhere
                            }

                            if (data.channels) {
                                serverChannels[guild.id] = data.channels.filter(ch => ch.type === 0).sort((a, b) => a.position - b.position);
                            } else {
                                serverChannels[guild.id] = [];
                            }

                            // Update channels-only view progressively as each guild loads
                            if (viewMode === 'channels') {
                                renderChannelsOnlyMode();
                            }
                        } catch (error) {
                            console.error(`Error preloading channels for ${guild.name}:`, error);
                            serverChannels[guild.id] = [];
                        }
                    }
                });

                await Promise.all(promises);
            }

            // Fetch all guilds and build UI
            async function initializeUI() {
                // Load from localStorage first (instant)
                loadSelectedChannels();
                loadMessageText();

                // Then load from database (syncs across devices)
                await loadUserDataFromDB();

                guilds = {{ guilds|tojson }};

                // Remove selected channels from servers that no longer exist (user left server)
                const guildIds = new Set(guilds.map(g => g.id));
                const originalLength = selectedChannels.length;
                selectedChannels = selectedChannels.filter(ch => guildIds.has(ch.guildId));

                // Save if any channels were removed
                if (selectedChannels.length !== originalLength) {
                    saveSelectedChannels();
                    saveUserDataToDB();
                }

                // Render servers
                renderServers();

                // Update selected display
                updateSelectedDisplay();
                updateSendButton();
                updateCharCount(); // Initialize character count display

                // Preload all channels in background for faster channel-only mode
                preloadAllChannels();
            }

            // Extract dominant color from image
            function getDominantColor(imageUrl, callback) {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    let r = 0, g = 0, b = 0, count = 0;

                    // Sample every 10th pixel for performance
                    for (let i = 0; i < data.length; i += 40) {
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        count++;
                    }

                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    callback(`rgb(${r}, ${g}, ${b})`);
                };
                img.onerror = function() {
                    callback('rgba(21, 216, 188, 0.6)'); // Fallback to default turquoise
                };
                img.src = imageUrl;
            }

            // Select a server and load its channels
            async function selectServer(guild) {
                // Set selected guild immediately
                selectedGuild = guild;
                const guildId = guild.id;

                // Update active state in server sidebar
                document.querySelectorAll('.server-icon-wrapper').forEach(item => {
                    item.classList.remove('active');
                });

                const activeItem = serverSidebar.querySelector(`[data-guild-id="${guildId}"]`);
                if (activeItem) {
                    activeItem.classList.add('active');
                }

                // Apply dominant color from server icon
                if (guild.icon) {
                    const iconUrl = `https://cdn.discordapp.com/icons/${guildId}/${guild.icon}.png`;
                    getDominantColor(iconUrl, (color) => {
                        // Only update if this guild is still selected
                        if (selectedGuild && selectedGuild.id === guildId) {
                            currentServerColor = color;
                        }
                    });
                } else {
                    // Use default color for servers without icons
                    currentServerColor = 'rgba(21, 216, 188, 0.6)';
                }

                // Load channels if not cached
                if (!serverChannels[guildId]) {
                    channelsList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';

                    try {
                        const response = await fetch(`/api/guild/${guildId}/channels`);

                        // Check if this guild is still selected
                        if (!selectedGuild || selectedGuild.id !== guildId) {
                            return;
                        }

                        const data = await response.json();

                        // Check for token_invalid error - redirect to settings
                        if (data.token_invalid) {
                            window.location.href = '/settings';
                            return;
                        }

                        if (!response.ok) {
                            await handleSessionError(response);
                            return;
                        }

                        if (data.channels) {
                            serverChannels[guildId] = data.channels.filter(ch => ch.type === 0).sort((a, b) => a.position - b.position);
                        } else {
                            serverChannels[guildId] = [];
                        }
                    } catch (error) {
                        console.error(`Error fetching channels:`, error);
                        serverChannels[guildId] = [];
                    }
                }

                // Only render if this guild is still selected
                if (selectedGuild && selectedGuild.id === guildId) {
                    renderChannels();
                }

                // Also update channels-only mode if active
                if (viewMode === 'channels') {
                    renderChannelsOnlyMode();
                }
            }

            // Render channels for selected server
            function renderChannels() {
                if (!selectedGuild) {
                    channelsList.innerHTML = '<div class="no-selection">Select a server to view channels</div>';
                    return;
                }

                channelsList.innerHTML = '';
                const channels = serverChannels[selectedGuild.id] || [];

                if (channels.length === 0) {
                    channelsList.innerHTML = '<div class="no-selection">No channels found</div>';
                    return;
                }

                // Filter channels by search tags (OR logic - any tag matches)
                let filteredChannels = channels;
                if (searchTags.length > 0) {
                    filteredChannels = channels.filter(channel =>
                        searchTags.some(tag => channel.name.toLowerCase().includes(tag))
                    );
                }

                if (filteredChannels.length === 0) {
                    channelsList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                filteredChannels.forEach(channel => {
                    const isSelected = selectedChannels.some(ch =>
                        ch.id === channel.id && ch.guildId === selectedGuild.id
                    );

                    // Check if channel failed
                    const channelKey = `${selectedGuild.id}-${channel.id}`;
                    const failedInfo = failedChannels.get(channelKey);
                    const isFailed = isSelected && !!failedInfo;
                    const statusText = failedInfo?.type === 'ratelimit' ? 'Rate limited' : 'Missing permission';

                    const channelItem = document.createElement('div');
                    channelItem.className = `channel-item ${isSelected ? 'selected' : ''}${isFailed ? ' failed' : ''}`;
                    channelItem.dataset.channelId = channel.id;

                    // Discord-style layout: # name [status-tag] tick
                    const statusTagHtml = isFailed ? `<span class="channel-status-tag">${statusText}</span>` : '';
                    channelItem.innerHTML = `
                        <span class="channel-hash">#</span>
                        <span class="channel-name">${channel.name}</span>
                        ${statusTagHtml}
                        <img class="channel-tick" src="{{ url_for('static', filename='tick.png') }}" alt="✓">
                    `;

                    // Click anywhere on channel item to toggle selection
                    channelItem.addEventListener('click', () => {
                        // Check current selection state at click time, not render time
                        const currentlySelected = selectedChannels.some(ch =>
                            ch.id === channel.id && ch.guildId === selectedGuild.id
                        );
                        toggleChannel(channel, !currentlySelected);
                    });

                    channelsList.appendChild(channelItem);
                });
            }

            // Toggle channel selection for channels-only mode
            function toggleChannelSelection(channel) {
                const isCurrentlySelected = selectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === channel.guildId
                );

                if (!isCurrentlySelected) {
                    // Check channel limit per server (-1 means unlimited)
                    if (maxChannelsPerServer !== -1) {
                        const currentServerChannelCount = selectedChannels.filter(ch =>
                            ch.guildId === channel.guildId
                        ).length;

                        if (currentServerChannelCount >= maxChannelsPerServer) {
                            showChannelLimitModal(maxChannelsPerServer);
                            return;
                        }
                    }

                    selectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: channel.guildId,
                        guildName: channel.guildName,
                        guildIcon: channel.guildIcon || null
                    });
                    // Clear any failed status when re-selecting
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    failedChannels.delete(channelKey);
                } else {
                    selectedChannels = selectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === channel.guildId)
                    );
                }

                // Save to localStorage
                saveSelectedChannels();

                // Update UI
                updateServerCount(channel.guildId);
                updateSelectedDisplay();
                updateSendButton();
            }

            // Toggle channel selection
            function toggleChannel(channel, isChecked) {
                if (!selectedGuild) return;

                const isCurrentlySelected = selectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === selectedGuild.id
                );

                if (isChecked && !isCurrentlySelected) {
                    // Check channel limit per server (-1 means unlimited)
                    if (maxChannelsPerServer !== -1) {
                        const currentServerChannelCount = selectedChannels.filter(ch =>
                            ch.guildId === selectedGuild.id
                        ).length;

                        if (currentServerChannelCount >= maxChannelsPerServer) {
                            showChannelLimitModal(maxChannelsPerServer);
                            return;
                        }
                    }

                    selectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: selectedGuild.id,
                        guildName: selectedGuild.name,
                        guildIcon: selectedGuild.icon || null
                    });
                    // Clear any failed status when re-selecting
                    const channelKey = `${selectedGuild.id}-${channel.id}`;
                    failedChannels.delete(channelKey);
                } else if (!isChecked && isCurrentlySelected) {
                    selectedChannels = selectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === selectedGuild.id)
                    );
                }

                // Save to localStorage
                saveSelectedChannels();

                // Update UI
                renderChannels();
                updateServerCount(selectedGuild.id);
                updateSelectedDisplay();
                updateSendButton();
            }

            // Update count badge on server
            function updateServerCount(guildId) {
                const count = selectedChannels.filter(ch => ch.guildId === guildId).length;
                const serverItem = document.querySelector(`[data-guild-id="${guildId}"]`);
                if (serverItem) {
                    const countEl = serverItem.querySelector('.server-count');
                    if (countEl) {
                        if (count > 0) {
                            countEl.textContent = `${count} selected`;
                            countEl.style.display = 'block';
                            serverItem.classList.add('has-selection');
                        } else {
                            countEl.style.display = 'none';
                            serverItem.classList.remove('has-selection');
                        }
                    }
                }
            }

            // Update only a specific channel's failed status - refreshes all relevant views
            function updateFailedChannelStatus(channel) {
                // Refresh the current view to show failed status
                if (viewMode === 'selected') {
                    renderSelectedChannelsMode();
                } else if (viewMode === 'channels') {
                    renderChannelsOnlyMode();
                } else if (viewMode === 'servers' && selectedGuild) {
                    renderChannels();
                }
            }

            // Update selected channels display (now just updates the selected channels mode view)
            function updateSelectedDisplay() {
                // Update selected channels mode view if it's active
                if (viewMode === 'selected') {
                    renderSelectedChannelsMode();
                }
                // Also update channels-only mode to reflect selection changes
                if (viewMode === 'channels') {
                    renderChannelsOnlyMode();
                }
            }

            // Update send button state
            function updateSendButton() {
                if (sendBtn && messageInput) {
                    const isOverLimit = messageInput.value.length > MESSAGE_LIMIT;
                    sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim() || isOverLimit;
                }
            }

            // Update character count display
            function updateCharCount() {
                if (charCount && messageInput) {
                    const remaining = MESSAGE_LIMIT - messageInput.value.length;
                    charCount.textContent = remaining;

                    // Apply red color when negative (over limit)
                    if (remaining < 0) {
                        charCount.style.color = '#991a35'; // Red from delete account button gradient
                    } else {
                        charCount.style.color = '#81828A'; // Default grey
                    }
                }
            }

            // Message input listener
            if (messageInput) {
                messageInput.addEventListener('input', function() {
                    updateCharCount();
                    saveMessageText();
                    updateSendButton();
                });
            }

            // Emoji button is just an icon - no picker functionality

            // Show collapsible send results
            async function showSendResults(succeeded, rateLimited, failed) {
                const totalAttempted = succeeded.length + rateLimited.length + failed.length;

                // Determine title and icon
                let title, icon;
                if (succeeded.length === 0 && (rateLimited.length > 0 || failed.length > 0)) {
                    title = 'Failed to send';
                    icon = 'error';
                } else {
                    title = 'Send succeeded';
                    icon = 'success';
                }

                // Build collapsible sections HTML
                let sectionsHTML = '';

                // Success section
                if (succeeded.length > 0) {
                    sectionsHTML += `
                        <div class="result-section collapsed">
                            <div class="result-header" onclick="this.parentElement.classList.toggle('collapsed')">
                                <span>Send succeeded (${succeeded.length} Channel${succeeded.length !== 1 ? 's' : ''})</span>
                                <img src="/static/openorclose.png" class="collapse-icon" style="width: 16px; height: 16px; transition: transform 0.2s;">
                            </div>
                            <div class="result-content">
                                ${succeeded.map(ch => `<div class="channel-item"># ${ch}</div>`).join('')}
                            </div>
                        </div>
                    `;
                }

                // Rate limited section
                if (rateLimited.length > 0) {
                    sectionsHTML += `
                        <div class="result-section collapsed">
                            <div class="result-header" onclick="this.parentElement.classList.toggle('collapsed')">
                                <span>Send rate limited (${rateLimited.length} Channel${rateLimited.length !== 1 ? 's' : ''})</span>
                                <img src="/static/openorclose.png" class="collapse-icon" style="width: 16px; height: 16px; transition: transform 0.2s;">
                            </div>
                            <div class="result-content">
                                ${rateLimited.map(ch => `<div class="channel-item"># ${ch}</div>`).join('')}
                            </div>
                        </div>
                    `;
                }

                // Failed section
                if (failed.length > 0) {
                    sectionsHTML += `
                        <div class="result-section collapsed">
                            <div class="result-header" onclick="this.parentElement.classList.toggle('collapsed')">
                                <span>Send failed (${failed.length} Channel${failed.length !== 1 ? 's' : ''})</span>
                                <img src="/static/openorclose.png" class="collapse-icon" style="width: 16px; height: 16px; transition: transform 0.2s;">
                            </div>
                            <div class="result-content">
                                ${failed.map(ch => `<div class="channel-item"># ${ch}</div>`).join('')}
                            </div>
                        </div>
                    `;
                }

                // Create custom modal
                const modalHTML = `
                    <style>
                        .result-section {
                            margin: 0 !important;
                            padding: 0 !important;
                            display: block !important;
                        }
                        .result-section.collapsed .result-content {
                            display: none;
                        }
                        .result-section.collapsed .collapse-icon {
                            transform: rotate(180deg);
                        }
                        .result-header {
                            padding: 0 !important;
                            margin: 0 !important;
                            cursor: pointer;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            font-weight: 500;
                            color: #dcddde;
                            user-select: none;
                            font-size: 0.85rem;
                            line-height: 1;
                        }
                        .result-header:hover {
                            opacity: 0.8;
                        }
                        .result-header span {
                            margin: 0 !important;
                            padding: 0 !important;
                            line-height: 1;
                        }
                        .result-content {
                            max-height: 150px;
                            overflow-y: auto;
                            overflow-x: hidden;
                            padding: 0 !important;
                            margin: 0 !important;
                            scroll-behavior: auto;
                        }
                        .result-content::-webkit-scrollbar {
                            width: 5px;
                        }
                        .result-content::-webkit-scrollbar-track {
                            background: transparent;
                        }
                        .result-content::-webkit-scrollbar-thumb {
                            background: rgba(255, 255, 255, 0.2);
                            border-radius: 3px;
                        }
                        .channel-item {
                            padding: 0 !important;
                            margin: 0 !important;
                            color: #81828A;
                            font-size: 0.75rem;
                            background: transparent;
                            line-height: 1;
                            display: block !important;
                        }
                    </style>
                    <div style="max-height: 300px; overflow-y: auto; overflow-x: hidden; scroll-behavior: auto; padding: 0 !important; margin: 0 !important; display: flex; flex-direction: column; gap: 0;">
                        ${sectionsHTML}
                    </div>
                `;

                await showAlert(modalHTML, title, { icon: icon, allowHtml: true });
            }

            // Send button handler
            if (sendBtn) {
                sendBtn.addEventListener('click', async function() {
                    if (selectedChannels.length > 0 && messageInput && messageInput.value.trim()) {
                        // Check for filtered content before proceeding
                        const message = messageInput.value.trim();
                        const filteredWords = {{ BLACKLISTED_WORDS|tojson }};
                        const phraseExceptions = {{ PHRASE_EXCEPTIONS|tojson }};

                        // Function to check if a word occurrence is within an exception phrase
                        function isWordInException(word, messageLower) {
                            const wordLower = word.toLowerCase();
                            const exceptions = phraseExceptions[wordLower] || [];

                            if (exceptions.length === 0) return false;

                            // Find all occurrences of the blacklisted word
                            let startIndex = 0;
                            while (true) {
                                const pos = messageLower.indexOf(wordLower, startIndex);
                                if (pos === -1) break;

                                const wordEnd = pos + wordLower.length;
                                let isException = false;

                                // Check if this occurrence is within any exception phrase
                                for (const exception of exceptions) {
                                    const excLower = exception.toLowerCase();
                                    const excPos = messageLower.indexOf(excLower);
                                    if (excPos !== -1 && excPos <= pos && (excPos + excLower.length) >= wordEnd) {
                                        isException = true;
                                        break;
                                    }
                                }

                                // If any occurrence is not an exception, word is blocked
                                if (!isException) return false;

                                startIndex = pos + 1;
                            }

                            return true; // All occurrences are within exceptions
                        }

                        // Check message against blacklist (case-insensitive) - find ALL matches
                        const messageLower = message.toLowerCase();
                        let foundWords = [];

                        for (const word of filteredWords) {
                            if (messageLower.includes(word.toLowerCase())) {
                                // Check if word is part of an exception phrase
                                if (!isWordInException(word, messageLower)) {
                                    foundWords.push(word);
                                }
                            }
                        }

                        if (foundWords.length > 0) {
                            // Flag the user for using banned words
                            try {
                                await fetch('/api/flag-self', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({ words: foundWords })
                                });
                            } catch (e) {
                                console.error('Failed to report flagged content:', e);
                            }

                            await showAlert(`Banned words used\n\nYour message contains prohibited content:\n• ${foundWords.join('\n• ')}\n\nPlease remove this content from your message before sending.`, 'Warning');
                            return; // Stop execution
                        }

                        // Show confirmation popup
                        const channelCount = selectedChannels.length;
                        const confirmed = await showConfirm(`Send message to ${channelCount} channel${channelCount !== 1 ? 's' : ''}?`, 'Send Message', { confirmText: 'Send' });
                        if (!confirmed) return;

                        // Clear previous failed channels
                        failedChannels.clear();

                        isSending = true;
                        sendBtn.disabled = true;
                        sendBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spinner"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2 A10 10 0 0 1 22 12" stroke-linecap="round"></path></svg> <span id="send-progress">Sending...</span>';

                        // Send messages one by one for real-time usage tracking
                        let succeededChannels = [];
                        let rateLimitedChannels = [];
                        let failedChannelsList = [];

                        // Helper function to wait/delay
                        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

                        // Get custom delay setting from database (default to 1000ms)
                        const customDelay = parseInt('{{ user_data.message_delay }}') || 1000;

                        // Get progress element for smooth updates
                        const progressEl = document.getElementById('send-progress');

                        try {
                            for (let i = 0; i < selectedChannels.length; i++) {
                                const channel = selectedChannels[i];

                                // Update progress text only (keeps spinner smooth)
                                if (progressEl) {
                                    progressEl.textContent = `Sending ${i + 1}/${selectedChannels.length}...`;
                                }

                                // Send message (no retry for rate limits)
                                const response = await fetch('/api/send-message-single', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({
                                        channel: channel,
                                        message: messageInput.value
                                    })
                                });

                                const result = await response.json();

                                // Check if send was successful (200/201 response)
                                if (response.ok && result.success) {
                                    succeededChannels.push(channel.name);
                                    // Clear any previous failure status for this channel
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.delete(channelKey);
                                    updateFailedChannelStatus(channel);
                                } else if (result.token_invalid) {
                                    // Token is invalid - redirect to settings
                                    window.location.href = '/settings';
                                    return; // Stop execution
                                } else if (result.limit_reached) {
                                    // Usage limit reached - redirect to settings
                                    await showAlert('Usage limit reached!\n\nYou have reached your message limit for this period.\nRedirecting to settings page...', 'Limit reached');
                                    window.location.href = '/settings';
                                    return; // Stop execution
                                } else if (response.status === 429) {
                                    // Rate limited by Discord - mark and skip (don't retry)
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.set(channelKey, { type: 'ratelimit' });
                                    rateLimitedChannels.push(channel.name);
                                    updateFailedChannelStatus(channel);
                                } else {
                                    // Other error (permissions, etc.)
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.set(channelKey, { type: 'permission' });
                                    failedChannelsList.push(channel.name);
                                    updateFailedChannelStatus(channel);
                                }

                                // Add delay between messages based on user setting
                                // Only delay if there are more messages to send
                                if (i < selectedChannels.length - 1 && customDelay > 0) {
                                    await delay(customDelay);
                                }
                            }

                            // Show collapsible results
                            await showSendResults(succeededChannels, rateLimitedChannels, failedChannelsList);
                        } catch (error) {
                            console.error('Send error:', error);
                            await showAlert(`Error sending message: ${error.message}`, 'Error');
                        } finally {
                            isSending = false;
                            sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                            sendBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"></path></svg> Send';
                        }
                    }
                });
            }

            // Initialize on load
            initializeUI();
        });
    </script>
</body>
</html>
