<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Panel - New Design</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='responsive.css') }}">
    {% include 'partials/config_styles.html' %}
    <script src="{{ url_for('static', filename='tab_enforcement.js') }}"></script>
    <script src="{{ url_for('static', filename='status_polling.js') }}"></script>
    <script>
        window.DB_VERSION = {{ db_version }};
        window.DB_WIPE_MESSAGE = "{{ db_wipe_message }}";
    </script>
    <script src="{{ url_for('static', filename='db_wipe_notice.js') }}"></script>
    <script src="{{ url_for('static', filename='custom_modals.js') }}"></script>
    <style>
        /* Prevent page scrolling */
        body {
            overflow: hidden;
            height: 100vh;
        }

        .panel {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* New panel design - wrapper for side menu + content */
        .test-panel-container {
            padding: 1rem;
            flex: 1;
            overflow: hidden;
        }

        .test-main-frame {
            background: transparent;
            border: 1px solid #222225;
            border-radius: 12px;
            display: flex;
            height: 100%;
            overflow: hidden;
        }

        /* Side menu */
        .side-menu {
            width: 240px;
            background: #1A1A1E;
            border-right: 1px solid #222225;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            gap: 1rem;
            flex-shrink: 0;
        }

        /* Discord profile section */
        .profile-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .profile-card {
            background: transparent;
            border-radius: 8px;
            padding: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
        }

        .profile-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: visible;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2a2a30;
            position: relative;
        }

        .profile-avatar img.avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }

        .profile-avatar .avatar-decoration {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120%;
            height: 120%;
            pointer-events: none;
            z-index: 1;
        }

        .profile-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .profile-name {
            color: #dcddde;
            font-weight: 500;
            font-size: 0.9rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            line-height: 1.2;
            margin: 0;
        }

        .change-account-text {
            color: #81828A;
            font-size: 0.75rem;
            line-height: 1.2;
            margin: 0;
        }

        /* Menu sections */
        .menu-section {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .menu-category {
            color: #81828A;
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            padding: 0.25rem 0.75rem;
            margin-top: 0.25rem;
        }

        .menu-category:first-child {
            margin-top: 0;
        }

        .menu-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-radius: 6px;
            color: #dcddde;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            background: transparent;
            border: none;
            width: 100%;
            text-align: left;
        }

        .menu-item.active {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
            color: #121215;
        }

        .menu-divider {
            height: 1px;
            background: rgba(255,255,255,0.05);
            margin: 0.25rem 0;
        }

        /* Main content wrapper - takes up remaining space */
        .main-content-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: visible;
            min-width: 0;
        }

        /* Custom radio button styling matching settings.html */
        input[type="radio"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid #15d8bc;
            border-radius: 50%;
            background: transparent;
            cursor: pointer;
            position: relative;
        }
        input[type="radio"]:checked {
            background: #15d8bc;
            border-color: #15d8bc;
        }
        input[type="radio"]:checked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: #fff;
            border-radius: 50%;
        }
        input[type="radio"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Override main-layout for test panel - add divider */
        .main-content-wrapper .main-layout {
            display: flex;
            gap: 0;
            height: 100%;
        }

        .main-content-wrapper .main-layout .selection-panel {
            flex: 1;
            margin: 0;
            padding: 0;
            background: transparent;
            border-radius: 0;
        }

        .main-content-wrapper .main-layout .action-panel {
            flex: 1;
            margin: 0.75rem;
        }

        /* Vertical divider between panels */
        .panel-divider {
            width: 1px;
            background: #222225;
            margin: 0;
            flex-shrink: 0;
        }

        /* View mode toggle - centered */
        .view-mode-toggle {
            display: flex;
            gap: 1.5rem;
            padding: 0.5rem 0.5rem;
            justify-content: center;
            margin-top: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .view-mode-toggle label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .view-mode-toggle span {
            color: #dcddde;
            font-weight: 500;
            font-size: 0.85rem;
        }

        /* Selected channels mode - channels list with x.png for remove */
        .selected-channels-mode .channels-list .channel-item .channel-tick {
            content: url("{{ url_for('static', filename='x.png') }}");
        }

        /* Reduced height searchbar for selection panel */
        .selection-panel .search-input {
            padding: 0.35rem 0.75rem;
            padding-left: 2.5rem;
            font-size: 0.85rem;
            width: 100%;
            box-sizing: border-box;
            color: #81828A;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            background-color: #1A1A1E;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%2381828A' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: 0.75rem center;
            background-size: 16px 16px;
            border: 1px solid #222225;
            border-radius: 8px;
        }

        /* Full-width channels list with horizontal padding to match searchbar */
        .selection-panel .channels-list {
            padding: 0 0.5rem;
            margin: 0;
            border-radius: 0;
        }

        .selection-panel .channels-list .channel-item {
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            border-radius: 4px;
        }

        .selection-panel .channels-section,
        .selection-panel .channels-only-section {
            padding: 0;
            margin: 0;
            border-radius: 0;
        }

        .selection-panel .unified-header {
            padding: 0 0.5rem;
            margin-bottom: 0.25rem;
        }

        /* Fixed height for both headers to prevent rescaling */
        .selection-panel .servers-mode-header,
        .selection-panel .channels-only-header {
            min-height: 2.5rem;
        }

        .selection-panel .servers-mode-header .header-section,
        .selection-panel .channels-only-header .header-section {
            width: 100%;
        }

        .selection-panel .channels-search {
            width: 100%;
        }

        /* Discord-style server sidebar on far left */
        .server-sidebar {
            width: 72px;
            background: transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem 0;
            gap: 0.5rem;
            overflow-y: auto;
            overflow-x: visible;
            flex-shrink: 0;
            position: relative;
        }

        .server-sidebar::-webkit-scrollbar {
            width: 0;
        }

        .server-icon-wrapper {
            position: relative;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .server-icon-pill {
            position: absolute;
            left: -12px;
            width: 4px;
            background: #FBFBFB;
            border-radius: 0 4px 4px 0;
            transition: height 0.15s ease-out, opacity 0.15s ease-out;
            height: 0;
            opacity: 0;
        }

        .server-icon-wrapper:hover .server-icon-pill {
            height: 20px;
            opacity: 1;
        }

        .server-icon-wrapper.active .server-icon-pill {
            height: 40px;
            opacity: 1;
        }

        .server-icon-holder {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #1A1A1E;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: border-radius 0.15s ease-out;
        }

        .server-icon-wrapper:hover .server-icon-holder {
            border-radius: 16px;
        }

        .server-icon-wrapper.active .server-icon-holder {
            border-radius: 16px;
        }

        .server-icon-holder img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .server-icon-placeholder {
            color: #dcddde;
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* Divider between content and server sidebar */
        .server-sidebar-divider {
            width: 1px;
            background: #222225;
            margin: 0;
            flex-shrink: 0;
        }

        /* Discord-style channel list overrides */
        .channels-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 0 0.5rem;
            overflow-x: hidden;
        }

        /* Selection panel needs position relative for absolute centering of messages */
        .selection-panel {
            position: relative;
        }

        /* Center no-selection and loading messages exactly in the middle of the selection-panel */
        .selection-panel .no-selection,
        .selection-panel .loading-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #81828A;
            font-size: 0.95rem;
            padding: 0;
            margin: 0;
            width: max-content;
            z-index: 1;
        }

        .channels-list .channel-item {
            display: flex !important;
            flex-direction: row !important;
            align-items: center !important;
            flex-wrap: nowrap !important;
            gap: 0.5rem;
            padding: 0.4rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            border: none;
            transition: none;
            width: 100%;
            box-sizing: border-box;
        }

        .channels-list .channel-item:hover {
            transform: none;
            background: #1A1A1E;
        }

        .channels-list .channel-item:hover .channel-hash,
        .channels-list .channel-item:hover .channel-name {
            color: #fff;
        }

        .channels-list .channel-item.selected {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
            border: none;
            box-shadow: none;
        }

        .channels-list .channel-item.selected:hover {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
        }

        .channels-list .channel-item .channel-hash {
            color: #81828A;
            font-size: 1rem;
            font-weight: 500;
            flex-shrink: 0;
        }

        .channels-list .channel-item.selected .channel-hash {
            color: #121215;
        }

        .channels-list .channel-item .channel-name {
            color: #81828A;
            font-size: 0.9rem;
            font-weight: 500;
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .channels-list .channel-item.selected .channel-name {
            color: #121215;
        }

        /* Right side container for status tag and tick icon */
        .channels-list .channel-item .channel-right {
            display: none !important;
            flex-direction: row !important;
            align-items: center !important;
            flex-wrap: nowrap !important;
            gap: 0.5rem;
            margin-left: auto;
            flex-shrink: 0;
            position: absolute;
            right: 0.5rem;
        }

        .channels-list .channel-item.selected .channel-right {
            display: flex !important;
        }

        /* Make channel-item position relative for absolute positioning of channel-right */
        .channels-list .channel-item {
            position: relative;
        }

        .channels-list .channel-item .channel-tick {
            width: 22px;
            height: 22px;
            flex-shrink: 0;
            filter: brightness(0) saturate(100%);
        }

        /* Keep x.png at smaller size */
        .channels-list .channel-item .channel-tick[alt="x"] {
            width: 11px;
            height: 11px;
        }

        /* Failed channel status tag */
        .channels-list .channel-item .channel-status-tag {
            display: none;
            background: #121215;
            color: #81828A;
            font-size: 0.6rem;
            font-weight: 500;
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
            white-space: nowrap;
            width: 85px;
            text-align: center;
            flex-shrink: 0;
            line-height: 1;
            box-sizing: border-box;
        }

        .channels-list .channel-item.failed .channel-status-tag {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Team Management member items - always show right side */
        .channels-list .channel-item.mgmt-member-item .channel-right {
            display: flex !important;
        }

        .channels-list .channel-item.mgmt-member-item .channel-status-tag {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Failed channel styling - red gradient background */
        .channels-list .channel-item.failed {
            background: linear-gradient(to bottom, #991a35, #6b1226);
        }

        .channels-list .channel-item.failed:hover {
            background: linear-gradient(to bottom, #991a35, #6b1226);
        }

        .channels-list .channel-item.failed .channel-hash,
        .channels-list .channel-item.failed .channel-name {
            color: #121215;
        }

        /* Server icon for channels-only mode */
        .channels-list .channel-item .server-icon-small {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            flex-shrink: 0;
            object-fit: cover;
        }

        .channels-list .channel-item .server-icon-placeholder-small {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #5865f2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            font-weight: 600;
            flex-shrink: 0;
        }

        /* Keep server icon unchanged when selected */
        .channels-list .channel-item.selected .server-icon-small,
        .channels-list .channel-item.selected .server-icon-placeholder-small {
            /* No changes - keep original appearance */
        }
    </style>
</head>
<body>
    <div class="panel">
        <nav class="navbar">
            <div class="navbar-content">
                <div class="navbar-left">
                    <div class="menu-icon" id="menu-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="3" y1="12" x2="21" y2="12"></line>
                            <line x1="3" y1="6" x2="21" y2="6"></line>
                            <line x1="3" y1="18" x2="21" y2="18"></line>
                        </svg>
                    </div>
                    <div class="navbar-text">
                        <h1 class="navbar-title">Ad <span class="gradient-z">Z</span> send</h1>
                        <p class="navbar-subtitle">Select in which servers and channels you would like to automate your marketing</p>
                    </div>
                </div>
                <div class="nav-right"></div>
            </div>

            <!-- Dropdown Menu -->
            <div class="dropdown-menu" id="dropdown-menu">
                <a href="{{ url_for('home') }}" class="dropdown-item">Home</a>
                <a href="{{ url_for('panel') }}" class="dropdown-item">Personal Panel</a>
                <a href="{{ url_for('settings') }}" class="dropdown-item">Settings</a>
                <div class="dropdown-divider"></div>
                <a href="https://discord.gg/KWt6rvCukp" target="_blank" class="dropdown-item discord-item">Discord Server</a>
                <a href="{{ url_for('logout') }}" class="dropdown-item logout-item">Logout</a>
            </div>
        </nav>

        <div class="test-panel-container">
            <div class="test-main-frame">
                <!-- Side Menu -->
                <div class="side-menu">
                    <!-- Discord Profile -->
                    <div class="profile-section">
                        {% if discord_linked and discord_info %}
                        <div class="profile-card">
                            <div class="profile-avatar">
                                {% if discord_info.avatar %}
                                <img class="avatar-img" src="https://cdn.discordapp.com/avatars/{{ discord_info.id }}/{{ discord_info.avatar }}.png?size=128" alt="Avatar">
                                {% else %}
                                <img class="avatar-img" src="https://cdn.discordapp.com/embed/avatars/{{ discord_info.discriminator|int % 5 }}.png" alt="Default Avatar">
                                {% endif %}
                                {% if discord_info.avatar_decoration_data and discord_info.avatar_decoration_data.asset %}
                                <img class="avatar-decoration" src="https://cdn.discordapp.com/avatar-decoration-presets/{{ discord_info.avatar_decoration_data.asset }}.png?size=160&passthrough=true" alt="">
                                {% endif %}
                            </div>
                            <div class="profile-info">
                                <div class="profile-name">{{ discord_info.username }}</div>
                                <div class="change-account-text">Change account</div>
                            </div>
                        </div>
                        {% else %}
                        <div class="profile-card">
                            <div class="profile-info">
                                <div class="profile-name">No Discord Account</div>
                                <div class="change-account-text">Change account</div>
                            </div>
                        </div>
                        {% endif %}
                    </div>

                    <!-- Menu Items -->
                    <div class="menu-section">
                        <div class="menu-category">Main</div>

                        <button class="menu-item{% if not discord_linked or is_team_owner or not guilds %} disabled{% else %} active{% endif %}" data-page="personal-panel"{% if not discord_linked or is_team_owner or not guilds %} disabled style="opacity: 0.4; cursor: not-allowed;"{% endif %}>
                            Personal panel
                        </button>

                        <button class="menu-item{% if not discord_linked or not has_team or not guilds %} disabled{% elif is_team_owner and guilds %} active{% endif %}" data-page="team-panel"{% if not discord_linked or not has_team or not guilds %} disabled style="opacity: 0.4; cursor: not-allowed;"{% endif %}>
                            Team panel
                        </button>

                        <div class="menu-divider"></div>

                        <div class="menu-category">Management</div>

                        <button class="menu-item{% if not discord_linked or not is_team_owner %} disabled{% endif %}" data-page="team-management"{% if not discord_linked or not is_team_owner %} disabled style="opacity: 0.4; cursor: not-allowed;"{% endif %}>
                            Team management
                        </button>

                        <button class="menu-item{% if not discord_linked %} disabled{% endif %}" data-page="analytics"{% if not discord_linked %} disabled style="opacity: 0.4; cursor: not-allowed;"{% endif %}>
                            Analytics
                        </button>

                        <div class="menu-divider"></div>

                        <div class="menu-category">Settings</div>

                        <button class="menu-item{% if not discord_linked %} disabled{% endif %}" data-page="interval"{% if not discord_linked %} disabled style="opacity: 0.4; cursor: not-allowed;"{% endif %}>
                            Interval
                        </button>
                    </div>
                </div>

                <!-- Main Content Area (uses styles.css classes) -->
                <div class="main-content-wrapper">
                    <!-- Page: Personal Panel -->
                    <div id="page-personal-panel" class="page-content" style="height: 100%; display: {% if is_team_owner %}none{% else %}flex{% endif %}; flex-direction: column;">
                    {% if guilds %}
                    <div class="main-layout" style="height: 100%;">
                        <!-- Left: Discord-style Server Sidebar -->
                        <div class="server-sidebar" id="server-sidebar">
                            <!-- Server icons will be populated by JavaScript -->
                        </div>

                        <!-- Divider after server sidebar -->
                        <div class="server-sidebar-divider"></div>

                        <!-- Channel Selection -->
                        <div class="selection-panel">
                            <!-- View Mode Toggle with Radio Buttons - Centered -->
                            <div class="view-mode-toggle">
                                <label>
                                    <input type="radio" name="view-mode" value="servers" checked>
                                    <span>Selected server</span>
                                </label>
                                <label>
                                    <input type="radio" name="view-mode" value="channels">
                                    <span>All channels</span>
                                </label>
                                <label>
                                    <input type="radio" name="view-mode" value="selected">
                                    <span>Selected channels</span>
                                </label>
                            </div>

                            <!-- Channels Header (Servers Mode) -->
                            <div class="unified-header servers-mode-header">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="channel-search" class="search-input" placeholder="Search (press enter to add tag)">
                                        <div class="search-tags" id="search-tags"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Channels Only Mode Header -->
                            <div class="unified-header channels-only-header" style="display: none;">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="channels-only-search" class="search-input" placeholder="Search (press enter to add tag)">
                                        <div class="search-tags" id="channels-only-search-tags"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Channels List (Servers Mode) -->
                            <div class="channels-section servers-mode-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                                <div id="channels-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="no-selection">Select a server to view channels</div>
                                </div>
                            </div>

                            <!-- Channels Only List (Channels Only Mode) -->
                            <div class="channels-only-section" style="display: none; flex: 1; flex-direction: column; min-height: 0;">
                                <div id="channels-only-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>
                                </div>
                            </div>

                            <!-- Selected Channels Mode Header -->
                            <div class="unified-header selected-channels-mode-header" style="display: none;">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="selected-channels-mode-search" class="search-input" placeholder="Search">
                                    </div>
                                </div>
                            </div>

                            <!-- Selected Channels Mode List -->
                            <div class="selected-channels-mode-section" style="display: none; flex: 1; flex-direction: column; min-height: 0; overflow: hidden;">
                                <div id="selected-channels-mode-list" class="channels-list selected-channels-mode" style="flex: 1; overflow-y: auto; overflow-x: hidden; min-height: 0;">
                                    <div class="no-selection">No channels selected</div>
                                </div>
                            </div>
                        </div>

                        <!-- Vertical Divider -->
                        <div class="panel-divider"></div>

                        <!-- Middle: Message Composer Only -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; background: transparent; padding: 0 0.75rem; border: none; box-sizing: border-box;">
                            <!-- Personal panel label - matching view-mode-toggle position -->
                            <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Personal panel</span>
                            </div>
                            <!-- Message Composer -->
                            <div class="message-section" style="display: flex; flex-direction: column; width: 100%; flex: 1; min-height: 0;">
                                <div class="message-input-container" style="flex: 1; display: flex; flex-direction: column; background: #1A1A1E; border: 1px solid #222225; border-radius: 8px; position: relative; min-height: 0;">
                                    <!-- Emoji button - top right corner (disabled) -->
                                    <button id="emoji-btn" type="button" disabled style="position: absolute; top: 8px; right: 8px; background: transparent; border: none; cursor: not-allowed; padding: 0; z-index: 2; opacity: 0.4;">
                                        <img src="{{ url_for('static', filename='emojimain.png') }}" alt="Emoji" style="width: 20px; height: 20px; opacity: 0.7;">
                                    </button>
                                    <!-- Character count - bottom right corner -->
                                    <span id="char-count" style="position: absolute; bottom: 8px; right: 8px; color: #81828A; font-size: 0.85rem; font-weight: 500; z-index: 1; pointer-events: none;">2000</span>
                                    <!-- Textarea with padding barriers for emoji (top-right) and counter (bottom-right) -->
                                    <textarea id="message-input" class="message-input" placeholder="Message" style="flex: 1; width: 100%; padding: 8px; padding-top: 8px; padding-right: 40px; padding-bottom: 32px; background: transparent; border: none; color: #dcddde; font-size: 0.9rem; resize: none; box-sizing: border-box; line-height: 1.4; vertical-align: top;"></textarea>
                                </div>
                                <div class="message-footer" style="flex-shrink: 0; padding: 0.75rem 0;">
                                    <button id="send-btn" class="send-button" disabled style="width: 100%; justify-content: center;">
                                        Send
                                    </button>
                                </div>
                            </div>
                        </div>

                    </div>
                    {% endif %}
                    </div>
                    <!-- End Page: Personal Panel -->

                    <!-- Page: Team Panel -->
                    <div id="page-team-panel" class="page-content" style="height: 100%; display: {% if is_team_owner and guilds %}flex{% else %}none{% endif %}; flex-direction: column;">
                    {% if has_team and guilds %}
                    <div class="main-layout" style="height: 100%;">
                        <!-- Left: Discord-style Server Sidebar -->
                        <div class="server-sidebar" id="team-server-sidebar">
                            <!-- Server icons will be populated by JavaScript -->
                        </div>

                        <!-- Divider after server sidebar -->
                        <div class="server-sidebar-divider"></div>

                        <!-- Channel Selection -->
                        <div class="selection-panel" id="team-selection-panel">
                            <!-- View Mode Toggle with Radio Buttons - Centered -->
                            <div class="view-mode-toggle">
                                <label>
                                    <input type="radio" name="team-view-mode" value="servers" checked>
                                    <span>Selected server</span>
                                </label>
                                <label>
                                    <input type="radio" name="team-view-mode" value="channels">
                                    <span>All channels</span>
                                </label>
                                <label>
                                    <input type="radio" name="team-view-mode" value="selected">
                                    <span>Selected channels</span>
                                </label>
                            </div>

                            <!-- Channels Header (Servers Mode) -->
                            <div class="unified-header team-servers-mode-header">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="team-channel-search" class="search-input" placeholder="Search (press enter to add tag)">
                                        <div class="search-tags" id="team-search-tags"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Channels Only Mode Header -->
                            <div class="unified-header team-channels-only-header" style="display: none;">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="team-channels-only-search" class="search-input" placeholder="Search (press enter to add tag)">
                                        <div class="search-tags" id="team-channels-only-search-tags"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Channels List (Servers Mode) -->
                            <div class="channels-section team-servers-mode-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                                <div id="team-channels-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="no-selection">Select a server to view channels</div>
                                </div>
                            </div>

                            <!-- Channels Only List (Channels Only Mode) -->
                            <div class="team-channels-only-section" style="display: none; flex: 1; flex-direction: column; min-height: 0;">
                                <div id="team-channels-only-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>
                                </div>
                            </div>

                            <!-- Selected Channels Mode Header -->
                            <div class="unified-header team-selected-channels-mode-header" style="display: none;">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="team-selected-channels-mode-search" class="search-input" placeholder="Search">
                                    </div>
                                </div>
                            </div>

                            <!-- Selected Channels Mode List -->
                            <div class="team-selected-channels-mode-section" style="display: none; flex: 1; flex-direction: column; min-height: 0; overflow: hidden;">
                                <div id="team-selected-channels-mode-list" class="channels-list selected-channels-mode" style="flex: 1; overflow-y: auto; overflow-x: hidden; min-height: 0;">
                                    <div class="no-selection">No channels selected</div>
                                </div>
                            </div>
                        </div>

                        <!-- Vertical Divider -->
                        <div class="panel-divider"></div>

                        <!-- Middle: Message Composer Only -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; background: transparent; padding: 0 0.75rem; border: none; box-sizing: border-box;">
                            <!-- Team panel label - matching view-mode-toggle position -->
                            <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Team panel (message set by team owner)</span>
                            </div>
                            <!-- Message Composer -->
                            <div class="message-section" style="display: flex; flex-direction: column; width: 100%; flex: 1; min-height: 0;">
                                <div class="message-input-container" style="flex: 1; display: flex; flex-direction: column; background: #1A1A1E; border: 1px solid #222225; border-radius: 8px; position: relative; min-height: 0;">
                                    <!-- Emoji button - top right corner (disabled) -->
                                    <button id="team-emoji-btn" type="button" disabled style="position: absolute; top: 8px; right: 8px; background: transparent; border: none; cursor: not-allowed; padding: 0; z-index: 2; opacity: 0.4;">
                                        <img src="{{ url_for('static', filename='emojimain.png') }}" alt="Emoji" style="width: 20px; height: 20px; opacity: 0.7;">
                                    </button>
                                    <!-- Character count - bottom right corner -->
                                    <span id="team-char-count" style="position: absolute; bottom: 8px; right: 8px; color: #81828A; font-size: 0.85rem; font-weight: 500; z-index: 1; pointer-events: none;">{{ 2000 - (team.team_message or '')|length }}</span>
                                    <!-- Textarea with padding barriers for emoji (top-right) and counter (bottom-right) -->
                                    <textarea id="team-message-input" class="message-input" placeholder="No team message set" readonly style="flex: 1; width: 100%; padding: 8px; padding-top: 8px; padding-right: 40px; padding-bottom: 32px; background: transparent; border: none; color: #81828A; font-size: 0.9rem; resize: none; box-sizing: border-box; line-height: 1.4; vertical-align: top;">{{ team.team_message or '' }}</textarea>
                                </div>
                                <div class="message-footer" style="flex-shrink: 0; padding: 0.75rem 0;">
                                    <button id="team-send-btn" class="send-button"{% if not team or not team.team_message %} disabled{% endif %} style="width: 100%; justify-content: center;">
                                        Send
                                    </button>
                                </div>
                            </div>
                        </div>

                    </div>
                    {% endif %}
                    </div>

                    <!-- Page: Team Management -->
                    <div id="page-team-management" class="page-content" style="height: 100%; display: none; flex-direction: row;">
                        {% if is_team_owner and team %}
                        <!-- Left Half: Team Members Management -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; position: relative;">
                            <!-- Radio Toggle -->
                            <div class="view-mode-toggle">
                                <label>
                                    <input type="radio" name="mgmt-view-mode" value="add" checked>
                                    <span>Add</span>
                                </label>
                                <label>
                                    <input type="radio" name="mgmt-view-mode" value="members">
                                    <span>Team members</span>
                                </label>
                            </div>

                            <!-- Add Mode Header (search bar + member count) -->
                            <div class="unified-header mgmt-add-mode-header">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="mgmt-add-search" class="search-input" placeholder="Search Adzsend ID (press enter to add)">
                                    </div>
                                </div>
                                <div id="mgmt-member-count-add" style="display: flex; justify-content: center; padding: 0.25rem 0 0 0;">
                                    <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">{{ active_member_count|default(0) }}/15 team members</span>
                                </div>
                            </div>

                            <!-- Team Members Mode Header (member count only, no search bar) -->
                            <div class="unified-header mgmt-members-mode-header" style="display: none;">
                                <div id="mgmt-member-count-members" style="display: flex; justify-content: center; padding: 0.5rem 0;">
                                    <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">{{ active_member_count|default(0) }}/15 team members</span>
                                </div>
                            </div>

                            <!-- Empty state messages (centered in entire left half) -->
                            {% set pending_members = members|default([])|selectattr('invitation_status', 'equalto', 'pending')|list %}
                            {% set accepted_members = members|default([])|selectattr('invitation_status', 'equalto', 'accepted')|list %}
                            <div id="mgmt-add-empty" class="no-selection" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); {% if pending_members|length > 0 %}display: none;{% endif %}">No pending invitations</div>
                            <div id="mgmt-members-empty" class="no-selection" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none;">No team members yet</div>

                            <!-- Add Mode List (Only pending invitations) -->
                            <div class="channels-section mgmt-add-mode-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0; padding-top: 0;">
                                <div id="mgmt-add-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    {% if pending_members|length > 0 %}
                                        {% for member in pending_members %}
                                            <div class="channel-item mgmt-member-item" data-adzsend-id="{{ member.member_adzsend_id }}" data-status="pending" style="cursor: default;">
                                                <div class="mgmt-member-avatar" style="width: 32px; height: 32px; border-radius: 50%; background: #ff3333; flex-shrink: 0;"></div>
                                                <span class="channel-name" style="font-family: monospace;">{{ member.member_adzsend_id or 'No ID' }}</span>
                                                <div class="channel-right">
                                                    <span class="channel-status-tag">Pending</span>
                                                    <img class="mgmt-member-remove" src="{{ url_for('static', filename='x.png') }}" alt="x" style="width: 16px; height: 16px; cursor: pointer; opacity: 0.7;" data-action="cancel-invite">
                                                </div>
                                            </div>
                                        {% endfor %}
                                    {% endif %}
                                </div>
                            </div>

                            <!-- Team Members Mode List (Only accepted members) -->
                            <div class="channels-section mgmt-members-mode-section" style="display: none; flex: 1; flex-direction: column; min-height: 0; padding-top: 0;">
                                <div id="mgmt-members-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    {% if accepted_members|length > 0 %}
                                        {% for member in accepted_members %}
                                            <div class="channel-item mgmt-member-item" data-adzsend-id="{{ member.member_adzsend_id }}" data-status="accepted" style="cursor: default;">
                                                <div class="mgmt-member-avatar" style="width: 32px; height: 32px; border-radius: 50%; background: #ff3333; flex-shrink: 0;"></div>
                                                <span class="channel-name" style="font-family: monospace;">{{ member.member_adzsend_id or 'No ID' }}</span>
                                                <div class="channel-right">
                                                    <span class="channel-status-tag">Team member</span>
                                                    <img class="mgmt-member-remove" src="{{ url_for('static', filename='x.png') }}" alt="x" style="width: 16px; height: 16px; cursor: pointer; opacity: 0.7;" data-action="remove-member">
                                                </div>
                                            </div>
                                        {% endfor %}
                                    {% endif %}
                                </div>
                            </div>
                        </div>

                        <!-- Vertical Divider -->
                        <div class="panel-divider"></div>

                        <!-- Right Half: Team Message (same UI as Personal panel) -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; background: transparent; border: none; box-sizing: border-box;">
                            <!-- Team message label - matching view-mode-toggle position -->
                            <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Team message</span>
                            </div>
                            <!-- Message Composer -->
                            <div class="message-section" style="display: flex; flex-direction: column; flex: 1; min-height: 0; margin: 0 0.75rem;">
                                <div class="message-input-container" style="flex: 1; display: flex; flex-direction: column; background: #1A1A1E; border: 1px solid #222225; border-radius: 8px; position: relative; min-height: 0;">
                                    <!-- Emoji button - top right corner (disabled) -->
                                    <button id="mgmt-emoji-btn" type="button" disabled style="position: absolute; top: 8px; right: 8px; background: transparent; border: none; cursor: not-allowed; padding: 0; z-index: 2; opacity: 0.4;">
                                        <img src="{{ url_for('static', filename='emojimain.png') }}" alt="Emoji" style="width: 20px; height: 20px; opacity: 0.7;">
                                    </button>
                                    <!-- Character count - bottom right corner -->
                                    <span id="mgmt-char-count" style="position: absolute; bottom: 8px; right: 8px; color: #81828A; font-size: 0.85rem; font-weight: 500; z-index: 1; pointer-events: none;">{{ 2000 - (team.team_message or '')|length }}</span>
                                    <!-- Textarea with padding barriers for emoji (top-right) and counter (bottom-right) -->
                                    <textarea id="mgmt-team-message-input" class="message-input" placeholder="Message" style="flex: 1; width: 100%; padding: 8px; padding-top: 8px; padding-right: 40px; padding-bottom: 32px; background: transparent; border: none; color: #dcddde; font-size: 0.9rem; resize: none; box-sizing: border-box; line-height: 1.4; vertical-align: top;">{{ team.team_message or '' }}</textarea>
                                </div>
                                <div class="message-footer" style="flex-shrink: 0; padding: 0.75rem 0;">
                                    <button id="mgmt-save-btn" class="send-button" style="width: 100%; justify-content: center;">
                                        Save
                                    </button>
                                </div>
                            </div>
                        </div>
                        {% else %}
                        <!-- No access message -->
                        <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
                            <div class="no-selection">You need to be a team owner to access this page</div>
                        </div>
                        {% endif %}
                    </div>

                    <!-- Page: Analytics -->
                    <div id="page-analytics" class="page-content" style="height: 100%; display: none; flex-direction: row;">
                        <!-- Left Half: Personal Analytics -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; position: relative;">
                            <!-- Label (replaces radio toggle) -->
                            <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Personal analytics</span>
                            </div>

                            <!-- Header (search bar) -->
                            <div class="unified-header">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="analytics-personal-search" class="search-input" placeholder="Search">
                                    </div>
                                </div>
                            </div>

                            <!-- List Section -->
                            <div class="channels-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0; padding-top: 0;">
                                <div id="analytics-personal-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                </div>
                            </div>
                        </div>

                        <!-- Vertical Divider -->
                        <div class="panel-divider"></div>

                        <!-- Right Half: Team Analytics -->
                        <div style="flex: 1; display: flex; flex-direction: column; height: 100%; position: relative;">
                            <!-- Label (replaces radio toggle) -->
                            <div style="display: flex; padding: 0.5rem 0.5rem; justify-content: center; margin-top: 0.25rem; margin-bottom: 0.5rem;">
                                <span style="color: #81828A; font-weight: 500; font-size: 0.85rem;">Team analytics</span>
                            </div>

                            <!-- Header (search bar) -->
                            <div class="unified-header">
                                <div class="header-section">
                                    <div class="channels-search">
                                        <input type="text" id="analytics-team-search" class="search-input" placeholder="Search">
                                    </div>
                                </div>
                            </div>

                            <!-- List Section -->
                            <div class="channels-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0; padding-top: 0;">
                                <div id="analytics-team-list" class="channels-list" style="flex: 1; overflow-y: auto; min-height: 0;">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Page: Interval -->
                    <div id="page-interval" class="page-content" style="height: 100%; display: none;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Analytics Dialog -->
    <div class="analytics-dialog-overlay" id="analytics-dialog-overlay">
        <div class="analytics-dialog">
            <div class="analytics-dialog-header">
                <h3 class="analytics-dialog-title" id="analytics-dialog-title">Member Analytics</h3>
                <button class="analytics-dialog-close" onclick="closeAnalyticsDialog()">&times;</button>
            </div>
            <div class="analytics-tabs">
                <button class="analytics-tab active" data-tab="information" onclick="switchAnalyticsTab('information')">Information</button>
                <button class="analytics-tab" data-tab="dates" onclick="switchAnalyticsTab('dates')">Dates</button>
            </div>
            <div class="analytics-content">
                <!-- Information Panel -->
                <div class="analytics-panel active" id="panel-information">
                    <div id="analytics-info-content">
                        <div class="no-data-message">Loading...</div>
                    </div>
                </div>
                <!-- Dates Panel -->
                <div class="analytics-panel" id="panel-dates">
                    <div class="date-range-container">
                        <div class="date-input-group">
                            <label>From</label>
                            <input type="date" id="analytics-start-date">
                        </div>
                        <div class="date-input-group">
                            <label>To</label>
                            <input type="date" id="analytics-end-date">
                        </div>
                        <button class="apply-dates-btn" onclick="applyDateRange()">Apply</button>
                    </div>
                    <div class="chart-container">
                        <div class="chart-canvas-wrapper">
                            <canvas id="analytics-chart" class="chart-canvas"></canvas>
                            <div class="chart-tooltip" id="chart-tooltip"></div>
                        </div>
                        <div class="chart-summary" id="chart-summary">
                            <div class="chart-summary-item">
                                <div class="chart-summary-value" id="summary-total">0</div>
                                <div class="chart-summary-label">Total Ads</div>
                            </div>
                            <div class="chart-summary-item">
                                <div class="chart-summary-value" id="summary-avg">0</div>
                                <div class="chart-summary-label">Daily Avg</div>
                            </div>
                            <div class="chart-summary-item">
                                <div class="chart-summary-value" id="summary-peak">0</div>
                                <div class="chart-summary-label">Peak Day</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <style>
        /* Analytics Dialog Styles */
        .analytics-dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .analytics-dialog-overlay.show {
            display: flex;
        }

        .analytics-dialog {
            background: #1a1a1d;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .analytics-dialog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #282930;
        }

        .analytics-dialog-title {
            color: #ffffff;
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0;
        }

        .analytics-dialog-close {
            background: none;
            border: none;
            color: #81828A;
            cursor: pointer;
            font-size: 1.5rem;
            line-height: 1;
            padding: 0;
        }

        .analytics-dialog-close:hover {
            color: #ffffff;
        }

        .analytics-tabs {
            display: flex;
            border-bottom: 1px solid #282930;
        }

        .analytics-tab {
            flex: 1;
            padding: 0.75rem;
            background: none;
            border: none;
            color: #81828A;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
        }

        .analytics-tab:hover {
            color: #dcddde;
        }

        .analytics-tab.active {
            color: #15d8bc;
            border-bottom-color: #15d8bc;
        }

        .analytics-content {
            padding: 0.75rem;
            overflow-y: auto;
            flex: 1;
        }

        .analytics-panel {
            display: none;
        }

        .analytics-panel.active {
            display: block;
        }

        .analytics-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #282930;
        }

        .analytics-stat-row:last-child {
            border-bottom: none;
        }

        .analytics-stat-label {
            color: #81828A;
            font-size: 0.9rem;
        }

        .analytics-stat-value {
            color: #dcddde;
            font-weight: 600;
        }

        .analytics-progress-bar {
            width: 100%;
            height: 8px;
            background: #282930;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .analytics-progress-fill {
            height: 100%;
            background: linear-gradient(to right, #15d8bc, #006e59);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Date picker styles */
        .date-range-container {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .date-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .date-input-group label {
            color: #81828A;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .date-input-group input {
            background: #212227;
            border: 1px solid #282930;
            border-radius: 6px;
            padding: 0.5rem;
            color: #dcddde;
            font-size: 0.85rem;
        }

        .date-input-group input:focus {
            outline: none;
            border-color: #15d8bc;
        }

        .date-input-group input[type="date"]::-webkit-calendar-picker-indicator {
            background: url('/static/calendar.png') no-repeat center;
            background-size: contain;
            filter: brightness(0) invert(1);
            cursor: pointer;
        }

        .apply-dates-btn {
            background: transparent;
            border: none;
            color: #15d8bc;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            margin-top: auto;
        }

        .apply-dates-btn:hover {
            color: #10b89e;
        }

        /* Chart styles */
        .chart-container {
            background: #121215;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .chart-canvas-wrapper {
            position: relative;
            width: 100%;
            height: 200px;
            overflow: hidden;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
        }

        .chart-tooltip {
            position: absolute;
            background: #282930;
            color: #dcddde;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 10;
            display: none;
            white-space: nowrap;
        }

        .chart-summary {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #282930;
        }

        .chart-summary-item {
            text-align: center;
        }

        .chart-summary-value {
            color: #15d8bc;
            font-size: 1.2rem;
            font-weight: 700;
        }

        .chart-summary-label {
            color: #81828A;
            font-size: 0.7rem;
            text-transform: uppercase;
            margin-top: 0.25rem;
        }

        .no-data-message {
            text-align: center;
            color: #81828A;
            padding: 2rem;
        }

        /* Member Stats Styles */
        .member-stats-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .member-stat-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: #212227;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .member-stat-item:hover {
            background: #2a2b32;
        }

        .member-stat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
        }

        .member-stat-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .member-stat-info {
            flex: 1;
            min-width: 0;
        }

        .member-stat-username {
            color: #dcddde;
            font-weight: 500;
            font-size: 0.95rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .member-stat-id {
            color: #81828A;
            font-size: 0.8rem;
            font-family: 'gg sans', sans-serif;
        }

        .member-stat-usage {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem 1rem;
            background: #121215;
            border-radius: 6px;
            min-width: 80px;
        }

        .stat-number {
            color: #15d8bc;
            font-weight: 700;
            font-size: 1.2rem;
            line-height: 1;
        }

        .stat-label {
            color: #81828A;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 0.25rem;
        }

        .view-analytics-btn {
            background: linear-gradient(to bottom, #15d8bc, #006e59);
            border: none;
            color: #121215;
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s ease;
            margin-left: auto;
        }

        .view-analytics-btn:hover {
            background: linear-gradient(to bottom, #10b89e, #004e40);
        }
    </style>

    <!-- Tag Limit Popup Modal -->
    <div id="tag-limit-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: #191A1F; border-radius: 12px; padding: 1.5rem; max-width: 400px; width: 90%; text-align: center; display: flex; flex-direction: column; gap: 1rem;">
            <h2 style="color: #dcddde; margin: 0; font-size: 1.25rem;">Tag limit reached</h2>
            <p style="color: #81828A; margin: 0; font-size: 0.9rem;">Maximum 6 tags allowed. Please remove a tag before adding a new one.</p>
            <button class="grey-btn" onclick="closeTagLimitModal()" style="padding: 0.6rem 2rem;">OK</button>
        </div>
    </div>

    <!-- Channel Limit Per Server Modal -->
    <div id="channel-limit-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: #191A1F; border-radius: 12px; padding: 1.5rem; max-width: 400px; width: 90%; text-align: center; display: flex; flex-direction: column; gap: 1rem;">
            <h2 style="color: #dcddde; margin: 0; font-size: 1.25rem;">Channel limit reached</h2>
            <p id="channel-limit-message" style="color: #81828A; margin: 0; font-size: 0.9rem;">You can only select up to X channels per server on your current plan.</p>
            <button class="grey-btn" onclick="closeChannelLimitModal()" style="padding: 0.6rem 2rem;">OK</button>
        </div>
    </div>

    <script>
        // Tag Limit Modal functions
        function showTagLimitModal() {
            document.getElementById('tag-limit-modal').style.display = 'flex';
        }

        function closeTagLimitModal() {
            document.getElementById('tag-limit-modal').style.display = 'none';
        }

        // Channel Limit Modal functions
        function showChannelLimitModal(limit) {
            document.getElementById('channel-limit-message').textContent =
                `You can only select up to ${limit} channel${limit !== 1 ? 's' : ''} per server on your current plan.`;
            document.getElementById('channel-limit-modal').style.display = 'flex';
        }

        function closeChannelLimitModal() {
            document.getElementById('channel-limit-modal').style.display = 'none';
        }

        // Close modals when clicking outside
        document.getElementById('tag-limit-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeTagLimitModal();
            }
        });
        document.getElementById('channel-limit-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeChannelLimitModal();
            }
        });
        // Prevent page from being stored in cache
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                window.location.reload();
            }
        });

        // Global function to show collapsible send results (used by both Personal and Team panels)
        async function showSendResults(succeeded, rateLimited, failed) {
            // Determine title and icon
            let title, icon;
            if (succeeded.length === 0 && (rateLimited.length > 0 || failed.length > 0)) {
                title = 'Failed to send';
                icon = 'error';
            } else {
                title = 'Send succeeded';
                icon = 'success';
            }

            // Build collapsible sections HTML
            let sectionsHTML = '';

            // Success section
            if (succeeded.length > 0) {
                sectionsHTML += `
                    <div class="result-section collapsed">
                        <div class="result-header" onclick="this.parentElement.classList.toggle('collapsed')">
                            <span>Send succeeded (${succeeded.length} Channel${succeeded.length !== 1 ? 's' : ''})</span>
                            <img src="/static/openorclose.png" class="collapse-icon" style="width: 16px; height: 16px; transition: transform 0.2s;">
                        </div>
                        <div class="result-content">
                            ${succeeded.map(ch => `<div class="result-channel-item"># ${ch}</div>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Rate limited section
            if (rateLimited.length > 0) {
                sectionsHTML += `
                    <div class="result-section collapsed">
                        <div class="result-header" onclick="this.parentElement.classList.toggle('collapsed')">
                            <span>Send rate limited (${rateLimited.length} Channel${rateLimited.length !== 1 ? 's' : ''})</span>
                            <img src="/static/openorclose.png" class="collapse-icon" style="width: 16px; height: 16px; transition: transform 0.2s;">
                        </div>
                        <div class="result-content">
                            ${rateLimited.map(ch => `<div class="result-channel-item"># ${ch}</div>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Failed section
            if (failed.length > 0) {
                sectionsHTML += `
                    <div class="result-section collapsed">
                        <div class="result-header" onclick="this.parentElement.classList.toggle('collapsed')">
                            <span>Send failed (${failed.length} Channel${failed.length !== 1 ? 's' : ''})</span>
                            <img src="/static/openorclose.png" class="collapse-icon" style="width: 16px; height: 16px; transition: transform 0.2s;">
                        </div>
                        <div class="result-content">
                            ${failed.map(ch => `<div class="result-channel-item"># ${ch}</div>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Create custom modal
            const modalHTML = `
                <style>
                    .result-section {
                        margin: 0 !important;
                        padding: 0 !important;
                        display: block !important;
                    }
                    .result-section.collapsed .result-content {
                        display: none;
                    }
                    .result-section.collapsed .collapse-icon {
                        transform: rotate(180deg);
                    }
                    .result-header {
                        padding: 0 !important;
                        margin: 0 !important;
                        cursor: pointer;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        font-weight: 500;
                        color: #dcddde;
                        user-select: none;
                        font-size: 0.85rem;
                        line-height: 1;
                    }
                    .result-header:hover {
                        opacity: 0.8;
                    }
                    .result-header span {
                        margin: 0 !important;
                        padding: 0 !important;
                        line-height: 1;
                    }
                    .result-content {
                        max-height: 150px;
                        overflow-y: auto;
                        overflow-x: hidden;
                        padding: 0 !important;
                        margin: 0 !important;
                        scroll-behavior: auto;
                    }
                    .result-content::-webkit-scrollbar {
                        width: 5px;
                    }
                    .result-content::-webkit-scrollbar-track {
                        background: transparent;
                    }
                    .result-content::-webkit-scrollbar-thumb {
                        background: rgba(255, 255, 255, 0.2);
                        border-radius: 3px;
                    }
                    .result-channel-item {
                        padding: 0 !important;
                        margin: 0 !important;
                        color: #81828A;
                        font-size: 0.75rem;
                        background: transparent;
                        line-height: 1;
                        display: block !important;
                    }
                </style>
                <div style="max-height: 300px; overflow-y: auto; overflow-x: hidden; scroll-behavior: auto; padding: 0 !important; margin: 0 !important; display: flex; flex-direction: column; gap: 0;">
                    ${sectionsHTML}
                </div>
            `;

            await showAlert(modalHTML, title, { icon: icon, allowHtml: true });
        }

        // Side menu page switching
        document.addEventListener('DOMContentLoaded', function() {
            const menuItems = document.querySelectorAll('.menu-item[data-page]');
            const pageContents = document.querySelectorAll('.page-content');

            // Server-side validated access flags (cannot be bypassed via inspect element)
            const hasGuilds = {{ 'true' if guilds else 'false' }};
            const hasTeam = {{ 'true' if has_team else 'false' }};
            const isTeamOwner = {{ 'true' if is_team_owner else 'false' }};

            // Set correct initial page display for team owners
            if (isTeamOwner && hasGuilds) {
                pageContents.forEach(page => {
                    if (page.id === 'page-team-panel') {
                        page.style.display = 'flex';
                    } else if (page.id === 'page-personal-panel') {
                        page.style.display = 'none';
                    }
                });
            }

            menuItems.forEach(item => {
                item.addEventListener('click', () => {
                    // Skip if button is disabled (server-side check)
                    if (item.disabled || item.classList.contains('disabled')) {
                        return;
                    }

                    const targetPage = item.dataset.page;

                    // Server-side validated access control (cannot bypass with inspect element)
                    if (targetPage === 'personal-panel' && (!hasGuilds || isTeamOwner)) {
                        return;
                    }
                    if (targetPage === 'team-panel' && (!hasTeam || !hasGuilds)) {
                        return;
                    }
                    if (targetPage === 'team-management' && !isTeamOwner) {
                        return;
                    }

                    // Update active state on menu items
                    menuItems.forEach(mi => mi.classList.remove('active'));
                    item.classList.add('active');

                    // Show/hide pages
                    pageContents.forEach(page => {
                        if (page.id === `page-${targetPage}`) {
                            page.style.display = 'flex';
                        } else {
                            page.style.display = 'none';
                        }
                    });
                });
            });
        });

        // Wait for all elements to load before initializing
        document.addEventListener('DOMContentLoaded', function() {
            const serverSidebar = document.getElementById('server-sidebar');
            const channelsList = document.getElementById('channels-list');
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const charCount = document.getElementById('char-count');
            const channelSearch = document.getElementById('channel-search');
            const searchTagsContainer = document.getElementById('search-tags');
            const MESSAGE_LIMIT = 2000; // Character limit for messages

            let guilds = [];
            let serverChannels = {}; // Cache for channels by guild ID
            let selectedChannels = []; // Array for multiple channel selection
            let selectedGuild = null; // Currently selected guild
            let searchTags = []; // Search filter tags
            let currentServerColor = 'rgba(21, 216, 188, 0.6)'; // Current server's dominant color
            let isSending = false; // Track if messages are being sent
            let failedChannels = new Map(); // Track channels that failed to send with failure type
            let viewMode = 'servers'; // 'servers', 'channels', or 'selected'
            let channelsOnlySearchText = ''; // Search filter for channels-only mode
            let channelsOnlySearchTags = []; // Search filter tags for channels-only mode
            let selectedChannelsModeSearchText = ''; // Search filter for selected channels mode
            const maxChannelsPerServer = {{ plan_status.max_channels_per_server if plan_status and plan_status.max_channels_per_server is defined else 2 }}; // -1 = unlimited

            // View mode toggle elements
            const viewModeRadios = document.querySelectorAll('input[name="view-mode"]');
            const serversModeHeader = document.querySelector('.servers-mode-header');
            const channelsOnlyHeader = document.querySelector('.channels-only-header');
            const selectedChannelsModeHeader = document.querySelector('.selected-channels-mode-header');
            const serversModeSections = document.querySelectorAll('.servers-mode-section');
            const channelsOnlySection = document.querySelector('.channels-only-section');
            const selectedChannelsModeSection = document.querySelector('.selected-channels-mode-section');
            const channelsOnlyList = document.getElementById('channels-only-list');
            const selectedChannelsModeList = document.getElementById('selected-channels-mode-list');
            const channelsOnlySearch = document.getElementById('channels-only-search');
            const selectedChannelsModeSearch = document.getElementById('selected-channels-mode-search');
            const channelsOnlySearchTagsContainer = document.getElementById('channels-only-search-tags');

            // View mode toggle handler (radio buttons)
            viewModeRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    const mode = radio.value;
                    if (mode === viewMode) return;

                    viewMode = mode;

                    // Hide all headers and sections first
                    serversModeHeader.style.display = 'none';
                    channelsOnlyHeader.style.display = 'none';
                    selectedChannelsModeHeader.style.display = 'none';
                    serversModeSections.forEach(s => s.style.display = 'none');
                    channelsOnlySection.style.display = 'none';
                    selectedChannelsModeSection.style.display = 'none';

                    // Show the appropriate mode
                    if (mode === 'servers') {
                        serversModeHeader.style.display = '';
                        serversModeSections.forEach(s => s.style.display = '');
                    } else if (mode === 'channels') {
                        channelsOnlyHeader.style.display = '';
                        channelsOnlySection.style.display = 'flex';
                        renderChannelsOnlyMode();
                    } else if (mode === 'selected') {
                        selectedChannelsModeHeader.style.display = '';
                        selectedChannelsModeSection.style.display = 'flex';
                        renderSelectedChannelsMode();
                    }
                });
            });

            // Selected channels mode search handler
            if (selectedChannelsModeSearch) {
                selectedChannelsModeSearch.addEventListener('input', (e) => {
                    selectedChannelsModeSearchText = e.target.value.toLowerCase();
                    renderSelectedChannelsMode();
                });
            }

            // Render channels in selected channels mode (shows selected channels with x.png to remove)
            function renderSelectedChannelsMode() {
                if (!selectedChannelsModeList) return;

                if (selectedChannels.length === 0) {
                    selectedChannelsModeList.innerHTML = '<div class="no-selection">No channels selected</div>';
                    return;
                }

                // Filter by search text
                let filteredChannels = selectedChannels;
                if (selectedChannelsModeSearchText) {
                    filteredChannels = selectedChannels.filter(ch =>
                        ch.name.toLowerCase().includes(selectedChannelsModeSearchText) ||
                        ch.guildName.toLowerCase().includes(selectedChannelsModeSearchText)
                    );
                }

                if (filteredChannels.length === 0) {
                    selectedChannelsModeList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                selectedChannelsModeList.innerHTML = filteredChannels.map(channel => {
                    const iconUrl = channel.guildIcon
                        ? `https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png`
                        : null;

                    const serverIconHtml = iconUrl
                        ? `<img class="server-icon-small" src="${iconUrl}" alt="">`
                        : `<div class="server-icon-placeholder-small">${channel.guildName[0].toUpperCase()}</div>`;

                    // Check if channel failed
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    const failedInfo = failedChannels.get(channelKey);
                    const isFailed = !!failedInfo;
                    const failedClass = isFailed ? ' failed' : '';
                    const statusText = failedInfo?.type === 'ratelimit' ? 'Rate limited' : 'Missing permission';
                    const statusTagHtml = isFailed ? `<span class="channel-status-tag">${statusText}</span>` : '';

                    return `<div class="channel-item selected${failedClass}" data-channel-id="${channel.id}" data-channel-name="${channel.name}" data-guild-id="${channel.guildId}" data-guild-name="${channel.guildName}" data-guild-icon="${channel.guildIcon || ''}">${serverIconHtml}<span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right">${statusTagHtml}<img class="channel-tick" src="{{ url_for('static', filename='x.png') }}" alt="x"></div></div>`;
                }).join('');

                // Add click handlers to remove channels
                selectedChannelsModeList.querySelectorAll('.channel-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const channelId = item.dataset.channelId;
                        const guildId = item.dataset.guildId;

                        // Remove from selected channels
                        selectedChannels = selectedChannels.filter(ch =>
                            !(ch.id === channelId && ch.guildId === guildId)
                        );

                        saveSelectedChannels();
                        renderSelectedChannelsMode();
                        updateServerCount(guildId);
                        updateSendButton();

                        // Also update other views if they exist
                        if (selectedGuild && selectedGuild.id === guildId) {
                            renderChannels();
                        }
                    });
                });
            }

            // Channels-only search handler
            if (channelsOnlySearch) {
                channelsOnlySearch.addEventListener('input', (e) => {
                    channelsOnlySearchText = e.target.value.toLowerCase();
                    renderChannelsOnlyMode();
                });
                channelsOnlySearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && channelsOnlySearch.value.trim()) {
                        addChannelsOnlySearchTag(channelsOnlySearch.value);
                    }
                });
            }

            // Add search tag for channels-only mode
            function addChannelsOnlySearchTag(text) {
                if (channelsOnlySearchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                if (!channelsOnlySearchTags.includes(text.toLowerCase()) && text.trim()) {
                    channelsOnlySearchTags.push(text.toLowerCase());
                    updateChannelsOnlySearchTagsDisplay();
                    channelsOnlySearch.value = '';
                    channelsOnlySearchText = '';
                    renderChannelsOnlyMode();
                }
            }

            // Remove search tag for channels-only mode
            function removeChannelsOnlySearchTag(tag) {
                channelsOnlySearchTags = channelsOnlySearchTags.filter(t => t !== tag);
                updateChannelsOnlySearchTagsDisplay();
                renderChannelsOnlyMode();
            }

            // Update search tags display for channels-only mode
            function updateChannelsOnlySearchTagsDisplay() {
                if (!channelsOnlySearchTagsContainer) return;
                channelsOnlySearchTagsContainer.innerHTML = '';
                channelsOnlySearchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}"></span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        removeChannelsOnlySearchTag(tag);
                    });
                    channelsOnlySearchTagsContainer.appendChild(tagEl);
                });
            }

            // Render channels in channels-only mode (with server icons)
            function renderChannelsOnlyMode() {
                if (!channelsOnlyList) return;

                // Check if any channels have been loaded
                const hasLoadedChannels = Object.keys(serverChannels).length > 0;

                // Collect all channels from all servers
                let allChannels = [];
                for (const guild of guilds) {
                    const channels = serverChannels[guild.id] || [];
                    for (const channel of channels) {
                        allChannels.push({
                            ...channel,
                            guildId: guild.id,
                            guildName: guild.name,
                            guildIcon: guild.icon
                        });
                    }
                }

                // Filter by search tags (OR logic - any tag matches)
                if (channelsOnlySearchTags.length > 0) {
                    allChannels = allChannels.filter(ch =>
                        channelsOnlySearchTags.some(tag =>
                            ch.name.toLowerCase().includes(tag) ||
                            ch.guildName.toLowerCase().includes(tag)
                        )
                    );
                }

                // Filter by search text
                if (channelsOnlySearchText) {
                    allChannels = allChannels.filter(ch =>
                        ch.name.toLowerCase().includes(channelsOnlySearchText) ||
                        ch.guildName.toLowerCase().includes(channelsOnlySearchText)
                    );
                }

                if (allChannels.length === 0) {
                    if (!hasLoadedChannels) {
                        // Channels haven't been loaded yet - show loading message
                        channelsOnlyList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';
                    } else if (channelsOnlySearchText || channelsOnlySearchTags.length > 0) {
                        // Channels loaded but filtered to empty
                        channelsOnlyList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    } else {
                        // Channels loaded but none available
                        channelsOnlyList.innerHTML = '<div class="no-selection">No channels found</div>';
                    }
                    return;
                }

                channelsOnlyList.innerHTML = allChannels.map(channel => {
                    const isSelected = selectedChannels.some(ch => ch.id === channel.id);
                    const iconUrl = channel.guildIcon
                        ? `https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png`
                        : null;

                    const serverIconHtml = iconUrl
                        ? `<img class="server-icon-small" src="${iconUrl}" alt="">`
                        : `<div class="server-icon-placeholder-small">${channel.guildName[0].toUpperCase()}</div>`;

                    // No failed status shown in channels-only mode
                    return `<div class="channel-item ${isSelected ? 'selected' : ''}" data-channel-id="${channel.id}" data-channel-name="${channel.name}" data-guild-id="${channel.guildId}" data-guild-name="${channel.guildName}" data-guild-icon="${channel.guildIcon || ''}">${serverIconHtml}<span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right"><img class="channel-tick" src="{{ url_for('static', filename='tick.png') }}" alt=""></div></div>`;
                }).join('');

                // Add click handlers
                channelsOnlyList.querySelectorAll('.channel-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const channelId = item.dataset.channelId;
                        const channelName = item.dataset.channelName;
                        const guildId = item.dataset.guildId;
                        const guildName = item.dataset.guildName;
                        const guildIcon = item.dataset.guildIcon;

                        toggleChannelSelection({
                            id: channelId,
                            name: channelName,
                            guildId: guildId,
                            guildName: guildName,
                            guildIcon: guildIcon
                        });

                        // Update selection state (no glow effects)
                        const isNowSelected = selectedChannels.some(ch => ch.id === channelId);
                        if (isNowSelected) {
                            item.classList.add('selected');
                        } else {
                            item.classList.remove('selected');
                        }
                    });
                });
            }

            // Check session on API error
            async function handleSessionError(response) {
                if (response.status === 401) {
                    // Session expired or token invalid - redirect to settings
                    window.location.href = '/settings';
                }
                return false;
            }

            // Warn user before leaving if messages are being sent
            window.addEventListener('beforeunload', (e) => {
                if (isSending) {
                    e.preventDefault();
                    e.returnValue = '';
                    return '';
                }
            });

            // Dropdown menu toggle
            const menuIcon = document.getElementById('menu-icon');
            const dropdownMenu = document.getElementById('dropdown-menu');

            if (menuIcon) {
                menuIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    dropdownMenu.classList.toggle('show');
                });
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (dropdownMenu && !dropdownMenu.contains(e.target) && menuIcon && !menuIcon.contains(e.target)) {
                    dropdownMenu.classList.remove('show');
                }
            });

            // Menu item navigation
            const menuItems = document.querySelectorAll('.menu-item');
            menuItems.forEach(item => {
                item.addEventListener('click', function() {
                    menuItems.forEach(i => i.classList.remove('active'));
                    this.classList.add('active');
                });
            });

            // Load saved data from localStorage (persists across sessions)
            function loadSelectedChannels() {
                const saved = localStorage.getItem('selectedChannels');
                if (saved) {
                    try {
                        selectedChannels = JSON.parse(saved);
                    } catch (e) {
                        console.error('Error loading saved channels:', e);
                        selectedChannels = [];
                    }
                }
            }

            function loadMessageText() {
                const saved = localStorage.getItem('messageText');
                if (saved && messageInput) {
                    messageInput.value = saved;
                    updateCharCount();
                }
            }

            // Load user data from database
            async function loadUserDataFromDB() {
                try {
                    const response = await fetch('/api/get-user-data');
                    if (response.ok) {
                        const data = await response.json();

                        // Load selected channels if available
                        if (data.selected_channels && Array.isArray(data.selected_channels)) {
                            selectedChannels = data.selected_channels;
                            localStorage.setItem('selectedChannels', JSON.stringify(selectedChannels));
                        }

                        // Load draft message if available
                        if (data.draft_message !== null && data.draft_message !== undefined && messageInput) {
                            messageInput.value = data.draft_message;
                            localStorage.setItem('messageText', data.draft_message);
                            updateCharCount();
                        }

                        return true;
                    } else {
                        console.warn('Failed to load user data from database, using localStorage fallback');
                        return false;
                    }
                } catch (error) {
                    console.error('Error loading user data from database:', error);
                    return false;
                }
            }

            // Save user data to database
            async function saveUserDataToDB() {
                try {
                    const response = await fetch('/api/save-user-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-Token': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({
                            selected_channels: selectedChannels,
                            draft_message: messageInput ? messageInput.value : ''
                        })
                    });

                    if (!response.ok) {
                        console.warn('Failed to save user data to database');
                        return false;
                    }

                    return true;
                } catch (error) {
                    console.error('Error saving user data to database:', error);
                    return false;
                }
            }

            // Save data to localStorage (persists across sessions)
            function saveSelectedChannels() {
                localStorage.setItem('selectedChannels', JSON.stringify(selectedChannels));
                // Also save to database
                saveUserDataToDB();
            }

            function saveMessageText() {
                if (messageInput) {
                    localStorage.setItem('messageText', messageInput.value);
                    // Also save to database
                    saveUserDataToDB();
                }
            }

            // Add search tag
            function addSearchTag(text) {
                if (searchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                if (!searchTags.includes(text.toLowerCase()) && text.trim()) {
                    searchTags.push(text.toLowerCase());
                    updateSearchTagsDisplay();
                    channelSearch.value = '';
                    if (selectedGuild) {
                        renderChannels();
                    }
                }
            }

            // Remove search tag
            function removeSearchTag(tag) {
                searchTags = searchTags.filter(t => t !== tag);
                updateSearchTagsDisplay();
                if (selectedGuild) {
                    renderChannels();
                }
            }

            // Update search tags display
            function updateSearchTagsDisplay() {
                searchTagsContainer.innerHTML = '';
                searchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}"></span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        removeSearchTag(tag);
                    });
                    searchTagsContainer.appendChild(tagEl);
                });
            }

            // Handle channel search input
            if (channelSearch) {
                channelSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && channelSearch.value.trim()) {
                        addSearchTag(channelSearch.value);
                    }
                });
            }

            // Render Discord-style server sidebar icons
            function renderServers() {
                if (!serverSidebar) return;

                serverSidebar.innerHTML = '';

                if (!guilds || guilds.length === 0) {
                    return;
                }

                guilds.forEach(guild => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'server-icon-wrapper';
                    wrapper.dataset.guildId = guild.id;
                    wrapper.title = guild.name;

                    const iconHtml = guild.icon
                        ? `<img src="https://cdn.discordapp.com/icons/${guild.id}/${guild.icon}.png?size=96" alt="${guild.name}">`
                        : `<span class="server-icon-placeholder">${guild.name.charAt(0).toUpperCase()}</span>`;

                    wrapper.innerHTML = `
                        <div class="server-icon-pill"></div>
                        <div class="server-icon-holder">
                            ${iconHtml}
                        </div>
                    `;

                    wrapper.addEventListener('click', () => selectServer(guild));
                    serverSidebar.appendChild(wrapper);

                    // Restore active state if this is the selected guild
                    if (selectedGuild && selectedGuild.id === guild.id) {
                        wrapper.classList.add('active');
                    }
                });
            }

            // Preload all channels for all guilds (for channels-only mode)
            async function preloadAllChannels() {
                const promises = guilds.map(async (guild) => {
                    if (!serverChannels[guild.id]) {
                        try {
                            const response = await fetch(`/api/guild/${guild.id}/channels`);
                            const data = await response.json();

                            if (data.token_invalid) {
                                return; // Skip, will handle redirect elsewhere
                            }

                            if (data.channels) {
                                serverChannels[guild.id] = data.channels.filter(ch => ch.type === 0).sort((a, b) => a.position - b.position);
                            } else {
                                serverChannels[guild.id] = [];
                            }

                            // Update channels-only view progressively as each guild loads
                            if (viewMode === 'channels') {
                                renderChannelsOnlyMode();
                            }
                        } catch (error) {
                            console.error(`Error preloading channels for ${guild.name}:`, error);
                            serverChannels[guild.id] = [];
                        }
                    }
                });

                await Promise.all(promises);
            }

            // Fetch all guilds and build UI
            async function initializeUI() {
                // Load from localStorage first (instant)
                loadSelectedChannels();
                loadMessageText();

                // Then load from database (syncs across devices)
                await loadUserDataFromDB();

                guilds = {{ guilds|tojson }};

                // Remove selected channels from servers that no longer exist (user left server)
                const guildIds = new Set(guilds.map(g => g.id));
                const originalLength = selectedChannels.length;
                selectedChannels = selectedChannels.filter(ch => guildIds.has(ch.guildId));

                // Save if any channels were removed
                if (selectedChannels.length !== originalLength) {
                    saveSelectedChannels();
                    saveUserDataToDB();
                }

                // Render servers
                renderServers();

                // Update selected display
                updateSelectedDisplay();
                updateSendButton();
                updateCharCount(); // Initialize character count display

                // Preload all channels in background for faster channel-only mode
                preloadAllChannels();
            }

            // Extract dominant color from image
            function getDominantColor(imageUrl, callback) {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    let r = 0, g = 0, b = 0, count = 0;

                    // Sample every 10th pixel for performance
                    for (let i = 0; i < data.length; i += 40) {
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        count++;
                    }

                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    callback(`rgb(${r}, ${g}, ${b})`);
                };
                img.onerror = function() {
                    callback('rgba(21, 216, 188, 0.6)'); // Fallback to default turquoise
                };
                img.src = imageUrl;
            }

            // Select a server and load its channels
            async function selectServer(guild) {
                // Set selected guild immediately
                selectedGuild = guild;
                const guildId = guild.id;

                // Update active state in server sidebar
                document.querySelectorAll('.server-icon-wrapper').forEach(item => {
                    item.classList.remove('active');
                });

                const activeItem = serverSidebar.querySelector(`[data-guild-id="${guildId}"]`);
                if (activeItem) {
                    activeItem.classList.add('active');
                }

                // Apply dominant color from server icon
                if (guild.icon) {
                    const iconUrl = `https://cdn.discordapp.com/icons/${guildId}/${guild.icon}.png`;
                    getDominantColor(iconUrl, (color) => {
                        // Only update if this guild is still selected
                        if (selectedGuild && selectedGuild.id === guildId) {
                            currentServerColor = color;
                        }
                    });
                } else {
                    // Use default color for servers without icons
                    currentServerColor = 'rgba(21, 216, 188, 0.6)';
                }

                // Load channels if not cached
                if (!serverChannels[guildId]) {
                    channelsList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';

                    try {
                        const response = await fetch(`/api/guild/${guildId}/channels`);

                        // Check if this guild is still selected
                        if (!selectedGuild || selectedGuild.id !== guildId) {
                            return;
                        }

                        const data = await response.json();

                        // Check for token_invalid error - redirect to settings
                        if (data.token_invalid) {
                            window.location.href = '/settings';
                            return;
                        }

                        if (!response.ok) {
                            await handleSessionError(response);
                            return;
                        }

                        if (data.channels) {
                            serverChannels[guildId] = data.channels.filter(ch => ch.type === 0).sort((a, b) => a.position - b.position);
                        } else {
                            serverChannels[guildId] = [];
                        }
                    } catch (error) {
                        console.error(`Error fetching channels:`, error);
                        serverChannels[guildId] = [];
                    }
                }

                // Only render if this guild is still selected
                if (selectedGuild && selectedGuild.id === guildId) {
                    renderChannels();
                }

                // Also update channels-only mode if active
                if (viewMode === 'channels') {
                    renderChannelsOnlyMode();
                }
            }

            // Render channels for selected server
            function renderChannels() {
                if (!selectedGuild) {
                    channelsList.innerHTML = '<div class="no-selection">Select a server to view channels</div>';
                    return;
                }

                channelsList.innerHTML = '';
                const channels = serverChannels[selectedGuild.id] || [];

                if (channels.length === 0) {
                    channelsList.innerHTML = '<div class="no-selection">No channels found</div>';
                    return;
                }

                // Filter channels by search tags (OR logic - any tag matches)
                let filteredChannels = channels;
                if (searchTags.length > 0) {
                    filteredChannels = channels.filter(channel =>
                        searchTags.some(tag => channel.name.toLowerCase().includes(tag))
                    );
                }

                if (filteredChannels.length === 0) {
                    channelsList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                filteredChannels.forEach(channel => {
                    const isSelected = selectedChannels.some(ch =>
                        ch.id === channel.id && ch.guildId === selectedGuild.id
                    );

                    const channelItem = document.createElement('div');
                    channelItem.className = `channel-item ${isSelected ? 'selected' : ''}`;
                    channelItem.dataset.channelId = channel.id;

                    // Discord-style layout: # name tick (no failed status in servers mode)
                    channelItem.innerHTML = `<span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right"><img class="channel-tick" src="{{ url_for('static', filename='tick.png') }}" alt=""></div>`;

                    // Click anywhere on channel item to toggle selection
                    channelItem.addEventListener('click', () => {
                        // Check current selection state at click time, not render time
                        const currentlySelected = selectedChannels.some(ch =>
                            ch.id === channel.id && ch.guildId === selectedGuild.id
                        );
                        toggleChannel(channel, !currentlySelected);
                    });

                    channelsList.appendChild(channelItem);
                });
            }

            // Toggle channel selection for channels-only mode
            function toggleChannelSelection(channel) {
                const isCurrentlySelected = selectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === channel.guildId
                );

                if (!isCurrentlySelected) {
                    // Check channel limit per server (-1 means unlimited)
                    if (maxChannelsPerServer !== -1) {
                        const currentServerChannelCount = selectedChannels.filter(ch =>
                            ch.guildId === channel.guildId
                        ).length;

                        if (currentServerChannelCount >= maxChannelsPerServer) {
                            showChannelLimitModal(maxChannelsPerServer);
                            return;
                        }
                    }

                    selectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: channel.guildId,
                        guildName: channel.guildName,
                        guildIcon: channel.guildIcon || null
                    });
                    // Clear any failed status when re-selecting
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    failedChannels.delete(channelKey);
                } else {
                    selectedChannels = selectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === channel.guildId)
                    );
                }

                // Save to localStorage
                saveSelectedChannels();

                // Update UI
                updateServerCount(channel.guildId);
                updateSelectedDisplay();
                updateSendButton();
            }

            // Toggle channel selection
            function toggleChannel(channel, isChecked) {
                if (!selectedGuild) return;

                const isCurrentlySelected = selectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === selectedGuild.id
                );

                if (isChecked && !isCurrentlySelected) {
                    // Check channel limit per server (-1 means unlimited)
                    if (maxChannelsPerServer !== -1) {
                        const currentServerChannelCount = selectedChannels.filter(ch =>
                            ch.guildId === selectedGuild.id
                        ).length;

                        if (currentServerChannelCount >= maxChannelsPerServer) {
                            showChannelLimitModal(maxChannelsPerServer);
                            return;
                        }
                    }

                    selectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: selectedGuild.id,
                        guildName: selectedGuild.name,
                        guildIcon: selectedGuild.icon || null
                    });
                    // Clear any failed status when re-selecting
                    const channelKey = `${selectedGuild.id}-${channel.id}`;
                    failedChannels.delete(channelKey);
                } else if (!isChecked && isCurrentlySelected) {
                    selectedChannels = selectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === selectedGuild.id)
                    );
                }

                // Save to localStorage
                saveSelectedChannels();

                // Update UI
                renderChannels();
                updateServerCount(selectedGuild.id);
                updateSelectedDisplay();
                updateSendButton();
            }

            // Update count badge on server
            function updateServerCount(guildId) {
                const count = selectedChannels.filter(ch => ch.guildId === guildId).length;
                const serverItem = document.querySelector(`[data-guild-id="${guildId}"]`);
                if (serverItem) {
                    const countEl = serverItem.querySelector('.server-count');
                    if (countEl) {
                        if (count > 0) {
                            countEl.textContent = `${count} selected`;
                            countEl.style.display = 'block';
                            serverItem.classList.add('has-selection');
                        } else {
                            countEl.style.display = 'none';
                            serverItem.classList.remove('has-selection');
                        }
                    }
                }
            }

            // Update only a specific channel's failed status - only refreshes Selected channels view
            function updateFailedChannelStatus(channel) {
                // Failed status only shows in Selected channels mode
                if (viewMode === 'selected') {
                    renderSelectedChannelsMode();
                }
            }

            // Update selected channels display (now just updates the selected channels mode view)
            function updateSelectedDisplay() {
                // Update selected channels mode view if it's active
                if (viewMode === 'selected') {
                    renderSelectedChannelsMode();
                }
                // Also update channels-only mode to reflect selection changes
                if (viewMode === 'channels') {
                    renderChannelsOnlyMode();
                }
            }

            // Update send button state
            function updateSendButton() {
                if (sendBtn && messageInput) {
                    const isOverLimit = messageInput.value.length > MESSAGE_LIMIT;
                    sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim() || isOverLimit;
                }
            }

            // Update character count display
            function updateCharCount() {
                if (charCount && messageInput) {
                    const remaining = MESSAGE_LIMIT - messageInput.value.length;
                    charCount.textContent = remaining;

                    // Apply red color when negative (over limit)
                    if (remaining < 0) {
                        charCount.style.color = '#991a35'; // Red from delete account button gradient
                    } else {
                        charCount.style.color = '#81828A'; // Default grey
                    }
                }
            }

            // Message input listener
            if (messageInput) {
                messageInput.addEventListener('input', function() {
                    updateCharCount();
                    saveMessageText();
                    updateSendButton();
                });
            }

            // Emoji button is just an icon - no picker functionality

            // Send button handler
            if (sendBtn) {
                sendBtn.addEventListener('click', async function() {
                    if (selectedChannels.length > 0 && messageInput && messageInput.value.trim()) {
                        // Check for filtered content before proceeding
                        const message = messageInput.value.trim();
                        const filteredWords = {{ BLACKLISTED_WORDS|tojson }};
                        const phraseExceptions = {{ PHRASE_EXCEPTIONS|tojson }};

                        // Function to check if a word occurrence is within an exception phrase
                        function isWordInException(word, messageLower) {
                            const wordLower = word.toLowerCase();
                            const exceptions = phraseExceptions[wordLower] || [];

                            if (exceptions.length === 0) return false;

                            // Find all occurrences of the blacklisted word
                            let startIndex = 0;
                            while (true) {
                                const pos = messageLower.indexOf(wordLower, startIndex);
                                if (pos === -1) break;

                                const wordEnd = pos + wordLower.length;
                                let isException = false;

                                // Check if this occurrence is within any exception phrase
                                for (const exception of exceptions) {
                                    const excLower = exception.toLowerCase();
                                    const excPos = messageLower.indexOf(excLower);
                                    if (excPos !== -1 && excPos <= pos && (excPos + excLower.length) >= wordEnd) {
                                        isException = true;
                                        break;
                                    }
                                }

                                // If any occurrence is not an exception, word is blocked
                                if (!isException) return false;

                                startIndex = pos + 1;
                            }

                            return true; // All occurrences are within exceptions
                        }

                        // Check message against blacklist (case-insensitive) - find ALL matches
                        const messageLower = message.toLowerCase();
                        let foundWords = [];

                        for (const word of filteredWords) {
                            if (messageLower.includes(word.toLowerCase())) {
                                // Check if word is part of an exception phrase
                                if (!isWordInException(word, messageLower)) {
                                    foundWords.push(word);
                                }
                            }
                        }

                        if (foundWords.length > 0) {
                            // Flag the user for using banned words
                            try {
                                await fetch('/api/flag-self', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({ words: foundWords })
                                });
                            } catch (e) {
                                console.error('Failed to report flagged content:', e);
                            }

                            await showAlert(`Banned words used\n\nYour message contains prohibited content:\n ${foundWords.join('\n ')}\n\nPlease remove this content from your message before sending.`, 'Warning');
                            return; // Stop execution
                        }

                        // Show confirmation popup
                        const channelCount = selectedChannels.length;
                        const confirmed = await showConfirm(`Send message to ${channelCount} channel${channelCount !== 1 ? 's' : ''}?`, 'Send Message', { confirmText: 'Send' });
                        if (!confirmed) return;

                        // Clear previous failed channels
                        failedChannels.clear();

                        isSending = true;
                        sendBtn.disabled = true;
                        sendBtn.innerHTML = '<span id="send-progress">Sending...</span>';

                        // Send messages one by one for real-time usage tracking
                        let succeededChannels = [];
                        let rateLimitedChannels = [];
                        let failedChannelsList = [];

                        // Helper function to wait/delay
                        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

                        // Get custom delay setting from database (default to 1000ms)
                        const customDelay = parseInt('{{ user_data.message_delay }}') || 1000;

                        // Get progress element for smooth updates
                        const progressEl = document.getElementById('send-progress');

                        try {
                            for (let i = 0; i < selectedChannels.length; i++) {
                                const channel = selectedChannels[i];

                                // Update progress text only (keeps spinner smooth)
                                if (progressEl) {
                                    progressEl.textContent = `Sending ${i + 1}/${selectedChannels.length}...`;
                                }

                                // Send message (no retry for rate limits)
                                const response = await fetch('/api/send-message-single', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({
                                        channel: channel,
                                        message: messageInput.value
                                    })
                                });

                                const result = await response.json();

                                // Check if send was successful (200/201 response)
                                if (response.ok && result.success) {
                                    succeededChannels.push(channel.name);
                                    // Clear any previous failure status for this channel
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.delete(channelKey);
                                    updateFailedChannelStatus(channel);
                                } else if (result.token_invalid) {
                                    // Token is invalid - redirect to settings
                                    window.location.href = '/settings';
                                    return; // Stop execution
                                } else if (result.limit_reached) {
                                    // Usage limit reached - redirect to settings
                                    await showAlert('Usage limit reached!\n\nYou have reached your message limit for this period.\nRedirecting to settings page...', 'Limit reached');
                                    window.location.href = '/settings';
                                    return; // Stop execution
                                } else if (response.status === 429) {
                                    // Rate limited by Discord - mark and skip (don't retry)
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.set(channelKey, { type: 'ratelimit' });
                                    rateLimitedChannels.push(channel.name);
                                    updateFailedChannelStatus(channel);
                                } else {
                                    // Other error (permissions, etc.)
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.set(channelKey, { type: 'permission' });
                                    failedChannelsList.push(channel.name);
                                    updateFailedChannelStatus(channel);
                                }

                                // Add delay between messages based on user setting
                                // Only delay if there are more messages to send
                                if (i < selectedChannels.length - 1 && customDelay > 0) {
                                    await delay(customDelay);
                                }
                            }

                            // Show collapsible results
                            await showSendResults(succeededChannels, rateLimitedChannels, failedChannelsList);
                        } catch (error) {
                            console.error('Send error:', error);
                            await showAlert(`Error sending message: ${error.message}`, 'Error');
                        } finally {
                            isSending = false;
                            sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                            sendBtn.innerHTML = 'Send';
                        }
                    }
                });
            }

            // Initialize on load
            initializeUI();
        });

        // ============================================
        // TEAM PANEL JavaScript
        // Separate functionality for the Team panel
        // ============================================
        document.addEventListener('DOMContentLoaded', function() {
            // Check if team panel elements exist
            const teamServerSidebar = document.getElementById('team-server-sidebar');
            if (!teamServerSidebar) return; // Exit if no team panel

            const teamChannelsList = document.getElementById('team-channels-list');
            const teamMessageInput = document.getElementById('team-message-input');
            const teamSendBtn = document.getElementById('team-send-btn');
            const teamCharCount = document.getElementById('team-char-count');
            const teamChannelSearch = document.getElementById('team-channel-search');
            const teamSearchTagsContainer = document.getElementById('team-search-tags');
            const MESSAGE_LIMIT = 2000;

            let teamGuilds = [];
            let teamServerChannels = {}; // Cache for channels by guild ID
            let teamSelectedChannels = []; // Array for multiple channel selection
            let teamSelectedGuild = null; // Currently selected guild
            let teamSearchTags = []; // Search filter tags
            let teamCurrentServerColor = 'rgba(21, 216, 188, 0.6)';
            let teamIsSending = false;
            let teamFailedChannels = new Map();
            let teamViewMode = 'servers';
            let teamChannelsOnlySearchText = '';
            let teamChannelsOnlySearchTags = [];
            let teamSelectedChannelsModeSearchText = '';
            const teamMaxChannelsPerServer = {{ plan_status.max_channels_per_server if plan_status and plan_status.max_channels_per_server is defined else 2 }};

            // Team panel view mode toggle elements
            const teamViewModeRadios = document.querySelectorAll('input[name="team-view-mode"]');
            const teamServersModeHeader = document.querySelector('.team-servers-mode-header');
            const teamChannelsOnlyHeader = document.querySelector('.team-channels-only-header');
            const teamSelectedChannelsModeHeader = document.querySelector('.team-selected-channels-mode-header');
            const teamServersModeSections = document.querySelectorAll('.team-servers-mode-section');
            const teamChannelsOnlySection = document.querySelector('.team-channels-only-section');
            const teamSelectedChannelsModeSection = document.querySelector('.team-selected-channels-mode-section');
            const teamChannelsOnlyList = document.getElementById('team-channels-only-list');
            const teamSelectedChannelsModeList = document.getElementById('team-selected-channels-mode-list');
            const teamChannelsOnlySearch = document.getElementById('team-channels-only-search');
            const teamSelectedChannelsModeSearch = document.getElementById('team-selected-channels-mode-search');
            const teamChannelsOnlySearchTagsContainer = document.getElementById('team-channels-only-search-tags');

            // Team view mode toggle handler
            teamViewModeRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    const mode = radio.value;
                    if (mode === teamViewMode) return;

                    teamViewMode = mode;

                    // Hide all headers and sections first
                    teamServersModeHeader.style.display = 'none';
                    teamChannelsOnlyHeader.style.display = 'none';
                    teamSelectedChannelsModeHeader.style.display = 'none';
                    teamServersModeSections.forEach(s => s.style.display = 'none');
                    teamChannelsOnlySection.style.display = 'none';
                    teamSelectedChannelsModeSection.style.display = 'none';

                    // Show the appropriate mode
                    if (mode === 'servers') {
                        teamServersModeHeader.style.display = '';
                        teamServersModeSections.forEach(s => s.style.display = '');
                    } else if (mode === 'channels') {
                        teamChannelsOnlyHeader.style.display = '';
                        teamChannelsOnlySection.style.display = 'flex';
                        teamRenderChannelsOnlyMode();
                    } else if (mode === 'selected') {
                        teamSelectedChannelsModeHeader.style.display = '';
                        teamSelectedChannelsModeSection.style.display = 'flex';
                        teamRenderSelectedChannelsMode();
                    }
                });
            });

            // Team selected channels mode search handler
            if (teamSelectedChannelsModeSearch) {
                teamSelectedChannelsModeSearch.addEventListener('input', (e) => {
                    teamSelectedChannelsModeSearchText = e.target.value.toLowerCase();
                    teamRenderSelectedChannelsMode();
                });
            }

            // Render channels in team selected channels mode
            function teamRenderSelectedChannelsMode() {
                if (!teamSelectedChannelsModeList) return;

                if (teamSelectedChannels.length === 0) {
                    teamSelectedChannelsModeList.innerHTML = '<div class="no-selection">No channels selected</div>';
                    return;
                }

                let filteredChannels = teamSelectedChannels;
                if (teamSelectedChannelsModeSearchText) {
                    filteredChannels = teamSelectedChannels.filter(ch =>
                        ch.name.toLowerCase().includes(teamSelectedChannelsModeSearchText) ||
                        ch.guildName.toLowerCase().includes(teamSelectedChannelsModeSearchText)
                    );
                }

                if (filteredChannels.length === 0) {
                    teamSelectedChannelsModeList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                teamSelectedChannelsModeList.innerHTML = filteredChannels.map(channel => {
                    const iconUrl = channel.guildIcon
                        ? `https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png`
                        : null;

                    const serverIconHtml = iconUrl
                        ? `<img class="server-icon-small" src="${iconUrl}" alt="">`
                        : `<div class="server-icon-placeholder-small">${channel.guildName[0].toUpperCase()}</div>`;

                    const channelKey = `${channel.guildId}-${channel.id}`;
                    const failedInfo = teamFailedChannels.get(channelKey);
                    const isFailed = !!failedInfo;
                    const failedClass = isFailed ? ' failed' : '';
                    const statusText = failedInfo?.type === 'ratelimit' ? 'Rate limited' : 'Missing permission';
                    const statusTagHtml = isFailed ? `<span class="channel-status-tag">${statusText}</span>` : '';

                    return `<div class="channel-item selected${failedClass}" data-channel-id="${channel.id}" data-channel-name="${channel.name}" data-guild-id="${channel.guildId}" data-guild-name="${channel.guildName}" data-guild-icon="${channel.guildIcon || ''}">${serverIconHtml}<span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right">${statusTagHtml}<img class="channel-tick" src="{{ url_for('static', filename='x.png') }}" alt="x"></div></div>`;
                }).join('');

                // Add click handlers to remove channels
                teamSelectedChannelsModeList.querySelectorAll('.channel-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const channelId = item.dataset.channelId;
                        const guildId = item.dataset.guildId;

                        teamSelectedChannels = teamSelectedChannels.filter(ch =>
                            !(ch.id === channelId && ch.guildId === guildId)
                        );

                        teamSaveSelectedChannels();
                        teamRenderSelectedChannelsMode();
                        teamUpdateServerCount(guildId);
                        teamUpdateSendButton();

                        if (teamSelectedGuild && teamSelectedGuild.id === guildId) {
                            teamRenderChannels();
                        }
                    });
                });
            }

            // Team channels-only search handler
            if (teamChannelsOnlySearch) {
                teamChannelsOnlySearch.addEventListener('input', (e) => {
                    teamChannelsOnlySearchText = e.target.value.toLowerCase();
                    teamRenderChannelsOnlyMode();
                });
                teamChannelsOnlySearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && teamChannelsOnlySearch.value.trim()) {
                        teamAddChannelsOnlySearchTag(teamChannelsOnlySearch.value);
                    }
                });
            }

            function teamAddChannelsOnlySearchTag(text) {
                if (teamChannelsOnlySearchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                if (!teamChannelsOnlySearchTags.includes(text.toLowerCase()) && text.trim()) {
                    teamChannelsOnlySearchTags.push(text.toLowerCase());
                    teamUpdateChannelsOnlySearchTagsDisplay();
                    teamChannelsOnlySearch.value = '';
                    teamChannelsOnlySearchText = '';
                    teamRenderChannelsOnlyMode();
                }
            }

            function teamRemoveChannelsOnlySearchTag(tag) {
                teamChannelsOnlySearchTags = teamChannelsOnlySearchTags.filter(t => t !== tag);
                teamUpdateChannelsOnlySearchTagsDisplay();
                teamRenderChannelsOnlyMode();
            }

            function teamUpdateChannelsOnlySearchTagsDisplay() {
                if (!teamChannelsOnlySearchTagsContainer) return;
                teamChannelsOnlySearchTagsContainer.innerHTML = '';
                teamChannelsOnlySearchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}"></span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        teamRemoveChannelsOnlySearchTag(tag);
                    });
                    teamChannelsOnlySearchTagsContainer.appendChild(tagEl);
                });
            }

            // Render channels in team channels-only mode
            function teamRenderChannelsOnlyMode() {
                if (!teamChannelsOnlyList) return;

                const hasLoadedChannels = Object.keys(teamServerChannels).length > 0;

                let allChannels = [];
                for (const guild of teamGuilds) {
                    const channels = teamServerChannels[guild.id] || [];
                    for (const channel of channels) {
                        allChannels.push({
                            ...channel,
                            guildId: guild.id,
                            guildName: guild.name,
                            guildIcon: guild.icon
                        });
                    }
                }

                if (teamChannelsOnlySearchTags.length > 0) {
                    allChannels = allChannels.filter(ch =>
                        teamChannelsOnlySearchTags.some(tag =>
                            ch.name.toLowerCase().includes(tag) ||
                            ch.guildName.toLowerCase().includes(tag)
                        )
                    );
                }

                if (teamChannelsOnlySearchText) {
                    allChannels = allChannels.filter(ch =>
                        ch.name.toLowerCase().includes(teamChannelsOnlySearchText) ||
                        ch.guildName.toLowerCase().includes(teamChannelsOnlySearchText)
                    );
                }

                if (allChannels.length === 0) {
                    if (!hasLoadedChannels) {
                        teamChannelsOnlyList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';
                    } else if (teamChannelsOnlySearchText || teamChannelsOnlySearchTags.length > 0) {
                        teamChannelsOnlyList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    } else {
                        teamChannelsOnlyList.innerHTML = '<div class="no-selection">No channels found</div>';
                    }
                    return;
                }

                teamChannelsOnlyList.innerHTML = allChannels.map(channel => {
                    const isSelected = teamSelectedChannels.some(ch => ch.id === channel.id);
                    const iconUrl = channel.guildIcon
                        ? `https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png`
                        : null;

                    const serverIconHtml = iconUrl
                        ? `<img class="server-icon-small" src="${iconUrl}" alt="">`
                        : `<div class="server-icon-placeholder-small">${channel.guildName[0].toUpperCase()}</div>`;

                    return `<div class="channel-item ${isSelected ? 'selected' : ''}" data-channel-id="${channel.id}" data-channel-name="${channel.name}" data-guild-id="${channel.guildId}" data-guild-name="${channel.guildName}" data-guild-icon="${channel.guildIcon || ''}">${serverIconHtml}<span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right"><img class="channel-tick" src="{{ url_for('static', filename='tick.png') }}" alt=""></div></div>`;
                }).join('');

                teamChannelsOnlyList.querySelectorAll('.channel-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const channelId = item.dataset.channelId;
                        const channelName = item.dataset.channelName;
                        const guildId = item.dataset.guildId;
                        const guildName = item.dataset.guildName;
                        const guildIcon = item.dataset.guildIcon;

                        teamToggleChannelSelection({
                            id: channelId,
                            name: channelName,
                            guildId: guildId,
                            guildName: guildName,
                            guildIcon: guildIcon
                        });

                        const isNowSelected = teamSelectedChannels.some(ch => ch.id === channelId);
                        if (isNowSelected) {
                            item.classList.add('selected');
                        } else {
                            item.classList.remove('selected');
                        }
                    });
                });
            }

            // Warn user before leaving if team messages are being sent
            window.addEventListener('beforeunload', (e) => {
                if (teamIsSending) {
                    e.preventDefault();
                    e.returnValue = '';
                    return '';
                }
            });

            // Load team saved data from localStorage
            function teamLoadSelectedChannels() {
                const saved = localStorage.getItem('teamSelectedChannels');
                if (saved) {
                    try {
                        teamSelectedChannels = JSON.parse(saved);
                    } catch (e) {
                        console.error('Error loading saved team channels:', e);
                        teamSelectedChannels = [];
                    }
                }
            }

            // Save team selected channels to localStorage
            function teamSaveSelectedChannels() {
                localStorage.setItem('teamSelectedChannels', JSON.stringify(teamSelectedChannels));
            }

            // Add team search tag
            function teamAddSearchTag(text) {
                if (teamSearchTags.length >= 6) {
                    showTagLimitModal();
                    return;
                }
                if (!teamSearchTags.includes(text.toLowerCase()) && text.trim()) {
                    teamSearchTags.push(text.toLowerCase());
                    teamUpdateSearchTagsDisplay();
                    teamChannelSearch.value = '';
                    if (teamSelectedGuild) {
                        teamRenderChannels();
                    }
                }
            }

            function teamRemoveSearchTag(tag) {
                teamSearchTags = teamSearchTags.filter(t => t !== tag);
                teamUpdateSearchTagsDisplay();
                if (teamSelectedGuild) {
                    teamRenderChannels();
                }
            }

            function teamUpdateSearchTagsDisplay() {
                teamSearchTagsContainer.innerHTML = '';
                teamSearchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}"></span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        teamRemoveSearchTag(tag);
                    });
                    teamSearchTagsContainer.appendChild(tagEl);
                });
            }

            // Handle team channel search input
            if (teamChannelSearch) {
                teamChannelSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && teamChannelSearch.value.trim()) {
                        teamAddSearchTag(teamChannelSearch.value);
                    }
                });
            }

            // Render team server sidebar icons
            function teamRenderServers() {
                if (!teamServerSidebar) return;

                teamServerSidebar.innerHTML = '';

                if (!teamGuilds || teamGuilds.length === 0) {
                    return;
                }

                teamGuilds.forEach(guild => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'server-icon-wrapper';
                    wrapper.dataset.guildId = guild.id;
                    wrapper.title = guild.name;

                    const iconHtml = guild.icon
                        ? `<img src="https://cdn.discordapp.com/icons/${guild.id}/${guild.icon}.png?size=96" alt="${guild.name}">`
                        : `<span class="server-icon-placeholder">${guild.name.charAt(0).toUpperCase()}</span>`;

                    wrapper.innerHTML = `
                        <div class="server-icon-pill"></div>
                        <div class="server-icon-holder">
                            ${iconHtml}
                        </div>
                    `;

                    wrapper.addEventListener('click', () => teamSelectServer(guild));
                    teamServerSidebar.appendChild(wrapper);

                    if (teamSelectedGuild && teamSelectedGuild.id === guild.id) {
                        wrapper.classList.add('active');
                    }
                });
            }

            // Preload all channels for team guilds
            async function teamPreloadAllChannels() {
                const promises = teamGuilds.map(async (guild) => {
                    if (!teamServerChannels[guild.id]) {
                        try {
                            const response = await fetch(`/api/guild/${guild.id}/channels`);
                            const data = await response.json();

                            if (data.token_invalid) {
                                return;
                            }

                            if (data.channels) {
                                teamServerChannels[guild.id] = data.channels.filter(ch => ch.type === 0).sort((a, b) => a.position - b.position);
                            } else {
                                teamServerChannels[guild.id] = [];
                            }

                            if (teamViewMode === 'channels') {
                                teamRenderChannelsOnlyMode();
                            }
                        } catch (error) {
                            console.error(`Error preloading team channels for ${guild.name}:`, error);
                            teamServerChannels[guild.id] = [];
                        }
                    }
                });

                await Promise.all(promises);
            }

            // Initialize team UI
            async function teamInitializeUI() {
                teamLoadSelectedChannels();

                teamGuilds = {{ guilds|tojson }};

                // Remove selected channels from servers that no longer exist
                const guildIds = new Set(teamGuilds.map(g => g.id));
                const originalLength = teamSelectedChannels.length;
                teamSelectedChannels = teamSelectedChannels.filter(ch => guildIds.has(ch.guildId));

                if (teamSelectedChannels.length !== originalLength) {
                    teamSaveSelectedChannels();
                }

                teamRenderServers();
                teamUpdateSelectedDisplay();
                teamUpdateSendButton();

                teamPreloadAllChannels();
            }

            // Extract dominant color from image (team version)
            function teamGetDominantColor(imageUrl, callback) {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    let r = 0, g = 0, b = 0, count = 0;

                    for (let i = 0; i < data.length; i += 40) {
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        count++;
                    }

                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    callback(`rgb(${r}, ${g}, ${b})`);
                };
                img.onerror = function() {
                    callback('rgba(21, 216, 188, 0.6)');
                };
                img.src = imageUrl;
            }

            // Select a server and load its channels (team version)
            async function teamSelectServer(guild) {
                teamSelectedGuild = guild;
                const guildId = guild.id;

                document.querySelectorAll('#team-server-sidebar .server-icon-wrapper').forEach(item => {
                    item.classList.remove('active');
                });

                const activeItem = teamServerSidebar.querySelector(`[data-guild-id="${guildId}"]`);
                if (activeItem) {
                    activeItem.classList.add('active');
                }

                if (guild.icon) {
                    const iconUrl = `https://cdn.discordapp.com/icons/${guildId}/${guild.icon}.png`;
                    teamGetDominantColor(iconUrl, (color) => {
                        if (teamSelectedGuild && teamSelectedGuild.id === guildId) {
                            teamCurrentServerColor = color;
                        }
                    });
                } else {
                    teamCurrentServerColor = 'rgba(21, 216, 188, 0.6)';
                }

                if (!teamServerChannels[guildId]) {
                    teamChannelsList.innerHTML = '<div class="loading-container"><div class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div></div>';

                    try {
                        const response = await fetch(`/api/guild/${guildId}/channels`);

                        if (!teamSelectedGuild || teamSelectedGuild.id !== guildId) {
                            return;
                        }

                        const data = await response.json();

                        if (data.token_invalid) {
                            window.location.href = '/settings';
                            return;
                        }

                        if (!response.ok) {
                            return;
                        }

                        if (data.channels) {
                            teamServerChannels[guildId] = data.channels.filter(ch => ch.type === 0).sort((a, b) => a.position - b.position);
                        } else {
                            teamServerChannels[guildId] = [];
                        }
                    } catch (error) {
                        console.error(`Error fetching team channels:`, error);
                        teamServerChannels[guildId] = [];
                    }
                }

                if (teamSelectedGuild && teamSelectedGuild.id === guildId) {
                    teamRenderChannels();
                }

                if (teamViewMode === 'channels') {
                    teamRenderChannelsOnlyMode();
                }
            }

            // Render channels for selected team server
            function teamRenderChannels() {
                if (!teamSelectedGuild) {
                    teamChannelsList.innerHTML = '<div class="no-selection">Select a server to view channels</div>';
                    return;
                }

                teamChannelsList.innerHTML = '';
                const channels = teamServerChannels[teamSelectedGuild.id] || [];

                if (channels.length === 0) {
                    teamChannelsList.innerHTML = '<div class="no-selection">No channels found</div>';
                    return;
                }

                let filteredChannels = channels;
                if (teamSearchTags.length > 0) {
                    filteredChannels = channels.filter(channel =>
                        teamSearchTags.some(tag => channel.name.toLowerCase().includes(tag))
                    );
                }

                if (filteredChannels.length === 0) {
                    teamChannelsList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                filteredChannels.forEach(channel => {
                    const isSelected = teamSelectedChannels.some(ch =>
                        ch.id === channel.id && ch.guildId === teamSelectedGuild.id
                    );

                    const channelItem = document.createElement('div');
                    channelItem.className = `channel-item ${isSelected ? 'selected' : ''}`;
                    channelItem.dataset.channelId = channel.id;

                    channelItem.innerHTML = `<span class="channel-hash">#</span><span class="channel-name">${channel.name}</span><div class="channel-right"><img class="channel-tick" src="{{ url_for('static', filename='tick.png') }}" alt=""></div>`;

                    channelItem.addEventListener('click', () => {
                        const currentlySelected = teamSelectedChannels.some(ch =>
                            ch.id === channel.id && ch.guildId === teamSelectedGuild.id
                        );
                        teamToggleChannel(channel, !currentlySelected);
                    });

                    teamChannelsList.appendChild(channelItem);
                });
            }

            // Toggle team channel selection for channels-only mode
            function teamToggleChannelSelection(channel) {
                const isCurrentlySelected = teamSelectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === channel.guildId
                );

                if (!isCurrentlySelected) {
                    if (teamMaxChannelsPerServer !== -1) {
                        const currentServerChannelCount = teamSelectedChannels.filter(ch =>
                            ch.guildId === channel.guildId
                        ).length;

                        if (currentServerChannelCount >= teamMaxChannelsPerServer) {
                            showChannelLimitModal(teamMaxChannelsPerServer);
                            return;
                        }
                    }

                    teamSelectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: channel.guildId,
                        guildName: channel.guildName,
                        guildIcon: channel.guildIcon || null
                    });
                    const channelKey = `${channel.guildId}-${channel.id}`;
                    teamFailedChannels.delete(channelKey);
                } else {
                    teamSelectedChannels = teamSelectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === channel.guildId)
                    );
                }

                teamSaveSelectedChannels();
                teamUpdateServerCount(channel.guildId);
                teamUpdateSelectedDisplay();
                teamUpdateSendButton();
            }

            // Toggle team channel selection
            function teamToggleChannel(channel, isChecked) {
                if (!teamSelectedGuild) return;

                const isCurrentlySelected = teamSelectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === teamSelectedGuild.id
                );

                if (isChecked && !isCurrentlySelected) {
                    if (teamMaxChannelsPerServer !== -1) {
                        const currentServerChannelCount = teamSelectedChannels.filter(ch =>
                            ch.guildId === teamSelectedGuild.id
                        ).length;

                        if (currentServerChannelCount >= teamMaxChannelsPerServer) {
                            showChannelLimitModal(teamMaxChannelsPerServer);
                            return;
                        }
                    }

                    teamSelectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: teamSelectedGuild.id,
                        guildName: teamSelectedGuild.name,
                        guildIcon: teamSelectedGuild.icon || null
                    });
                    const channelKey = `${teamSelectedGuild.id}-${channel.id}`;
                    teamFailedChannels.delete(channelKey);
                } else if (!isChecked && isCurrentlySelected) {
                    teamSelectedChannels = teamSelectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === teamSelectedGuild.id)
                    );
                }

                teamSaveSelectedChannels();
                teamRenderChannels();
                teamUpdateServerCount(teamSelectedGuild.id);
                teamUpdateSelectedDisplay();
                teamUpdateSendButton();
            }

            // Update count badge on team server
            function teamUpdateServerCount(guildId) {
                const count = teamSelectedChannels.filter(ch => ch.guildId === guildId).length;
                const serverItem = teamServerSidebar.querySelector(`[data-guild-id="${guildId}"]`);
                if (serverItem) {
                    const countEl = serverItem.querySelector('.server-count');
                    if (countEl) {
                        if (count > 0) {
                            countEl.textContent = `${count} selected`;
                            countEl.style.display = 'block';
                            serverItem.classList.add('has-selection');
                        } else {
                            countEl.style.display = 'none';
                            serverItem.classList.remove('has-selection');
                        }
                    }
                }
            }

            // Update team failed channel status
            function teamUpdateFailedChannelStatus(channel) {
                if (teamViewMode === 'selected') {
                    teamRenderSelectedChannelsMode();
                }
            }

            // Update team selected channels display
            function teamUpdateSelectedDisplay() {
                if (teamViewMode === 'selected') {
                    teamRenderSelectedChannelsMode();
                }
                if (teamViewMode === 'channels') {
                    teamRenderChannelsOnlyMode();
                }
            }

            // Update team send button state
            function teamUpdateSendButton() {
                if (teamSendBtn && teamMessageInput) {
                    // Team message is read-only - check if there's a team message set
                    const teamMessage = teamMessageInput.value.trim();
                    teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessage;
                }
            }

            // Team send button handler
            if (teamSendBtn) {
                teamSendBtn.addEventListener('click', async function() {
                    const teamMessage = teamMessageInput ? teamMessageInput.value.trim() : '';
                    if (teamSelectedChannels.length > 0 && teamMessage) {
                        // Check for filtered content before proceeding
                        const filteredWords = {{ BLACKLISTED_WORDS|tojson }};
                        const phraseExceptions = {{ PHRASE_EXCEPTIONS|tojson }};

                        function isWordInException(word, messageLower) {
                            const wordLower = word.toLowerCase();
                            const exceptions = phraseExceptions[wordLower] || [];

                            if (exceptions.length === 0) return false;

                            let startIndex = 0;
                            while (true) {
                                const pos = messageLower.indexOf(wordLower, startIndex);
                                if (pos === -1) break;

                                const wordEnd = pos + wordLower.length;
                                let isException = false;

                                for (const exception of exceptions) {
                                    const excLower = exception.toLowerCase();
                                    const excPos = messageLower.indexOf(excLower);
                                    if (excPos !== -1 && excPos <= pos && (excPos + excLower.length) >= wordEnd) {
                                        isException = true;
                                        break;
                                    }
                                }

                                if (!isException) return false;

                                startIndex = pos + 1;
                            }

                            return true;
                        }

                        const messageLower = teamMessage.toLowerCase();
                        let foundWords = [];

                        for (const word of filteredWords) {
                            if (messageLower.includes(word.toLowerCase())) {
                                if (!isWordInException(word, messageLower)) {
                                    foundWords.push(word);
                                }
                            }
                        }

                        if (foundWords.length > 0) {
                            try {
                                await fetch('/api/flag-self', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({ words: foundWords })
                                });
                            } catch (e) {
                                console.error('Failed to report flagged content:', e);
                            }

                            await showAlert(`Banned words used\n\nThe team message contains prohibited content:\n ${foundWords.join('\n ')}\n\nPlease contact the team owner to update the message.`, 'Warning');
                            return;
                        }

                        // Show confirmation popup
                        const channelCount = teamSelectedChannels.length;
                        const confirmed = await showConfirm(`Send team message to ${channelCount} channel${channelCount !== 1 ? 's' : ''}?`, 'Send Team Message', { confirmText: 'Send' });
                        if (!confirmed) return;

                        teamFailedChannels.clear();

                        teamIsSending = true;
                        teamSendBtn.disabled = true;
                        teamSendBtn.innerHTML = '<span id="team-send-progress">Sending...</span>';

                        let succeededChannels = [];
                        let rateLimitedChannels = [];
                        let failedChannelsList = [];

                        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
                        const customDelay = parseInt('{{ user_data.message_delay }}') || 1000;
                        const progressEl = document.getElementById('team-send-progress');

                        try {
                            for (let i = 0; i < teamSelectedChannels.length; i++) {
                                const channel = teamSelectedChannels[i];

                                if (progressEl) {
                                    progressEl.textContent = `Sending ${i + 1}/${teamSelectedChannels.length}...`;
                                }

                                const response = await fetch('/api/send-message-single', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRF-Token': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({
                                        channel: channel,
                                        message: teamMessage
                                    })
                                });

                                const result = await response.json();

                                if (response.ok && result.success) {
                                    succeededChannels.push(channel.name);
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    teamFailedChannels.delete(channelKey);
                                    teamUpdateFailedChannelStatus(channel);
                                } else if (result.token_invalid) {
                                    window.location.href = '/settings';
                                    return;
                                } else if (result.limit_reached) {
                                    await showAlert('Usage limit reached!\n\nYou have reached your message limit for this period.\nRedirecting to settings page...', 'Limit reached');
                                    window.location.href = '/settings';
                                    return;
                                } else if (response.status === 429) {
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    teamFailedChannels.set(channelKey, { type: 'ratelimit' });
                                    rateLimitedChannels.push(channel.name);
                                    teamUpdateFailedChannelStatus(channel);
                                } else {
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    teamFailedChannels.set(channelKey, { type: 'permission' });
                                    failedChannelsList.push(channel.name);
                                    teamUpdateFailedChannelStatus(channel);
                                }

                                if (i < teamSelectedChannels.length - 1 && customDelay > 0) {
                                    await delay(customDelay);
                                }
                            }

                            await showSendResults(succeededChannels, rateLimitedChannels, failedChannelsList);
                        } catch (error) {
                            console.error('Team send error:', error);
                            await showAlert(`Error sending team message: ${error.message}`, 'Error');
                        } finally {
                            teamIsSending = false;
                            teamSendBtn.disabled = teamSelectedChannels.length === 0 || !teamMessage;
                            teamSendBtn.innerHTML = 'Send';
                        }
                    }
                });
            }

            // Initialize team panel on load
            teamInitializeUI();
        });
    </script>

    <!-- Team Management Script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Message box elements
            const mgmtMessageInput = document.getElementById('mgmt-team-message-input');
            const mgmtCharCount = document.getElementById('mgmt-char-count');
            const mgmtSaveBtn = document.getElementById('mgmt-save-btn');
            const MESSAGE_LIMIT = 2000;

            // Left half elements
            const mgmtAddSearch = document.getElementById('mgmt-add-search');
            const mgmtAddModeHeader = document.querySelector('.mgmt-add-mode-header');
            const mgmtAddModeSection = document.querySelector('.mgmt-add-mode-section');
            const mgmtMembersModeSection = document.querySelector('.mgmt-members-mode-section');
            const mgmtAddList = document.getElementById('mgmt-add-list');
            const mgmtMembersList = document.getElementById('mgmt-members-list');
            const mgmtAddEmpty = document.getElementById('mgmt-add-empty');
            const mgmtMembersEmpty = document.getElementById('mgmt-members-empty');

            // Track saved message to detect changes
            let savedMessage = mgmtMessageInput ? mgmtMessageInput.value : '';

            // =====================
            // MESSAGE BOX FUNCTIONS
            // =====================

            function updateMgmtSaveButton() {
                if (mgmtSaveBtn && mgmtMessageInput) {
                    const isOverLimit = mgmtMessageInput.value.length > MESSAGE_LIMIT;
                    const hasChanged = mgmtMessageInput.value !== savedMessage;
                    mgmtSaveBtn.disabled = isOverLimit || !hasChanged;
                }
            }

            function updateMgmtCharCount() {
                if (mgmtCharCount && mgmtMessageInput) {
                    const remaining = MESSAGE_LIMIT - mgmtMessageInput.value.length;
                    mgmtCharCount.textContent = remaining;

                    if (remaining < 0) {
                        mgmtCharCount.style.color = '#991a35';
                    } else {
                        mgmtCharCount.style.color = '#81828A';
                    }
                }
            }

            if (mgmtMessageInput) {
                mgmtMessageInput.addEventListener('input', function() {
                    updateMgmtCharCount();
                    updateMgmtSaveButton();
                });
            }

            updateMgmtSaveButton();

            if (mgmtSaveBtn) {
                mgmtSaveBtn.addEventListener('click', async function() {
                    const message = mgmtMessageInput ? mgmtMessageInput.value : '';

                    mgmtSaveBtn.disabled = true;
                    // Use visibility:hidden on text to maintain button size, position dots absolutely centered
                    mgmtSaveBtn.innerHTML = '<span style="visibility: hidden;">Save</span><div class="loading-dots" style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>';
                    mgmtSaveBtn.style.position = 'relative';

                    try {
                        const response = await fetch('/api/team/set-team-message', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ message: message })
                        });

                        const result = await response.json();

                        if (response.ok && result.success) {
                            const teamPanelTextarea = document.getElementById('team-message-input');
                            if (teamPanelTextarea) {
                                teamPanelTextarea.value = message;
                            }
                            const teamCharCount = document.getElementById('team-char-count');
                            if (teamCharCount) {
                                teamCharCount.textContent = MESSAGE_LIMIT - message.length;
                            }

                            savedMessage = message;
                            mgmtSaveBtn.innerHTML = 'Save';
                            updateMgmtSaveButton();
                        } else {
                            await showAlert(result.error || 'Failed to save team message', 'Error');
                            mgmtSaveBtn.innerHTML = 'Save';
                            updateMgmtSaveButton();
                        }
                    } catch (error) {
                        console.error('Save team message error:', error);
                        await showAlert('Failed to save team message: ' + error.message, 'Error');
                        mgmtSaveBtn.innerHTML = 'Save';
                        updateMgmtSaveButton();
                    }
                });
            }

            // =====================
            // RADIO TOGGLE (Add / Team members)
            // =====================

            const mgmtMembersModeHeader = document.querySelector('.mgmt-members-mode-header');

            const mgmtViewModeRadios = document.querySelectorAll('input[name="mgmt-view-mode"]');
            mgmtViewModeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    const mode = this.value;

                    if (mode === 'add') {
                        // Show Add mode
                        if (mgmtAddModeHeader) mgmtAddModeHeader.style.display = '';
                        if (mgmtMembersModeHeader) mgmtMembersModeHeader.style.display = 'none';
                        if (mgmtAddModeSection) mgmtAddModeSection.style.display = 'flex';
                        if (mgmtMembersModeSection) mgmtMembersModeSection.style.display = 'none';
                        // Show/hide empty states
                        if (mgmtMembersEmpty) mgmtMembersEmpty.style.display = 'none';
                        updateEmptyStates();
                    } else {
                        // Show Team members mode
                        if (mgmtAddModeHeader) mgmtAddModeHeader.style.display = 'none';
                        if (mgmtMembersModeHeader) mgmtMembersModeHeader.style.display = '';
                        if (mgmtAddModeSection) mgmtAddModeSection.style.display = 'none';
                        if (mgmtMembersModeSection) mgmtMembersModeSection.style.display = 'flex';
                        // Show/hide empty states
                        if (mgmtAddEmpty) mgmtAddEmpty.style.display = 'none';
                        updateEmptyStates();
                    }
                });
            });

            // =====================
            // HELPER: Update empty state messages
            // =====================

            function updateEmptyStates() {
                // Get current mode
                const currentMode = document.querySelector('input[name="mgmt-view-mode"]:checked');
                const isAddMode = currentMode ? currentMode.value === 'add' : true;

                // Check Add list
                if (mgmtAddList && mgmtAddEmpty) {
                    const items = mgmtAddList.querySelectorAll('.mgmt-member-item');
                    if (items.length === 0 && isAddMode) {
                        mgmtAddEmpty.style.display = '';
                    } else {
                        mgmtAddEmpty.style.display = 'none';
                    }
                }
                // Check Members list
                if (mgmtMembersList && mgmtMembersEmpty) {
                    const items = mgmtMembersList.querySelectorAll('.mgmt-member-item');
                    if (items.length === 0 && !isAddMode) {
                        mgmtMembersEmpty.style.display = '';
                    } else {
                        mgmtMembersEmpty.style.display = 'none';
                    }
                }
            }

            // =====================
            // ADD MEMBER (search bar enter to add)
            // =====================

            if (mgmtAddSearch) {
                // Only allow numeric input
                mgmtAddSearch.addEventListener('input', function() {
                    this.value = this.value.replace(/[^0-9]/g, '');
                });

                mgmtAddSearch.addEventListener('keypress', async function(e) {
                    if (e.key === 'Enter') {
                        const adzsendId = this.value.trim();

                        if (!adzsendId) {
                            await showAlert('Please enter an Adzsend ID', 'Error');
                            return;
                        }

                        if (!/^\d{18}$/.test(adzsendId)) {
                            await showAlert('Adzsend ID must be exactly 18 digits', 'Error');
                            return;
                        }

                        try {
                            const response = await fetch('/api/team/add-member', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRF-Token': '{{ csrf_token }}'
                                },
                                body: JSON.stringify({ adzsend_id: adzsendId })
                            });

                            const result = await response.json();

                            if (response.ok && result.success) {
                                this.value = '';

                                // Hide empty state message
                                if (mgmtAddEmpty) mgmtAddEmpty.style.display = 'none';

                                // Add new member item to the list
                                const newItem = document.createElement('div');
                                newItem.className = 'channel-item mgmt-member-item';
                                newItem.dataset.adzsendId = adzsendId;
                                newItem.dataset.status = 'pending';
                                newItem.style.cursor = 'default';
                                newItem.innerHTML = `
                                    <div class="mgmt-member-avatar" style="width: 32px; height: 32px; border-radius: 50%; background: #ff3333; flex-shrink: 0;"></div>
                                    <span class="channel-name" style="font-family: monospace;">${adzsendId}</span>
                                    <div class="channel-right">
                                        <span class="channel-status-tag">Pending</span>
                                        <img class="mgmt-member-remove" src="{{ url_for('static', filename='x.png') }}" alt="x" style="width: 16px; height: 16px; cursor: pointer; opacity: 0.7;" data-action="cancel-invite">
                                    </div>
                                `;
                                mgmtAddList.appendChild(newItem);
                            } else {
                                await showAlert(result.error || 'Failed to add member', 'Error');
                            }
                        } catch (error) {
                            console.error('Add member error:', error);
                            await showAlert('Failed to add member: ' + error.message, 'Error');
                        }
                    }
                });
            }

            // =====================
            // REMOVE HANDLERS (X button clicks)
            // =====================

            // Add list - cancel pending invite (no confirmation)
            if (mgmtAddList) {
                mgmtAddList.addEventListener('click', async function(e) {
                    const removeBtn = e.target.closest('.mgmt-member-remove');
                    if (!removeBtn) return;

                    const memberItem = removeBtn.closest('.mgmt-member-item');
                    if (!memberItem) return;

                    const adzsendId = memberItem.dataset.adzsendId;

                    try {
                        const response = await fetch('/api/team/remove-member', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ adzsend_id: adzsendId })
                        });

                        const result = await response.json();

                        if (response.ok && result.success) {
                            // Remove item from DOM instantly
                            memberItem.remove();
                            updateEmptyStates();
                        } else {
                            await showAlert(result.error || 'Failed to cancel invitation', 'Error');
                        }
                    } catch (error) {
                        console.error('Cancel invitation error:', error);
                        await showAlert('Failed to cancel invitation: ' + error.message, 'Error');
                    }
                });
            }

            // Members list - remove team member (with confirmation)
            if (mgmtMembersList) {
                mgmtMembersList.addEventListener('click', async function(e) {
                    const removeBtn = e.target.closest('.mgmt-member-remove');
                    if (!removeBtn) return;

                    const memberItem = removeBtn.closest('.mgmt-member-item');
                    if (!memberItem) return;

                    const adzsendId = memberItem.dataset.adzsendId;

                    const confirmed = await showConfirm('Remove this team member?', 'Remove Member', { confirmText: 'Remove' });
                    if (!confirmed) return;

                    try {
                        const response = await fetch('/api/team/remove-member', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ adzsend_id: adzsendId })
                        });

                        const result = await response.json();

                        if (response.ok && result.success) {
                            // Remove item from DOM instantly
                            memberItem.remove();
                            updateEmptyStates();
                        } else {
                            await showAlert(result.error || 'Failed to remove member', 'Error');
                        }
                    } catch (error) {
                        console.error('Remove member error:', error);
                        await showAlert('Failed to remove member: ' + error.message, 'Error');
                    }
                });
            }
        });
    </script>

    <!-- Analytics Dialog Script -->
    <script>
        // Analytics Dialog Variables
        let currentMemberId = null;
        let currentMemberName = null;
        let memberJoinDate = null;
        let serverDate = null;
        let chartData = [];

        function openAnalyticsDialog(memberId, memberName) {
            currentMemberId = memberId;
            currentMemberName = memberName;

            document.getElementById('analytics-dialog-title').textContent = `Analytics: ${memberName}`;
            document.getElementById('analytics-dialog-overlay').classList.add('show');

            // Reset to information tab
            switchAnalyticsTab('information');

            // Set default date range (last 30 days)
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 30);

            document.getElementById('analytics-start-date').value = startDate.toISOString().split('T')[0];
            document.getElementById('analytics-end-date').value = endDate.toISOString().split('T')[0];

            // Load information data
            loadAnalyticsInfo();
        }

        function closeAnalyticsDialog() {
            document.getElementById('analytics-dialog-overlay').classList.remove('show');
            currentMemberId = null;
            currentMemberName = null;
        }

        // Close on overlay click
        document.getElementById('analytics-dialog-overlay').addEventListener('click', function(e) {
            if (e.target === this) {
                closeAnalyticsDialog();
            }
        });

        function switchAnalyticsTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.analytics-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            // Update panels
            document.querySelectorAll('.analytics-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === `panel-${tabName}`);
            });

            // Load data for the tab
            if (tabName === 'information') {
                loadAnalyticsInfo();
            } else if (tabName === 'dates') {
                loadDailyStats();
            }
        }

        async function loadAnalyticsInfo() {
            const container = document.getElementById('analytics-info-content');
            container.innerHTML = '<div class="no-data-message">Loading...</div>';

            try {
                const response = await fetch(`/api/team/member/${currentMemberId}/analytics`);
                const data = await response.json();

                if (data.success) {
                    const analytics = data.analytics;
                    // Format date as mm/dd/yy
                    const joinedDate = analytics.joined_at ? (() => {
                        const d = new Date(analytics.joined_at);
                        const month = String(d.getMonth() + 1).padStart(2, '0');
                        const day = String(d.getDate()).padStart(2, '0');
                        const year = String(d.getFullYear()).slice(-2);
                        return `${month}/${day}/${year}`;
                    })() : 'Unknown';

                    // Store dates for calendar restrictions
                    memberJoinDate = analytics.joined_at ? analytics.joined_at.split('T')[0] : null;
                    serverDate = analytics.server_date || new Date().toISOString().split('T')[0];

                    // Apply date restrictions to inputs
                    const startInput = document.getElementById('analytics-start-date');
                    const endInput = document.getElementById('analytics-end-date');
                    if (memberJoinDate) {
                        startInput.min = memberJoinDate;
                        endInput.min = memberJoinDate;
                    }
                    startInput.max = serverDate;
                    endInput.max = serverDate;

                    // Adjust default date range if join date is more recent than 30 days ago
                    if (memberJoinDate && new Date(memberJoinDate) > new Date(startInput.value)) {
                        startInput.value = memberJoinDate;
                    }

                    container.innerHTML = `
                        <div class="analytics-stat-row">
                            <span class="analytics-stat-label">All-time ads sent</span>
                            <span class="analytics-stat-value">${analytics.all_time.toLocaleString()}</span>
                        </div>
                        <div class="analytics-stat-row">
                            <span class="analytics-stat-label">Current cycle ads</span>
                            <span class="analytics-stat-value">${analytics.current_cycle.toLocaleString()}</span>
                        </div>
                        <div class="analytics-stat-row">
                            <span class="analytics-stat-label">Joined team (mm/dd/yy)</span>
                            <span class="analytics-stat-value">${joinedDate}</span>
                        </div>
                        <div class="analytics-stat-row" style="flex-direction: column; align-items: stretch;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                <span class="analytics-stat-label">Team contribution</span>
                                <span class="analytics-stat-value">${analytics.percentage}%</span>
                            </div>
                            <div class="analytics-progress-bar">
                                <div class="analytics-progress-fill" style="width: ${Math.min(analytics.percentage, 100)}%"></div>
                            </div>
                        </div>
                    `;
                } else {
                    container.innerHTML = `<div class="no-data-message">${data.error || 'Failed to load analytics'}</div>`;
                }
            } catch (error) {
                console.error('Error loading analytics:', error);
                container.innerHTML = '<div class="no-data-message">Error loading analytics</div>';
            }
        }

        async function loadDailyStats() {
            const startDate = document.getElementById('analytics-start-date').value;
            const endDate = document.getElementById('analytics-end-date').value;

            try {
                const response = await fetch(`/api/team/member/${currentMemberId}/daily-stats?start_date=${startDate}&end_date=${endDate}`);
                const data = await response.json();

                if (data.success) {
                    chartData = data.data.stats || [];

                    // Update summary
                    document.getElementById('summary-total').textContent = data.data.total.toLocaleString();
                    document.getElementById('summary-avg').textContent = data.data.average.toFixed(1);
                    document.getElementById('summary-peak').textContent = data.data.peak.toLocaleString();

                    // Draw chart
                    drawChart();
                } else {
                    console.error('Failed to load daily stats:', data.error);
                }
            } catch (error) {
                console.error('Error loading daily stats:', error);
            }
        }

        function applyDateRange() {
            loadDailyStats();
        }

        function drawChart() {
            const canvas = document.getElementById('analytics-chart');
            const ctx = canvas.getContext('2d');
            const wrapper = canvas.parentElement;

            // Set canvas size
            canvas.width = wrapper.offsetWidth;
            canvas.height = wrapper.offsetHeight;

            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 20, right: 20, bottom: 30, left: 40 };

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (chartData.length === 0) {
                ctx.fillStyle = '#81828A';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data for selected period', width / 2, height / 2);
                return;
            }

            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Find max value for scaling
            const maxCount = Math.max(...chartData.map(d => d.count), 1);

            // Calculate points
            const points = chartData.map((d, i) => ({
                x: padding.left + (i / (chartData.length - 1 || 1)) * chartWidth,
                y: padding.top + chartHeight - (d.count / maxCount) * chartHeight,
                date: d.date,
                count: d.count
            }));

            // Draw gradient fill
            if (points.length > 1) {
                const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
                gradient.addColorStop(0, 'rgba(21, 216, 188, 0.3)');
                gradient.addColorStop(1, 'rgba(21, 216, 188, 0)');

                ctx.beginPath();
                ctx.moveTo(points[0].x, height - padding.bottom);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.lineTo(points[points.length - 1].x, height - padding.bottom);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // Draw line
            ctx.beginPath();
            ctx.strokeStyle = '#15d8bc';
            ctx.lineWidth = 2;
            points.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            // Draw points
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#15d8bc';
                ctx.fill();
                ctx.strokeStyle = '#121215';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw Y-axis labels
            ctx.fillStyle = '#81828A';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(maxCount.toString(), padding.left - 5, padding.top + 5);
            ctx.fillText('0', padding.left - 5, height - padding.bottom + 5);

            // Draw X-axis labels (first and last dates)
            if (chartData.length > 0) {
                ctx.textAlign = 'left';
                ctx.fillText(formatDateShort(chartData[0].date), padding.left, height - 5);
                ctx.textAlign = 'right';
                ctx.fillText(formatDateShort(chartData[chartData.length - 1].date), width - padding.right, height - 5);
            }

            // Store points for tooltip
            canvas.chartPoints = points;
        }

        function formatDateShort(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        // Chart tooltip
        document.addEventListener('DOMContentLoaded', function() {
            const chartCanvas = document.getElementById('analytics-chart');
            const chartTooltip = document.getElementById('chart-tooltip');

            if (chartCanvas && chartTooltip) {
                chartCanvas.addEventListener('mousemove', function(e) {
                    if (!this.chartPoints || this.chartPoints.length === 0) return;

                    const rect = this.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Find closest point
                    let closest = null;
                    let minDist = Infinity;

                    this.chartPoints.forEach(p => {
                        const dist = Math.sqrt(Math.pow(p.x - x, 2) + Math.pow(p.y - y, 2));
                        if (dist < minDist && dist < 20) {
                            minDist = dist;
                            closest = p;
                        }
                    });

                    if (closest) {
                        chartTooltip.style.display = 'block';
                        chartTooltip.innerHTML = `<strong>${closest.count} ads</strong><br>${formatDateShort(closest.date)}`;

                        // Position tooltip below the point
                        const tooltipHeight = chartTooltip.offsetHeight;
                        const tooltipWidth = chartTooltip.offsetWidth;

                        // Center horizontally under the point
                        let left = closest.x - (tooltipWidth / 2);
                        // Ensure it doesn't go off-screen horizontally
                        if (left < 0) left = 0;
                        if (left + tooltipWidth > rect.width) left = rect.width - tooltipWidth;

                        // Position below the point
                        let top = closest.y + 15;
                        // If it would go off-screen below, position above instead
                        if (top + tooltipHeight > rect.height) {
                            top = closest.y - tooltipHeight - 10;
                        }

                        chartTooltip.style.left = left + 'px';
                        chartTooltip.style.top = top + 'px';
                    } else {
                        chartTooltip.style.display = 'none';
                    }
                });

                chartCanvas.addEventListener('mouseleave', function() {
                    chartTooltip.style.display = 'none';
                });
            }
        });

        // Redraw chart on window resize
        window.addEventListener('resize', function() {
            if (document.getElementById('analytics-dialog-overlay').classList.contains('show') &&
                document.getElementById('panel-dates').classList.contains('active')) {
                drawChart();
            }
        });
    </script>
</body>
</html>
